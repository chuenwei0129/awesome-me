# 计算机知识图谱（三）<!-- omit in toc -->

***👀 TIPS: 二级标题可返回目录***

---

> ## 目录

## [学习数据结构有什么用？](https://www.zhihu.com/question/29587605)

至少希望说到某个业务可以用树建模的时候不要有沟通障碍……

因为他们觉得反正招进来之后我也用不上二叉树，你们谁写业务代码的时候用上二叉树了？所以我不会就不会呗。这其实就是“高等数学有啥用，又不能用来买菜”的进化版本。

的确很少有写业务代码的时候会直接用上二叉树。但是真的没有吗？XML/DOM是什么？是不是一棵树？为什么DOM可以和XML一一对应？因为XML序列化就是树的遍历的结果。能和XML对应，也就能跟JSON对应，因为两者都可以对应到树（只是表示逻辑上有些区别）。

一个业务系统里有任务（Task），任务有相应的执行计划（Plan），计划可以用子任务组成，子任务可以是基础任务，也可以通过Plan拆分成更多的子任务。这是什么？这不就是树吗？那么怎么存储？JSON不就很好吗。怎么从JSON加载、再保存会JSON？树的遍历。怎么计算任务总共需要多少个基础任务？树的遍历。怎么计算计划总共需要多少时间？树的遍历。

一个社交系统里，用户可以加好友，好友还有别的好友，这是什么？无向图。如果是知乎这样的关注系统呢？有向图。一个用户点了个赞，扩散到另一个用户至少要经过几次转发？最短路径。我要画一个小圈子里的人之间的关系图，怎么做？最小生成树。我要整理信息路径，看这批用户里哪些生产内容，哪些阅读内容，按什么次序传播，怎么做？拓扑排序。

比如遍历二叉树，你脑子里应该有这样的表述：

『二叉树每个节点有对左右子节点的引用，每个节点都看作是一个二叉树的根节点，便利方式很自然有三种：先访问根节点，然后左，然后右；先访问左，然后根，然后右；先访问左，然后右，最后根。』

『因为每一个左右节点都可以看作一个独立的二叉树，所以这个问题适合用递归方式实现。』

『不过，递归有一个通用原则，就是递归要有一个结束的时候，当一个二叉树的根节点为空时，这个二叉树无需遍历。』

能这样表达出来，就没问题了。

> **学会英语，你就会发现这些都不用自己写 🤪**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220418-gcj.png)

## [探究 JS V8 引擎下的“数组”底层实现](https://zhuanlan.zhihu.com/p/96959371)

### 什么是数组

**维基百科上对于数组的定义：**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/v2-cd0fc3029ce769da5e76aeb00b28e836_1440w.png)

图中有两个关键的点，**相同类型、连续内存**。

C、C++、Java、Scala 等语言中数组的实现，是通过在内存中划分一串**连续的**、**固定长度的空间**，来实现存放一组有限个**相同数据类型**的数据结构。

1. **连续：**

    ![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220514-hwa.png)

2. **固定长度：**

    因为数组的空间是连续的，这就意味着在内存中会有一整块空间来存放数组，如果不是固定长度，那么内存中位于数组之后的区域会没办法分配，内存不知道数组还要不要继续存放，要使用多长的空间。**长度固定，就界定了数组使用内存的界限，数组之外的空间可以分配给别人使用。**

3. **相同数据类型：**

    因为数组的长度是固定的，如果不是相同数据类型，一会存 Int ，一会存 String ，两种不同长度的数据类型，不能保证各自存放几个，这样有悖固定长度的规定，所以也要是相同的数据类型。

### 数组的优缺点

优点

随机访问：可以通过下标随机访问数组中的任意位置上的数据
缺点

对数据的删除和插入不是很友好
查找： 根据下标随机访问的时间复杂度为 O(1)；

插入或删除： 时间复杂度为 O(n)；

### JavaScript 中的数组

- JS 数组可以存放数组、对象、函数、Number、Undefined、Null、String、Boolean 等等不同的数据类型。

- JS 数组可以**动态的改变容量，根据元素的数量来扩容、收缩**。

- JS 数组可以表现的像栈一样，为数组提供了 `push()` 和 `pop()` 方法。也可以表现的像队列一样，使用 `shift()` 和 `push()` 方法，可以像使用队列一样使用数组。

- JS 数组可以使用 `for-each` 遍历，可以排序，可以倒置。

- JS 提供了很多操作数组的方法，比如 `Array.concat()`、`Array.slice()`等。

### 从 V8 源码上看数组的实现

> **V8 数组的实现：** JSArray 是继承自 JSObject，也就是说，**数组是一个特殊的对象**。

V8 中对数组做了一层封装，使其有两种实现方式：快数组和慢数组，**快数组底层是连续内存**，通过索引直接定位，**慢数组底层是哈希表**，通过计算哈希值来定位。两种实现方式各有特点，有各自的使用情况，**也会相互转换**。

1. **快数组**

    快数组是一种线性的存储方式。**新创建的空数组，默认的存储方式是快数组**，快数组长度是可变的，**可以根据元素的增加和删除来动态调整存储空间大小**，内部是通过扩容和收缩机制实现。

2. **慢数组**

    慢数组是一种字典的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 HashTable，其效率会比快数组低。散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

3. **快数组、慢数组的区别**

    - **存储方式方面**：快数组内存中是连续的，慢数组在内存中是零散分配的。
    - **内存使用方面**：由于快数组内存是连续的，可能需要开辟一大块供其使用，其中还可能有很多空洞，是比较费内存的。慢数组不会有空洞的情况，且都是零散的内存，比较节省内存空间。
    - **遍历效率方面**：快数组由于是空间连续的，遍历速度很快，而慢数组每次都要寻找 key 的位置，遍历效率会差一些。

**总结：**

- 快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。
- 慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。
- 每个数组的存储结构不会是一成不变的，会有具体情况下的快慢数组转换

### ArrayBuffer

JS 在 ES6 也推出了可以按照需要分配连续内存的数组，这就是 ArrayBuffer。

ArrayBuffer 会从内存中申请设定的二进制大小的空间，但是并不能直接操作它，需要通过 ArrayBuffer 构建一个视图，通过视图来操作这个内存。

```js
let buffer = new ArrayBuffer(1024)
```

这行代码就申请了 1kb 的内存区域。但是并不能对 ArrayBuffer 直接操作，需要将它赋给一个视图来操作内存。

```js
let intArray = new Int32Array(buffer)
```

这行代码创建了有符号的 32 位的整数数组，每个数占 4 字节，长度也就是 **1024 / 4 = 256** 个。

## [用链表的目的是什么？省空间还是省时间？](https://www.zhihu.com/question/31082722/answer/1928249851)

几乎所有的编程语言都有直接或者间接的应用这种数据结构.

哈希表通常是基于数组进行实现的，但是相对于数组，它也很多的优势：

口它可以提供非常快速的插入-删除-查找操作

口无论多少数据,插入和州除值需要接近常量的时间：即O(1的时间级.实际上，只需要几个机器指令即可完成口哈希表的速度比树还要快，基本可以瞬间查找到想要的元素哈希表相对于树来说编码要容易很多.

相对于数组，链表有一些优点：

内存空间不是必须连续的．可以充分利用计算机的内存．实现灵活的内存动态管理.

链表不必在创建时就确定大小，并且大小可以无限的延伸下去。

链表在插入和删除数据时，时间复杂度可以达到O(1）.相对数组效率高很多.

数组：

优点：

数组的主要优点是根据下标值访问效率会很高， 但是如果我们希望根据元素来查找对应的位置呢？

比较好的方式是先对数组进行排序，再进行二分查找.

缺点：

需要先对数组进行排序，生成有序数组，才能提高查找效率， 另外数组在插入和删除数据时，需要有大量的位移操作(插入到首位或者中间位置的时候)，效率很低

链表：

优点：

口链表的插入和删除操缺点：

口查找效率很低，需要从表中的每个数据项，直口而且即使插入和删除

如果要插入和删除中需要重头先找到对应

哈希表：

优点：

口我们学过哈希表后，已经发现了哈希表的插入/查询 /删除效率都是非常高的口但是哈希表也有很多缺点.

缺点：

口空间利用率不高，底层使用的是数组，并且某些单元是没有被利用的.

口哈希表中的元素是无序的，不能按照固定的顺序来遍历哈希表中的元素.

口不能快速的找出哈希表中的最大值或者最小值这些

特硃的值

树结构：

口我们不能说树结构比其他结构都要好，因为每种数据结构都有自己特定的应用场景.

口但是树确实也综合了上面的数据结构的优点(当然优点不足于盖过其他数据结构，比如效率一般情况下没有哈希表高）

并且也弥补了上面数据结构的缺点.

而且为了模拟某些场景，我们使用树结构会更加方便， 因为数结构的非线性的，可以表示一对多的关系比如文件的目录结构.
