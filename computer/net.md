# 计算机基础知识图谱（二）<!-- omit in toc -->

***👀 TIPS: 二级标题可返回目录***

---

> ## 目录

- [[基础概念]](#基础概念)
- [如果让你来设计网络](#如果让你来设计网络)
- [TCP](#tcp)
- [HTTP](#http)
  - [什么是 HTTP](#什么是-http)
  - [URI 和 URL](#uri-和-url)
  - [TCP/IP 协议栈](#tcpip-协议栈)
  - [DNS 协议](#dns-协议)
    - [域名的层级结构](#域名的层级结构)
    - [域名解析](#域名解析)
    - [DNS 缓存](#dns-缓存)
    - [DNS 的完整解析](#dns-的完整解析)
  - [HTTP 报文格式](#http-报文格式)
    - [请求报文格式](#请求报文格式)
    - [响应报文格式](#响应报文格式)
    - [请求和响应头](#请求和响应头)
  - [HTTP 缓存管理](#http-缓存管理)
  - [HTTP 连接管理](#http-连接管理)
    - [短连接和长连接](#短连接和长连接)
  - [对头阻塞](#对头阻塞)
  - [HTTP 2.0](#http-20)
    - [头部压缩](#头部压缩)
    - [二进制格式](#二进制格式)
    - [服务端推送](#服务端推送)
  - [GET 和 POST 和 OPTIONS](#get-和-post-和-options)
    - [POST 是否比 GET 安全](#post-是否比-get-安全)
    - [GET 相对 POST 的优势是什么](#get-相对-post-的优势是什么)
    - [OPTIONS](#options)
    - [简单请求](#简单请求)
    - [复杂请求](#复杂请求)
  - [HTTP 的明文传输](#http-的明文传输)
  - [HTTP 状态码](#http-状态码)
    - [1xx](#1xx)
    - [2xx](#2xx)
    - [3xx](#3xx)
    - [4xx](#4xx)
    - [5xx](#5xx)
  - [HTTP 无状态](#http-无状态)
  - [HTTP 请求头必传的字段](#http-请求头必传的字段)
  - [代理](#代理)
    - [正向代理](#正向代理)
    - [反向代理](#反向代理)
  - [HTTPS 简述](#https-简述)
    - [对称加密（天王盖地虎）](#对称加密天王盖地虎)
    - [非对称加密](#非对称加密)
    - [HTTPS 加密方式](#https-加密方式)
    - [HTTPS 通讯方式](#https-通讯方式)
    - [HTTPS 的缺点](#https-的缺点)
    - [HTTPS 握手](#https-握手)
- [HTTPS](#https)
- [QUIC](#quic)
- [Websocket](#websocket)
  - [典型的 Websocket 握手](#典型的-websocket-握手)
  - [Websocket 的作用](#websocket-的作用)
    - [ajax 轮询](#ajax-轮询)
    - [long poll](#long-poll)
    - [Websocket 和 HTTP 对比](#websocket-和-http-对比)
- [参考资料](#参考资料)

## [基础概念](#目录)

- **主机：** 计算机网络上任何一种能够连接网络的设备都被称为主机或者说是端系统，比如手机、平板电脑、电视、游戏机、汽车等，随着 5G 的到来，将会有越来越多的终端设备接入网络。

- **半双工模式：** 连接在**集线器**中的端系统每次只能有数据包一个发送，只有这个发送完毕其他电脑才能再发送，这称为半双工模式。

- **全双工模式：** 连接在**交换机**中的端系统可以彼此之间相互通信，相互发送消息互不影响。

- **TCP/IP 协议簇：** 不仅仅只有 TCP 协议和 IP 协议，而是以 TCP、IP 协议为主的一系列协议，比如 ICMP 协议、ARP 协议、UDP 协议、DNS 洗衣、SMTP 协议等。

- **分组：** 当一台端系统向另外一台端系统发送数据时，通常会将数据进行分片，然后为每段加上首部字节，从而形成计算机网络的专业术语：分组。这些分组通过网络发送到端系统，然后再进行数据处理。
  - **报文：** 通常指的是应用层的分组。
  - **报文段：** 通常把运输层的分组称为报文段。
  - **数据报：** 通常将网络层的分组称为数据报。
  - **帧：** 一般把链路层的分组称为帧。

- **单播：** 单播最大的特点就是 1 对 1，早期的固定电话就是单播的一个例子。

- **广播：** 我们一般小时候经常会广播体操，这就是广播的一个事例，主机和与他连接的所有端系统相连，主机将信号发送给所有的端系统。

- **多播：** 多播与广播很类似，也是将消息发送给多个接收主机，**不同之处在于多播需要限定在某一组主机作为接收端。**

- **任播：** 任播是在特定的多台主机中选出一个接收端的通信方式。虽然和多播很相似，**但是行为与多播不同，任播是从许多目标机群中选出一台最符合网络条件的主机作为目标主机发送消息。然后被选中的特定主机将返回一个单播信号，然后再与目标主机进行通信。**

- **CS 体系：** 它是一种面向网络应用的体系结构。把系统中的不同端系统区分为客户和服务器两类，客户向服务器发出服务请求，由服务器完成所请求的服务，并把处理结果回送给客户。在客户-服务器体系结构中，有一个总是打开的主机称为 服务器(Server)，它提供来自于 客户(client) 的服务。我们最常见的服务器就是 Web 服务器，Web 服务器服务于来自 浏览器 的请求。

- **P2P 体系：** 对等体系结构，相当于没有服务器了，大家都是客户机，每个客户既能发送请求，也能对请求作出响应。

- **端口号：** 在同一台主机内，端口号用于**标识不同应用程序进程**。

- **URI：** 它的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够**唯一的标记互联网上资源**。

- **URL：** 它的全称是（Uniform Resource Locator），中文名称是统一资源定位符，它实际上是 URI 的一个子集。

- **Web 服务器：** Web 服务器的正式名称叫做 Web Server，Web 服务器可以向浏览器等 Web 客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个 Web 服务器是 Apache、 Nginx 、IIS。

- **CDN：** CDN 的全称是 Content Delivery Network，即内容分发网络，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，**使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。**

- **WebService：** WebService 是一种 Web 应用程序，**WebService 是一种跨编程语言和跨操作系统平台的远程调用技术。**

- **HTTP：** TCP/IP 协议簇的一种，它是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

- **Session：** Session 其实就是客户端会话的缓存，主要是为了弥补 HTTP 无状态的特性而设计的。**服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。** 当客户端请求服务端时，服务端会为这次请求开辟一块内存空间，这个对象便是 Session 对象，存储结构为 ConcurrentHashMap。

- **Cookie：** HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。**通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。**

- **DNS 协议：** 由于 IP 地址是计算机能够识别的地址，而我们人类不方便记忆这种地址，所以为了方便人类的记忆，使用 DNS 协议，来把我们容易记忆的网络地址映射称为主机能够识别的 IP 地址。

- **根 DNS 服务器：** 最顶级的 DNS 服务器，全世界有 400 多台根域名服务器，由 13 个不同的组织管理，根域名服务器提供 TLD 服务器的 IP 地址。

- **顶级域 DNS 服务器：** 这个我们比较熟悉，像是常见的顶级域（如 com、org、net、edu 和 gov）和所有的国家顶级域（uk、fr、ca 和 jp），TLD 服务器提供了权威 DNS 服务器的 IP 地址。

- **权威 DNS 服务器：** 这个服务器就是因特网上具有公共可访问主机的 DNS 记录的服务器。

- **本地 DNS 服务器：** 一般来说，每个 ISP 都有一台本地 DNS 服务器，本地 DNS 服务器会临近主机端。

- **TELNET 协议：** 远程登陆协议，它允许用户(Telnet 客户端)通过一个协商过程来与一个远程设备进行通信，它为用户提供了在本地计算机上完成远程主机工作的能力。

- **SSH 协议：** SSH 是一种建立在应用层上的安全加密协议。因为 TELNET 有一个非常明显的缺点，那就是在主机和远程主机的发送数据包的过程中是明文传输，未经任何安全加密，这样的后果是容易被互联网上不法分子嗅探到数据包来搞一些坏事，为了数据的安全性，我们一般使用 SSH 进行远程登录。

- **FTP 协议：** 文件传输协议，是应用层协议之一。FTP 协议包括两个组成部分，分为 FTP 服务器和 FTP 客户端。其中 FTP 服务器用来存储文件，用户可以使用 FTP 客户端通过 FTP 协议访问位于 FTP 服务器上的资源。FTP 协议传输效率很高，一般用来传输大文件。

- **多路复用：** 在发送方，从不同的套接字中收集数据块，然后为数据块封装上首部信息从而生成报文段，然后将报文段传递给网络层的过程被称为多路复用。

- **非持续连接：** 每个请求/响应会经过不同的连接，每一个连接都会经过建立、保持、销毁这个过程。并且每个请求/响应后都会断开连接。

- **持续连接：** 每个请求/响应都会经过相同的连接，也就是说每个请求/响应都可以复用这个连接，并且在每个请求/响应后不会断开连接。

- **ARP 协议：** ARP 是一种解决地址问题的协议，通过 IP 位线索，可以定位下一个用来接收数据的网络设备的 MAC 地址。如果目标主机与主机不在同一个链路上时，可以通过 ARP 查找下一跳路由的地址。不过 ARP 只适用于 IPv4 ，不适用于 IPv6。

- **RARP：** RARP 就是将 ARP 协议反过来，通过 MAC 地址定位 IP 地址的一种协议。

- **ICMP 协议：** Internet 报文控制协议，如果在 IP 通信过程中由于某个 IP 包由于某种原因未能到达目标主机，那么将会发送 ICMP 消息，ICMP 实际上是 IP 的一部分。

  ![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/icmp.jpg)

- **DHCP 协议：** DHCP 是一种动态主机配置协议，又被称为即插即用协议或者零配置协议，使用 DHCP 就能实现自动设置 IP 地址、统一管理 IP 地址分配，实现即插即用。

- **NAT 协议：** 网络地址转换协议，它指的是所有本地地址的主机在接入网络时，都会要在 NAT 路由器上讲其转换成为全球 IP 地址，才能和其他主机进行通信。

- **BGP：** 边界网关协议，这个协议将因特网中数以千计的 ISP 连接起来。

- **以太网：** 以太网是一种当今最普遍的局域网技术，它规定了物理层的连线、电子信号和 MAC 协议的内容。

- **VLAN：** 虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，所以称为虚拟局域网。

- **明文：** 没有被加密过的内容都被称为明文。

- **Socket：** Socket **是应用层与 TCP/IP 协议族通信的中间软件抽象层**，它是一组接口。在设计模式中，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。进程可类比于一座房子，而它的套接字可以类比于它的门。当一个进程想向位于另外一台主机上的另一个进程发送报文时，它把报文推出该门。

  ![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/socket.jpg)

## [如果让你来设计网络](#目录)

**你是一台电脑，你的名字叫 A**，你希望与另一台电脑 B 建立通信，于是你们各开了**一个网口**，用**一根网线**连接了起来。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640.gif)

有一天，一个新伙伴 C 加入了，每个人开**两个网口**，用一共**三根网线**，彼此相连。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640.png)

随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-1.png)

于是你们发明了一个**中间设备**，你们将网线都插到这个设备上，由这个设备做**转发**，就可以彼此之间通信了。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-2.png)

你给它取名叫**集线器**，它仅仅是无脑将电信号**转发到所有出口（广播）**，不做任何处理，你觉得它是没有智商的，因此把人家定性在了**物理层**。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-1.gif)

由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？

首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，**全局唯一**的名字作为标识，你把这个更高端的名字称为 **MAC 地址**。

你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。

这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-3.png)

B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便**收下**。

其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便**丢弃**。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-2.gif)

虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。

如果把这个集线器弄得更智能一些，**只发给目标 MAC 地址指向的那台电脑**，就好了。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-3.gif)

虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做**交换机**。也正因为这一点点智能，你把它放在了另一个层级，**数据链路层**。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-4.png)

交换机内部维护一张 **MAC 地址表**，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。

|     MAC 地址      | 端口  |
| :---------------: | :---: |
| bb-bb-bb-bb-bb-bb |   1   |
| cc-cc-cc-cc-cc-cc |   3   |
| aa-aa-aa-aa-aa-aa |   4   |
| dd-dd-dd-dd-dd-dd |   5   |

假如你仍然要发给 B 一个数据包，到达交换机时，交换机内部通过自己维护的 MAC 地址表，**发现目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上**，于是把数据从 1 号端口发给了 B，完事~

你给这个通过这样传输方式而组成的小范围的网络，叫做**以太网**。

> ❓ **当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？**

假如在 MAC 地址表为空是，你给 B 发送了数据包，由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：

**MAC：aa-aa-aa-aa-aa-aa-aa
端口：4**

交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了**所有端口**，也即发给了所有机器。

之后，只有机器 B 收到了确实是发给自己的包，于是做出了**响应**，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：

**MAC：bb-bb-bb-bb-bb-bb
端口：1**

过程如下

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-4.gif)

经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~

随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-5.png)

但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。

最终，**两个交换机将分别记录 A ~ H 所有机器的映射记录**。

> **左边的交换机**

|     MAC 地址      | 端口  |
| :---------------: | :---: |
| bb-bb-bb-bb-bb-bb |   1   |
| cc-cc-cc-cc-cc-cc |   3   |
| aa-aa-aa-aa-aa-aa |   4   |
| dd-dd-dd-dd-dd-dd |   5   |
| ee-ee-ee-ee-ee-ee |   6   |
| ff-ff-ff-ff-ff-ff |   6   |
| gg-gg-gg-gg-gg-gg |   6   |
| hh-hh-hh-hh-hh-hh |   6   |

> **右边的交换机**

|     MAC 地址      | 端口  |
| :---------------: | :---: |
| bb-bb-bb-bb-bb-bb |   1   |
| cc-cc-cc-cc-cc-cc |   1   |
| aa-aa-aa-aa-aa-aa |   1   |
| dd-dd-dd-dd-dd-dd |   1   |
| ee-ee-ee-ee-ee-ee |   2   |
| ff-ff-ff-ff-ff-ff |   3   |
| gg-gg-gg-gg-gg-gg |   4   |
| hh-hh-hh-hh-hh-hh |   6   |

这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。

但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。

**交换机已经无法记录如此庞大的映射关系了。**

此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。

那我可不可以让那根红色的网线，接入一个**新的设备**，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次**转发**呢？

这个设备就是**路由器，** 它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发，你把它定在了**网络层。**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-8.png)

**注意，路由器的每一个端口，都有独立的 MAC 地址。**

由于 MAC 地址如同身份证上的身份证号码，具有唯一性（只要不更改自己的 MAC 地址）。如果你希望统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念）你就需要发明了一个新的地址，一个可以随时修改的 IP 地址

现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是软件层面上的，可以随时修改，MAC 地址一般是无法修改的。

如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，"将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！"。

现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。

假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-9.png)

但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。

A ~ 路由器这段的包如下：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-10.png)

路由器到 C 这段的包如下：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-11.png)

> ❓ A 给 C 发数据包，怎么知道是否要通过路由器转发呢？

答案：**子网**

**如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。**

**如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。**

假如某台机器的子网掩码定为 255.255.255.0

**将源 IP 与目的 IP 分别同这个子网掩码进行与运算，相等则是在一个子网，不相等就是在不同子网。**

比如

- **A电脑：** 192.168.0.1 & 255.255.255.0 = 192.168.0.0

- **B电脑：** 192.168.0.2 & 255.255.255.0 = 192.168.0.0

- **C电脑：** 192.168.1.1 & 255.255.255.0 = 192.168.1.0

- **D电脑：** 192.168.1.2 & 255.255.255.0 = 192.168.1.0

> ❓ A 如何知道，哪个设备是路由器？

答案：**在 A 上要设置默认网关**

所以默认网关，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-13.png)

> ❓ 路由器如何知道 C 在哪里？

**答案：路由表。**

现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，**路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去**，才能直接（或间接）地最终到达目的地 C 呢。

路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。

这个表就叫**路由表**。

|     目的地址     | 下一跳 | 端口  |
| :--------------: | :----: | :---: |
|  192.168.0.0/24  |        |   0   |
| 192.168.0.254/32 |        |   0   |
|  192.168.1.0/24  |        |   1   |
| 192.168.1.254/32 |        |   1   |

这就很好理解了，路由表就表示，**192.168.0.xxx 这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口**。下一跳列还没有值，我们先不管

配合着结构图来看（这里把子网掩码和默认网关都补齐了）图中 & 笔误，结果应该是 .0

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-5.gif)

> ❓ 刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？

**答案：arp。**

假如你（A）此时**不知道**你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？

答案很简单，在网络层，**我需要把 IP 地址对应的 MAC 地址找到**，也就是通过某种方式，找到 **192.168.0.2** 对应的 MAC 地址 **BBBB**。

这种方式就是 **arp 协议**，同时电脑 A 和 B 里面也会有一张 **arp 缓存表**，表中记录着 **IP 与 MAC 地址**的对应关系。

|   IP 地址   | MAC 地址 |
| :---------: | :------: |
| 192.168.0.2 |   BBBB   |

一开始的时候这个表是**空的**，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会**广播**一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个**响应**。此时 A 便更新了自己的 arp 表。

这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整。

好了，总结一下，到目前为止就几条规则

> **从各个节点的视角来看**

**电脑视角：**

- 首先我要知道我的 IP 以及对方的 IP
- 通过子网掩码判断我们是否在同一个子网
- 在同一个子网就通过 arp 获取对方 mac 地址直接扔出去
- 不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去

**交换机视角：**

- 我收到的数据包必须有目标 MAC 地址
- 通过 MAC 地址表查映射关系
- 查到了就按照映射关系从我的指定端口发出去
- 查不到就所有端口都发出去

**路由器视角：**

- 我收到的数据包必须有目标 IP 地址
- 通过路由表查映射关系
- 查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）
- 查不到则返回一个路由不可达的数据包

> **网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。**

**涉及到的三张表分别是：**

- 交换机中有 **MAC 地址**表用于映射 MAC 地址和它的端口
- 路由器中有**路由表**用于映射 IP 地址(段)和它的端口
- 电脑和路由器中都有 **arp 缓存表**用于缓存 IP 和 MAC 地址的映射关系

**这三张表是怎么来的：**

- MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。
- 路由表是各种路由算法 + 人工配置逐步完善起来的。
- arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。

知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-14.png)

这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。

也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。

|     目的地址     |    下一跳     | 端口  |
| :--------------: | :-----------: | :---: |
|  192.168.0.0/24  |               |   0   |
| 192.168.0.254/32 |               |   0   |
|  192.168.1.0/24  |               |   1   |
| 192.168.1.254/32 |               |   1   |
|  192.168.2.0/24  | 192.168.100.5 |       |
| 192.168.100.0/24 |               |   2   |
| 192.168.100.4/32 |               |   2   |

**这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-15.png)

**详细过程动画描述：**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-6.gif)

**详细过程文字描述：**

**1.** 首先 A（192.168.0.1）通过子网掩码（255.255.255.0）计算出自己与 F（192.168.2.2）并不在同一个子网内，于是决定发送给默认网关（192.168.0.254）

**2.** A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址。

**3.** A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包

**4.** 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器1

**5.** 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5

**6.** 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从 2 号口发出去。

**7.** 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从 1 号口把数据包送出去。

**8.** 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF，将其封装在数据链路层头部，并从 1 号端口把包发出去。

**9.** 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF，查询其 MAC 地址表，发现应该从其 6 号端口出去，于是从 6 号端口把数据包发出去。

**10.** **F 最终收到了数据包！** 并且发现目的 MAC 地址就是自己，于是收下了这个包

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-7.gif)

至此，经过物理层、数据链路层、网络层这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），**理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/640-16.png)

> 什么是私网和公网

私网也称内网，也叫局域网，企业或者家庭用户搭建的网络为私网，比如公司里的很多台计算机就组成了一个子网，它们内部之间是可以互相通信的，而且它们组成的子网地址是**私有地址**，**不同的子网私有地址是可以相同的**。

但如果你要访问 Google 那就要出这个子网，到公网上去找，公网才是我们所说的广义上的的互联网。

在公网上每个设备的 IP 都是**全球唯一**。

也就是说私网中的主机如果想要访问公网，必须将私网中的 IP 转为公网上的 IP，我们把这个过程称为 NAT（Network Address Translation，网络地址转换）

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/v2-acf52b5dba31ed073be16388cc9c57fc_1440w.jpg)

相信细心的你一定发现了一个问题，子网中的地址通过 NAT 转成公网请求后，它的响应包该怎么找到请求的主机呢，也就是是私网 IP 与公网 IP 应该要有个映射关系，比较常用的是端口映射。我们前面只提到了 IP，mac，实际上还有一个端口（port）没提，一个 TCP 连接是需要知道请求方与被请求方的 iP,port的，简称 **TCP 的四元组**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/v2-eb342d7a16748980cea70b3e6d2b66fa_1440w.jpg)

也就是说请求包中除了有 IP 地址，实际上还有端口

NAT 为了节省 IP 资源，往往采用端口映射的方式

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/v2-c5cfd29db16110f0cd9d7f148be6b5e7_1440w.jpg)

这样的话，请求除了公网地址变了，端口地址也变了，但请求回来的时候也会把公网的 IP 和端口转成内网的 IP+端口，也就解决了响应包找不到主机的问题

## [TCP](#目录)

> [你管这破玩意儿叫 TCP？](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247491962&idx=1&sn=aa4414483edaba487c080e91ad0efb93&chksm=c2c59bd7f5b212c12231394c585f3b063b0b2d5b05d6f05fddccdb4e856875e7ee1127bb30a7&cur_album_id=1700901576128643073&scene=189#wechat_redirect)

## [HTTP](#目录)

### 什么是 HTTP

`HTTP` 全称 `HyperText Transfer Protocol`「超文本传输协议」,拆成三个部分来看，即「超文本」,「传输」,「协议」

**超文本**：即「超越了普通文本的文本」，即音视频，图片，文件的混合体，除了这些超文本内容外，最关键的是超文本中含有**超链接**，超链接意味着网页等文件内容的超文本上可以点击链接到其他页面上，**互联网就是通过这样的超链接构成的**。

**传输**: 传输意味着至少有两个参与者，比如 `A`，`B`，这意味着 **HTTP 协议是个双向协议**，一般是将「超文本」按照约定的协议以二进制数据包的形式从 `A` 传到 `B` 或 `B` 传到 A，`A <===> B`，我们把发起请求的叫请求方，接到请求后返回数据的那一方称为响应方，但需要注意的是**传输也不限于两个参与者，允许中间有中转或者接力**，只要参与者间遵循约定的协议即可传输。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-1.jpg)

**协议**：`HTTP` 是一个协议，啥是协议？在日常生活中协议并不少见，比如我们租房时签订的租房协议，入职后和企业签订的劳动合同协议。

所以给 `HTTP` 下一个比较准确的定义：

**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。**

### URI 和 URL

使用 `URI`（Uniform Resource Identifier）即**统一资源标识符**就可以**唯一定位互联网上的资源**。

`URL` 是 `URI` 的一种子集，区别就是 `URI` 定义资源，而 `URL` 不单定义这个资源，**还定义了如何找到这个资源**。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-2.jpg)

### TCP/IP 协议栈

`TCP/IP` 协议栈总共有四层

- `link layer`: **链接层**，负责在以太网，`WIFI` 这样的底层网络上发送原始数据包，工作在网卡这一层，使用 `MAC` 地址来标记网络上的设备，所以也叫 `MAC` 层

- `Internet layer`: **网络层**，`IP` 协议即处于这一层，提供**路由**和**寻址**的功能，使两终端系统能够互连且决定最佳路径，並具有一定的拥塞控制和流量控制的能力

- `transport layer`: **传输层**，该层的协议为应用进程提供端到端的通信服务，这层主要有 `TCP`，`UDP` 两个协议，
  - `TCP` 提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务，
  - `UDP` 不提供复杂的控制机制，利用 `IP` 提供面向无连接的简单消息传输

- `application layer`: **应用层**，前面三层已经为网络通信打下了坚实的基础，这层可发挥的空间就大很多了，应用层协议可以想象为不同的服务，每个应用层协议都是为了解决某一类应用问题而生的，每一个服务需要用不同的协议，规定应用进程在通信时所遵循的协议。

> 我们可以把前面三层认为是高速公路的基础设施，至于要传什么货物，高速公路是否要关闭等则由应用层决定。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-3.jpg)

> 通过这样分层的方式，每个层各司其职，只要管好自己的工作即可，可扩展性很好，**比如对于 `HTTP` 来说，它底层可以用 `TCP`，也可以用 `UDP` 来传输**，哪天如果再出现了更牛逼的协议，也可以替换之，不影响上下层，这就是计算机中比较有名的分层理论：**没有什么是分层解决不了的，如果有那就再分一层。**

### DNS 协议

应用层在请求传输数据时必须事先要知道对方的 `IP` 地址，然后才能开始传输。

但 `IP` 地址是由 `161.117.232.65` 这样的数字组成的，正常人根本记不住，同样的，正常人只会记住 `http://baidu.com` 这样的网址，那就需要有类似电话本这样的翻译器把网址转成 `IP` 地址，`DNS`（域名服务器）就是干这个事的

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-4.jpg)

#### 域名的层级结构

类似 `http://www.baidu.com` 这样的网址也叫域名，是一个有层次的结构, 最右边的被称为顶级域名，然后是二级域名，层级关系向左降低，最左边的是主机名，通常用来表示主机的用途，比如 「www」 表示提供万维网服务

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-5.jpg)

#### 域名解析

`http://www.apple.com` 的 `DNS` 解析如下

1. 首先访问根域名服务器，获取 `com` 顶级域名服务器的地址
2. 请求 `com` 顶级域名服务器，返回 `http://apple.com` 域名服务器的地址
3. 然后返回 `http://apple.com` 域名服务器，返回 `http://www.apple.com` 的地址

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-6.jpg)

#### DNS 缓存

全世界的设备多如牛毛，如果每发一次请求都要按上面的 DNS 解析来获取 IP，那估计 DNS 解析系统就要炸了，如何缓解这种压力呢，答案是用缓存

- 非权威域名服务器（类似 Google 的 `8.8.8.8` DNS 解析服务器）
- 操作系统缓存（`/etc/hosts` 就是操作系统 DNS 缓存的一种）
- 浏览器缓存

#### DNS 的完整解析

这样的话如果请求 `http://www.example.com`，DNS 的完整解析流程如下:

1. 浏览器中输入 `http://www.example.com` 后，会先查看浏览器的 `DNS` 缓存是否过期，未过期直接取缓存的，已过期会继续请求操作系统的缓存（`/etc/hosts` 文件等）还未找到，进入步骤 2

2. 请求本地地址配置的 `DNS resolver`（非权威域名服务器），一般由用户的 `Internet` 服务提供商 (ISP) 进行管理

3. `DNS resolver` 将 `http://www.example.com` 的请求转发到 `DNS` 根名称服务器, 根服务器返回「.com」顶级域名服务器地址

    ...

`DNS` 解析程序还会将 `http://example.com` 的 `IP` 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 `http://example.com` 时更快地作出响应。

一个域名解析出多个 `ip` 地址，这样的话 `client` 可以随机选择其中一个请求，这就是我们常说的 **DNS 负载均衡**，可有效缓存 `server` 压力。

### HTTP 报文格式

请求和响应报文都由「起始行」，「头部」，「空行」，「实体」 四个部分组成，只不过起始行稍有不同。

#### 请求报文格式

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-7.jpg)

请求方法比较常见的有以下几类

1、**GET**: 请求 `URL` 指定的资源，指定的资源经服务器端解析后返回响应内容，**GET 方法具有幂等性**，即无论请求多次，都只会返回资源，而不会额外创建或改变资源，`GET` 请求**只传请求头，不传请求体**。

2、**POST**: 主要用来创建，修改，上传资源，不具有幂等性，一般将要请求的资源附在请求体上传输

3、**OPTIONS**: 列出可对资源实行的方法，这个方法很少见，但在跨域中会用到，也比较重要

#### 响应报文格式

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-8.jpg)

响应报文主要有如下五类状态码：

- `1××`：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
- `2××`：成功，报文已经收到并被正确处理；
- `3××`：重定向，资源位置发生变动，需要客户端重新发送请求；
- `4××`：客户端错误，请求报文有误，服务器无法处理；
- `5××`：服务器错误，服务器在处理请求时内部发生了错误。

#### 请求和响应头

请求和响应头部报文的 `header` 格式基本都是一样的，都是 `key-value` 的形式，**对 `HTTP` 报文的解析和处理其实本质上就是对头字段的处理**，`HTTP` 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，理解了头字段，基本上也就理解了 `HTTP`

请求报文的「Accept」，「Accept-Charset」,「Accept-Encoding」，「Accept-Language」,「Content-Language」,即为内容协商的判定标准。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-9.jpg)

请求方如果要上传资源（一般是 POST 请求），可以在用 `Content-Type` 指定资源所属类型，如果请求方想要获取资源（GET 请求），可以用 `Accept` 请求头指定想要获取什么资源，这样 `server` 找到匹配的资源后就可以在 `Content-Type` 中指定返回的资源类型，浏览器等客户端看到后就可以据此解析处理了

> 注意：如果返回的 `Content-Type` 是 `application/octet-stream`，这个类型是应用程序文件的默认值，意思是**未知的应用程序文件**，浏览器一会不会自动执行或询问执行，**会直接下载**。

### HTTP 缓存管理

对于资源来说，由于有些挺长时间内都不会更新，所以没必要每次请求都向 `server` 发起网络请求，如果第一次请求后能保存在本地，下次请求直接在本地取，那无疑会快得多，对服务器的压力也会减少。

涉及到缓存的请求头为 `Cache-Control`。**这个缓存指令是单向的**，也就是说请求中设置的指令，不一定包含在响应中，请求中如果没有传 `Cache-Control`，`server` 也可以返回 `Cache-Control`。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-10.jpg)

**如图示：客户端发起请求后，服务器返回 `Cache-Control： max-age=30`，代表资源在客户端可以缓存 30 秒，30 秒内客户端的请求可以直接从缓存获取，超过 30 秒后需要向服务器发起网络请求。**

`max-age` 是 `HTTP` 缓存控制最常用的属性，表示资源存储的最长时间，需要注意的是，时间的计算起点是响应报文的创建时刻（即 `Date` 字段，也就是离开服务器的时刻），超过后客户端需要重新发起请求

除此之外，还有其它属性值如下:

- `no-cache`: **缓存但重新验证**服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回 304），则缓存才使用本地缓存副本。

- `no-store`: 这才是真正的不允许缓存，比如秒杀页面这样变化非常频繁的页面就不适合缓存

- `must-revalidate`：一旦资源过期（比如已经超过 max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-11.jpg)

`Cache-Control` 只能刷新数据，但不能很好地利用缓存，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版，存在一定的性能稳定，所以 `HTTP` 又引入了条件缓存（协商缓存）。

条件请求以 `If` 开头，有「If-Match」，「If-Modified-Since」，「If-None-Match」,「If-Range」,「If-Unmodified-Since」五个头字段，我们最常用的是「if-Modified-Since」和「If-None-Match」这两个头字段，所以重点介绍一下。

- `if-Modified-Since`：指的是文件最后修改时间，服务器只在所请求的资源**在给定的日期时间之后对内容进行过修改的情况下**才会将资源返回，如果请求的资源从那时起未经修改，那么**返回一个不带有消息主体的 `304` 响应**，需要第一次请求提供「Last-modified」，只能精确到一秒，第二次请求就可以在 「if-Modified-Since」首部带上此值了

- `If-None-Match`：条件请求首部，对于 `GET` 和 `HEAD` 请求方法来说，当且仅当服务器上没有任何资源的 `ETag` 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 `200`，

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-12.jpg)

> ETag 是实体标签（Entity Tag）的缩写，是资源的唯一标识，主要解决修改时间无法准确区分文件变化的问题，比如文件在一秒内修改了多次，由于修改时间是秒级的，用 `if-Modified-Since` 就会误认为资源没有变化，而每次文件修改了都会修改 `ETag`，也就是说 `ETag` 可以精确识别资源的变动, 所以如果对资源变化很敏感觉的话，应该用 `If-None-Match`
>
> 注：ETag 有强，弱之分，强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有「W/」标记，只要求资源在语义上没啥变化，比如加了几个空格等等。

需要注意的是不管是 `if-Modified-Since` 还是 `If-None-Match`，**这两者只会在资源过期（即存活时间超 max-age）后才会触发**，

在开发环境下，缓存可能会影响我们联调，我们希望每次请求都从 `server` 拿，而不是缓存里，该怎么办？这种情况下就要用到刷新或者强制刷新了。

如果是刷新，请求头里会加上一个 `Cache-Control: max-age=0`，代表需要最新的资源，浏览器看到了后就不会使用本地资源，会向 `server` 请求，如果是强制刷新，请求头会加上 `Cache-Control: no-cache`，也会向 `server` 发送请求。

### HTTP 连接管理

#### 短连接和长连接

首先我们知道双方要建立可靠连接要经过 `TCP` 的三次握手，然后才能开始传输 `HTTP` 的报文，报文传输之后要经过四次挥手断开连接

`HTTP` `0.9`，`1.0` 时期，发送完 `HTTP` 报文后， 连接立马关闭，这种连接被称为短链接，短链接效率非常低下，大量时间浪费在无意义的三次握手和四次挥手上。

`HTTP` `1.1` 对此进行了改进，每次报文发送后不立即关闭，可复用，长链接由于减少了大量无意义的三次握手，四次挥手，效率大大提升了！

我们可以在请求头里明确要求使用长链接，指定 `Connection: keep-alive` 即可，**在 `HTTP 1.1` 就算不指定也是默认开启的**。

> 如果服务器支持长链接，不管客户端是否显式要求长链接，它都会在返回头里带上 `Connection: keep-alive`，这样接下来双方就会使用长连接来收发报文，客户端如果想显式关闭关闭，只需要指定 `Connection: Close` 头字段即可。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-13.jpg)

### 对头阻塞

长连接让传输效率大大提升，但新的问题又来了，因为 `HTTP` 规定报文必须一发一收，如果在要连接上发多个 `HTTP` 报文，**多个报文会被累积到队列里依次处理（不能并行处理）只要队首的请求被阻塞了**，后续 `HTTP` 的发送就受到影响，这就是有名的队头阻塞

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-14.jpg)

> HTTP 1.1 提出了**管线化机制**，一次可以发送多个请求，但依然要等前一个请求的响应返回后才能处理下一个请求，所以这种机制聊胜于无。

**对头阻塞本质上其实是因为我们没法区分每一个请求。**

每个数据链接层的包（准确地说，链路层的包应该叫帧）规定的 `IP` 数据报的大小是有限制的，一般把这个大小限制称为最大传输单元（MTU, Maximum Transmission Unit）, `TCP` 数据报的大小也是有限制的，我们称之为 `MSS`（Maximum Transmission Unit）

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-16.jpg)

对于每一个最终发送的以太网包能传输的应用层数据是有限的，如果上层的应用层要发的数据大小超过了以太网包的大小，就需要对其进行拆分，分成几个以太网包再传输。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-15.jpg)

**接收方拿到每个包的应用层数据再组装成应用层数据，然后一个请求才算接收完成**，响应也是类似的原理。

接收方通过 `Content-Length` 就可以判断几个请求报文组合后大小是否达到这个设置值，如果是说明报文接收完毕，就可以对请求进行解析了，如果少于这个值，说明还需要接收请求包直到达到这个设定的值。

> Content-Length 指的是实体消息首部，也就是在 POST，PUT 等方法中传输实体数据时才会出现，GET 请求不会出现

<!-- http 1.1 对头阻塞原因，没法区分每个数据包所属的请求，http 2 可以区分，响应也是没法区分，那么请求响应必须一一对应 -->
**在底层，每个请求是复用同一个连接的，也就是说每个包发送都是串行的。**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-17.jpg)

> 🌿 在 `HTTP 1.1` 中，**没法区分每个数据包所属的请求**，**所以它规定每个请求只能串行处理**，每个请求通过 `Content-Length` 判断接收完每个请求的数据包并处理后，才能再处理下一个请求，这样的话如果某个请求处理太慢就会影响后续请求的处理。

### HTTP 2.0

`HTTP 2.0` 只在语法上做了重要改进，完全变更了 `HTTP` 报文的传输格式，与 `HTTP 1.1` 的语义完全相同

#### 头部压缩

`HTTP 1.1` 考虑了 `body` 的压缩，但没有考虑 `header` 的压缩, 经常出现传了头部上百，上千字节，但 `Body` 却只有几十字节的情况，浪费了带宽。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-18.jpg)

那么 `HTTP 2.0` 是如何解决的呢？它开发了专门的 「HPACK」算法，在客户端和服务器两端建立字典，用索引号表示重复的字符串，还采用哈夫曼编码来压缩数字和整数，可以达到最高达 90% 的压缩率

- 维护一份静态的字典（Static table），包含常见的头部名称，以及特别常见的头部名称与值的组合。这样的话如果请求响应命中了静态字典，直接发索引号即可

- 维护一份相同的动态字典（Dynamic table），可以动态地添加字典，这样的话如果客户端首次请求由于「User-Agent: xxx」,「host:xxx」,「Cookie」这些的动态键值对没有命中静态字典，还是会传给服务器，但服务器收到后会基于传过来的键值对创建动态字典条目

- 支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）：对于静态、动态字典中不存在的内容，可以使用哈夫曼编码来减小体积。`HTTP/2` 使用了一份静态哈夫曼码表，也需要内置在客户端和服务端之中。

#### 二进制格式

`HTTP 1.1` 是纯文本形式，而 `2.0` 是完全的二进制形式，它把 `TCP` 协议的部分特性挪到了应用层，把原来的 `Header + Body` 消息打散为了数个小版的二进制"帧"（Frame）,“HEADERS”帧存放头数据、“DATA”帧存放实体数据

`HTTP 2` 定义了「流」（stream）的的概念，它是二进制帧的双向传输序列，同一个消息往返的数据帧 （header 帧和 data 帧）会分配一个唯一的流 `ID`，**这样我们就能区分每一个请求**。在这个虚拟的流里，数据帧按先后次序传输，到达应答方后，将这些数据帧按它们的先后顺序组装起来，最后解析 `HTTP 1.1` 的请求头和实体。

**在同一时间，请求方可以在流里发请求，应答方也可以也流里发响应，对比 `HTTP 1.1` 一个连接一次只能处理一次请求-应答，吞吐量大大提升**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-23.jpg)

一个连接里多个流可以同时收发请求-应答数据帧，每个流中数据包按序传输组装

所有的流都是在同一个连接中流动的，这也是 `HTTP 2.0` 经典的**多路复用**（ Multiplexing），另外由于每个流都是独立的，所以谁先处理好请求，谁就可以先将响应通过连接发送给对方，也就解决了队头阻塞的问题。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-19.jpg)

**在 `HTTP 2` 中，两个请求同时发送，可以同时接收，而在 `HTTP 1.1` 中必须等上一个请求响应后才能处理下一个请求**

`HTTP 2` 引入的流，帧等语法层面的改造确实让其传输效率有了质的飞跃，但是它依然存在着队头阻塞

其实主要是因为 `HTTP 2` 的分帧主要是在应用层处理的，而分帧最终还是要传给下层的 `TCP` 层经由它封装后再进行传输，每个连接最终还是顺序传输这些包，

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-20.jpg)

> TCP 是可靠连接，为了保证这些包能顺序传给对方，会进行丢包重传机制，如果传了三个包，后两个包传成功，但第一个包传失败了，`TCP` 协议栈会把已收到的包暂存到缓存区中，停下等待第一个包的重传成功，这样的话在网络不佳的情况下只要一个包阻塞了，由于重传机制，后面的包就被阻塞了，上层应用由于拿不到包也只能干瞪眼了

由于这是 `TCP` 协议层面的机制，无法改造，所以 `HTTP 2` 的队头阻塞是不可避免的。

`HTTP 3` 对此进行了改进，将 `TCP` 换成了 `UDP` 来进行传输，由于 `UDP` 是无序的，不需要断建连，包之间没有依赖关系，所以从根本上解决了“队头阻塞”, 当然由于 `UDP` 本身的这些特性不足以支撑可靠的通信，所以 `Google` 在 `UDP` 的基础上也加了 `TCP` 的连接管理，拥塞窗口，流量控制等机制，这套协议我们称之为 `QUIC` 协议。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-21.jpg)

#### 服务端推送

`HTTP` 需要请求方发起请示，然后应答方对此作出响应，应答方不会无缘无故地发响应给请求方，另外请求和应答方的角色是可以互换的，比如 `HTTP 2` 中 `server` 是可以主动 `push` 给 `client` 的，这种情况下 `server` 即为请求方，`cilent` 即为应答方

### GET 和 POST 和 OPTIONS

#### POST 是否比 GET 安全

是的，`POST` 要比 `GET` 安全一点点，注意，是一点点。。。两者都是明文传送，但是有一个细节，就是 `GET` 的 `URL` 会被放在浏览器历史和 `WEB` 服务器日志里面。`POST` 发完基本就木有了。所以如果你把关键数据放在 `GET` 里面，被人偷窥了浏览器，或者 `WEB` 服务器被入侵日志被人倒去了，基本泄露可能性 `100%`。而 `POST` 来说，日志没有记录，只要数据库服务器不被入侵，基本还是安全的。

当然如果被抓了包，这一切都没有什么卵用，所以，`HTTPS` 该用还是得用。

#### GET 相对 POST 的优势是什么

最大的优势是，`GET` 的 `URL` 可以人肉手输啊。。。本质上面，`GET` 的所有信息都在 `URL`，所以很方便的记录下来重复使用。

所以下列情况

- 请求中的 `URL` 可以被手动输入
- 请求中的 `URL` 可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。
- 请求中的 `URL` 是可以被搜索引擎收录的。
- 带云压缩的浏览器，比如 `Opera mini/Turbo 2` , 只有 `GET` 才能在服务器端被预取的。
- 请求中的 `URL` 可以被缓存。

请使用 GET.

> 可以重复的交互，比如取个数据，跳个页面， 用 `GET`，不可以重复的操作，比如创建一个条目/修改一条记录，用 `POST`, 因为 `POST` 不能被缓存，所以浏览器不会多次提交。`GET` 请求也可以用 `body` 传输数据（但不建议）

#### OPTIONS

`HTTP` 的 `OPTIONS` 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 `URL` 使用 `OPTIONS` 方法，也可以对整站（通过将 `URL` 设置为 “*”）使用该方法。”

简单来说，就是可以用 `options` 请求去嗅探某个请求在对应的服务器中都支持哪种请求方法。

在前端中我们一般不会主动发起这个请求，但是往往你可以看到浏览器中相同的请求发起了 `2` 次

其实，这是因为在跨域的情况下，在浏览器发起"复杂请求"时主动发起的。

跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 `HTTP` 请求方法（特别是 `GET` 以外的 `HTTP` 请求，或者搭配某些 `MIME` 类型的 `POST` 请求），浏览器必须首先使用 `OPTIONS` 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 `HTTP` 请求。

某些请求不会触发 `CORS` 预检请求，这样的请求一般称为"简单请求",而会触发预检的请求则称为"复杂请求"。

而在项目中常见的 `Content-Type: application/json` 及 `Authorization: <token>` 为典型的非简单请求，在发送请求时往往会带上 `Options`

#### 简单请求

- 请求方法为 GET、HEAD、POST 时发的请求
- 人为设置了规范集合之内的首部字段，如 `Accept/Accept-Language/Content-Language/Content-Type/DPR/Downlink/Save-Data/Viewport-Width/Width`
- `Content-Type` 的值仅限于下列三者之一,即 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`
- 请求中的任意 `XMLHttpRequestUpload` 对象均没有注册任何事件监听器；
- 请求中没有使用 `ReadableStream` 对象。

#### 复杂请求

- 使用了下面任一 `HTTP` 方法，`PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH`
- 人为设置了以下集合之外首部字段，即简单请求外的字段
- `Content-Type` 的值不属于下列之一，即`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

### HTTP 的明文传输

`HTTP` 的明文传输带来的问题是无法防止中间人截获、盗取和篡改信息，从你的路由器、运营商到对方服务器，中间每一步都是明文。这里面可下手的地方太多了。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-1.jpg)

比如很多地方电信运营商就擅自给用户的网页插入浮动窗口广告，甚至影响正常浏览，不知情的用户还骂网站。其实这就是 HTTP 的明文特性导致的天然漏洞，对 HTTPS 网站则束手无策。因为后者只有用户和服务器能看到真实请求数据，对所有中间环节都加了密，自然也就无从篡改。

比如与运营商合作的营销公司。他们可以通过截获请求盗取并伪造你的身份信息来关注一票僵尸号或给某些营销微博点赞。方法也简单，把你本次成功访问微博的 `cookie` 存下来，直接用这个 `cookie` 发送关注别人的请求就行。这种情况根本无需窃取你密码，也就无所谓密码大量泄露了。

### HTTP 状态码

#### 1xx

`1xx` 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。

#### 2xx

`2xx` 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。

- 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 `body` 数据。
- 「204 No Content」也是常见的成功状态码，与 `200 OK` 基本相同，但响应头没有 `body` 数据。
- 「206 Partial Content」是应用于 `HTTP` 分块下载或断点续传，表示响应返回的 `body` 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

#### 3xx

`3xx` 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 `URL` 重新发送请求获取资源，也就是重定向。

- 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 `URL` 再次访问。
- 「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 `URL` 来访问。
- `301` 和 `302` 都会在响应头里使用字段 `Location`，指明后续要跳转的 `URL`，浏览器会自动重定向新的 `URL`。
- 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

#### 4xx

`4xx` 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。

- 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

#### 5xx

`5xx` 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。

- 「500 Internal Server Error」与 `400` 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

### HTTP 无状态

`HTTP` 的每次的收发报文都是完全独立，没有任何联系的，服务器收到每个请求响应后，不会记录这个请求的任何信息，比如访问一个网站需要反复进行登录操作

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-22.jpg)

`Session` 可以认为是 `Server` 用来追踪每个用户行为的一个会话，`server` 会给每个用户分配一个这个 `Session` 的 `sessionId`，通过 `Cookie` 这个头字段返回给 `client`，之后 `client` 每次请求都会在 `Cookie` 里带上这个 `sessionId`，`server` 拿到 `sessionId` 之后就知道是哪个用户发起的了

### HTTP 请求头必传的字段

是 `Host`, `HTTP 1.1` 允许一台服务器搭建多个 `Web` 站点，也就是说一台服务器可以托管多个域名对应的网站，这样的话必须指定 `Host`，到达服务器后才能找到对应的网址向其请求。

### 代理

说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。

被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程；如同生活中的专卖店，客人到 `adidas` 专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是 adidas 厂家，目标角色就是用户。

简而言之，就是 `adidas` 老板找来专卖店这个代理来卖鞋子给客人这个目标角色。

#### 正向代理

用 `FQ` 软件进行访问 `facebook`，`FQ` 的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/proxy-2.jpg)

上述这样的代理模式称为正向代理，正向代理最大的特点是**客户端非常明确要访问的服务器地址**；**服务器只清楚请求来自哪个代理服务器**，而不清楚来自哪个具体的客户端；**正向代理模式屏蔽或者隐藏了真实客户端信息**。

客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的 `IP` 地址，还有代理程序的端口。

总结来说：正向代理，**“它代理的是客户端”**，是一个位于客户端和原始服务器（Origin Server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器）。

#### 反向代理

明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我国的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了。

此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题。

某宝网站中大部分功能也是直接使用 `Nginx` 进行反向代理实现的，并且通过封装 `Nginx` 和其他的组件之后起了个高大上的名字：`Tengine`。

那么反向代理具体是通过什么样的方式实现的分布式的集群操作呢，我们先看一个示意图（我把服务器和反向代理框在一块，同属于一个环境，后面我有介绍）

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/proxy-3.jpg)

此时请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，`Nginx` 扮演的就是一个反向代理角色。

客户端是无感知代理的存在的，**反向代理对外都是透明的**，**访问者并不知道自己访问的是一个代理**。因为客户端不需要任何配置就可以访问。

反向代理，“**它代理的是服务端**”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。

反向代理的作用：

- 保证内网的安全，通常将反向代理作为公网访问地址，`Web` 服务器是内网。
- 负载均衡，通过反向代理服务器来优化网站的负载。

通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在同一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/proxy-4.jpg)

### HTTPS 简述

`HTTPS` 并非是应用层的一种新协议。只是 `HTTP` 通信接口部分用 `SSL`（Secure Socket Layer）和 `TLS`（Transport Layer Security）协议代替而已。通常，`HTTP` 直接和 `TCP` 通信。当使用 `SSL` 时，则演变成先和 `SSL` 通信，再由 `SSL` 和 `TCP` 通信了。简言之，所谓 `HTTPS`，其实就是身披 `SSL` 协议这层外壳的 `HTTP`。

> http 和 `https` 使用连接方式不同，默认端口也不一样，`http` 是 `80`，`https` 是 `443`。

#### 对称加密（天王盖地虎）

对称加密：即通信的双方都使用**同一个秘钥**进行加解密，比如特务接头的暗号，就属于对称加密

对称加密虽然很简单性能也好，但是**无法解决首次把秘钥发给对方的问题**，很容易被 `hacker` 拦截秘钥。

#### 非对称加密

>私钥 + 公钥 = 密钥对

即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密

因为**通信双方的手里都有一套自己的密钥对**,通信之前双方会先把自己的公钥都先发给对方

然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密

非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。

#### HTTPS 加密方式

结合两种加密方式，**将对称加密的密钥使用非对称加密的公钥进行加密**，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

> 此时又带来一个问题，中间人问题

如果此时在客户端和服务器之间存在一个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。

所以这个时候需要一个安全的第三方颁发证书（CA），证明身份，防止被中间人攻击。

**证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的 HASH 算法、证书到期时间等。**

> 但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。

数字签名就是用 `CA` 自带的 `HASH` 算法对证书的内容进行 `HASH` 得到一个摘要，再用 `CA` 的私钥加密，最终组成数字签名。
当别人把他的证书发过来的时候,我再用同样的 `Hash` 算法,再次生成消息摘要，然后用 `CA` 的公钥对数字签名解密,得到 `CA` 创建的消息摘要,两者一比,就知道中间有没有被人篡改了。

这个时候就能最大程度保证通信的安全了。

#### HTTPS 通讯方式

1. 客户使用 `https` 的 `URL` 访问 `Web` 服务器，要求与 `Web` 服务器建立 `SSL` 连接。

2. `Web` 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

3. 客户端的浏览器与 `Web` 服务器开始协商 `SSL` 连接的安全等级，也就是信息加密的等级。

4. 客户端的浏览器根据双方同意的安全等级，建立**会话密钥**，然后利用网站的公钥将会话密钥加密，并传送给网站。

5. `Web` 服务器利用自己的私钥解密出会话密钥。
`Web` 服务器利用会话密钥加密与客户端之间的通信。

#### HTTPS 的缺点

- HTTPS 协议多次握手，导致页面的加载时间延长近 50%；
- HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗；
- 申请 SSL 证书需要钱，功能越强大的证书费用越高。
- SSL 涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。

#### HTTPS 握手

在 `TLS 1.2` 中，握手协议过程需要耗费两个 `RTT`，过程如下

- [OUT] `Client Hello`，客户端选出自身支持的 TLS 版本号、`cipher suites`、一个随机数、`SessionId` 传送给服务器端 (有可能可服用 Session)
- [IN] `Server Hello`，服务器端选出双方都支持的 TLS 版本，`cipher suite` 、一个随机数、`SeesionId` 给客户端
- [IN] `Certificate`，服务器端给客户端发送证书，用以身份验证及提供公钥
- [IN] `Server Key Exchange`，服务器端给客户端发送秘钥交换算法的一些参数
- [IN] `Server Finished`
- [OUT] `Client Key Exchange`，客户端给服务器端发送秘钥交换算法的一些参数，计算出预备主密钥 (pre master key)，作为随机数传递给服务器端 (这个随机数是安全的)。双方根据三个随机数生成对称加密中的秘钥
- [OUT] `Change Cipher Spec`，告知对方以后的消息将要使用 `TLS` 记录层协议进行加密
- [OUT] `Finished`，发送第一条加密的消息并完整性验证
- [IN] `Change Cipher Spec`，告知以后的消息将要使用 `TLS` 记录层协议进行加密
- [IN] `Finished`，发送第一条加密的消息并完整性验证

`TLS 1.3` 握手时间从以前的 `2RTT` 缩短到 `1RTT`，通过 `Pre shared-key` 减少了单独的 `ServerKeyExchange` 与 `ClientKeyExchange` 消耗的一个 `RTT`

## [HTTPS](#目录)

> [西方机构吊销了俄罗斯的HTTPS证书有什么影响吗？](https://www.zhihu.com/question/523817733/answer/2440936723)

A 和 B 通信，A 收到由证书认证机构 C 颁发的 B 的证书后认定自己确实是在和 B 通信，而不是和 D 冒充的 B 通信，这是证书的作用。打个比方，你作为普通用户在淘宝上经过淘宝官方认证的苹果官方旗舰店买 iPhone，你相信这家店是真的苹果官方旗舰店，这是因为你相信淘宝的认证。要是哪天淘宝和华强北串通，华强北在淘宝上也开一家叫“苹果官方旗舰店”的店而且得到淘宝官方认证，你就有可能在“官方旗舰店”买到假 iPhone

> [破玩意 | 用 HTTPS 传纸条](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247497199&idx=1&sn=d4cdcfe5449f62f1a32feb7336da8d3f&chksm=c2c58f42f5b20654107f77cc84aafd73963a48bac37834aeab43ecc7747b2989459e2373b25e&scene=178&cur_album_id=1703494881072955395#rd)

**公钥加密，私钥解密，这个叫加密**，是为了保证内容安全，因为私钥只有自己知道，是为了保证这个信息不被中间人解开。

**私钥加密，公钥解密，这个叫签名**，是为了防止内容被篡改，因为公钥所有人都知道，所有人都能看到这个信息做验证。

## [QUIC](#目录)

- [QUIC 是如何解决 TCP 性能瓶颈的？](https://mp.weixin.qq.com/s/6SIA_YZSEu1K2yJDhB56Kw)
- [TCP拥塞控制的问题？](https://www.zhihu.com/question/58517416)

## [Websocket](#目录)

首先，`Websocket` 是一个持久化的协议，相对于 `HTTP` 这种非持久的协议来说。

`HTTP` 的生命周期通过 `Request` 来界定，也就是一个 `Request` 一个 `Response`，**而且这个 `response` 也是被动的，不能主动发起**。

### 典型的 Websocket 握手

```js
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

这段类似 `HTTP` 协议的握手请求中，多了几个东西。

```js
Upgrade: websocket
Connection: Upgrade
```

这个就是 `Websocket` 的核心了，告诉 `Apache`、`Nginx` 等服务器：注意啦，窝发起的是 `Websocket` 协议，快点帮我找到对应的助理处理~不是那个老土的 `HTTP`。

```js
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

首先，`Sec-WebSocket-Key` 是一个 `Base64 encode` 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠窝，我要验证尼是不是真的是 `Websocket` 助理。

然后，`Sec_WebSocket-Protocol` 是一个用户定义的字符串，用来区分同 `URL` 下，不同的服务所需要的协议。简单理解：今晚我要服务 `A`，别搞错啦~

最后，`Sec-WebSocket-Version` 是告诉服务器所使用的 `Websocket Draft`（协议版本）

然后服务器会返回下列东西，表示已经接受到请求， 成功建立 `Websocket` 啦！

```js
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

这里开始就是 `HTTP` 最后负责的区域了，告诉客户，我已经成功切换协议啦~

```js
Upgrade: websocket
Connection: Upgrade
```

依然是固定的，告诉客户端即将升级的是 `Websocket` 协议，而不是 `mozillasocket`，`lurnarsocket` 或者 `shitsocket`。

然后，`Sec-WebSocket-Accept` 这个则是经过服务器确认，并且加密过后的 `Sec-WebSocket-Key`。服务器：好啦好啦，知道啦，给你看我的 `ID CARD` 来证明行了吧。。

后面的，`Sec-WebSocket-Protocol` 则是表示最终使用的协议。

至此，`HTTP` 已经完成它所有工作了，接下来就是完全按照 `Websocket` 协议进行了。
具体的协议就不在这阐述了。

### Websocket 的作用

#### ajax 轮询

`ajax` 轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。

#### long poll

`long poll` 其实原理跟 `ajax` 轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回 `Response` 给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。

#### Websocket 和 HTTP 对比

他解决了 `HTTP` 的这几个难题。

首先，被动性，当服务器完成协议升级后（HTTP->Websocket），服务端就可以主动推送信息给客户端啦。

只需要经过一次 `HTTP` 请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）

这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。

其实我们所用的程序是要经过两层代理的，即 `HTTP` 协议在 `Nginx` 等服务器的解析下，然后再传送给相应的 `Handler`（PHP 等）来处理。

简单地说，我们有一个非常快速的接线员（Nginx），他负责把问题转交给相应的客服（Handler）。

本身接线员基本上速度是足够的，但是每次都卡在客服（Handler）了，老有客服处理速度太慢。导致客服不够。

`Websocket` 就解决了这样一个难题，建立后，可以直接跟接线员建立持久连接，有信息的时候客服想办法通知接线员，然后接线员在统一转交给客户。
这样就可以解决客服处理速度过慢的问题了（客服不够多搞几个）。

同时，在传统的方式上，要不断的建立，关闭 `HTTP` 协议，由于 `HTTP` 是非状态性的，每次都要重新传输 `identity info`（鉴别信息），来告诉服务端你是谁。

虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的处理时间，而且还会在网路传输中消耗过多的流量/时间。

但是 `Websocket` 只需要一次 `HTTP` 握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了 `HTTP` 的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析 `HTTP` 协议，还要查看 `identity info` 的信息。

同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了

## [参考资料](#目录)

- [计算机网络的166个核心概念，你知道吗？](https://zhuanlan.zhihu.com/p/492051760)
- [如果让你来设计网络](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247489907&idx=1&sn=a296cb42467cab6f0a7847be32f52dae&chksm=c2c663def5b1eac84b664c8c1cadf1c8ec23ea2e57e48e04add9b833c841256fc9449b62c0ec&scene=178&cur_album_id=1700901576128643073#rd)
- [IPv4地址和子网掩码](https://www.bilibili.com/video/BV1xu411f7UW)
- [半小时看懂<计算机网络>](https://www.bilibili.com/video/BV124411k7uV)
- [你管这破玩意儿叫 TCP？](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247491962&idx=1&sn=aa4414483edaba487c080e91ad0efb93&chksm=c2c59bd7f5b212c12231394c585f3b063b0b2d5b05d6f05fddccdb4e856875e7ee1127bb30a7&cur_album_id=1700901576128643073&scene=189#wechat_redirect)
- [一个数据包的互联网之旅](https://zhuanlan.zhihu.com/p/393701792)
- [51 张图助你彻底掌握 HTTP!](https://zhuanlan.zhihu.com/p/341280965)
- [最终的TCP传输层本质上还是一个需要顺序交付验证的管道，所以http2的管道化尝试意义有多大？](https://www.zhihu.com/question/340651010)
- [为什么那么多公司做前后端分离项目后端响应的 HTTP 状态一律 200？](https://www.zhihu.com/question/513865370/answer/2344277817)
- [WebSocket 是什么原理？为什么可以实现持久连接？](https://www.zhihu.com/question/20215561/answer/40316953)
- [非对称加密](https://www.bilibili.com/video/BV1YL411p7bb)
- [数学不好也能听懂的算法 - RSA加密和解密原理和过程](https://www.bilibili.com/video/BV1XP4y1A7Ui)
- [课堂上传纸条如何防范中间人攻击？](https://www.zhihu.com/question/22558998/answer/21803111)
