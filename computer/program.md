# 祛魅

> 精确本身就是祛魅

## 图灵机

> [谁还不是个科班出身了](computer.md#图灵机)

**数学运算的本质特征**：

1. 在每一步中，只需要关注少数符号。
2. 每一步采取的行动，仅仅取决于当前的运算符号、计算人当前的记忆状态。

**运算行为过程中的人，是完全可以由机器取代的**。

这就是图灵最初给出的，自动运算机器的抽象逻辑归纳，也是用来证明判定问题不存在算法的方法：**如果一个问题无法用图灵机来完成，那么可以说，没有任何算法程序可以解决这个问题。也就是说，凡是能用算法方法解决的问题，也一定能用图灵机解决。**

## 递归

### [递归思想为什么是编程的基本思想，它效率很高吗？](https://www.zhihu.com/question/271081962)

> 递归跟效率没关系，是解决可计算性问题的，**图灵可计算的问题都可以通过一些单步的操作加上递归完成，所以有递归就能表述出所有的程序**，而且比图灵机程序更直观。至于效率那是实现时候的问题。

### [通用的递归转循环方法](https://zhuanlan.zhihu.com/p/136511316)

> 为什么**递归能等效于栈 + 循环**
>
> CPU 就可以看成是一个循环，不断从 PC 指向的位置去执行代码，在函数调用的过程中用 PC 去改变接下来要去执行的位置，用栈来跟踪找到调用完一个函数再回来的路，避免迷路。
>
> 只要我们自己接管整个函数调用的过程，完全可以实现将函数调用全部转换成 `while(true)`。

```js
let pc: number = 0; // pc 寄存器，用来标记程序下一个指令执行的位置
let r0: number = 0; // r0 寄存器，用来储存函数返回的值
let stack: number[] = [];

const code: Command[];

function run(address: number) {
    const command = code[address];
    if (command.isCall) { // 如果是调用函数
        stack.push(pc); // 用栈记录回来的位置
        pc = command.callAddress; // 设置 pc 让 cpu 去执行调用的函数
    }
    if (command.isReturn) { // 当函数返回的时候
        pc = stack.pop(); // 出栈之前在函数调用时记录的返回位置，并设置 pc 让 cpu 执行回到的位置
    }
    // other...
}

while (true) { // cpu 执行指令的循环
    run(pc);
    pc++; // pc 自增自动执行下一条指令
}
```

## 尾递归

> [尾递归为啥能优化？](https://zhuanlan.zhihu.com/p/36587160)
>
> **尾递归本身就可以完全等效于一个无栈的循环**，写成尾递归除了强行炫技以外没有任何实际意义，除了是在一些没有循环的纯函数式语言。

<!-- js 不支持尾递归优化，所以写成尾递归还是会生成递归调用栈 -->
> **尾递归函数依然还是递归函数，如果不优化依然跟普通递归函数一样会爆栈**，该展开多少层依旧是展开多少层。
>
> 函数栈的作用 —— **保持入口环境**
>
> **尾递归为什么可以优化？**
>
> 函数栈的目的是啥？是保持入口环境。那么在什么情况下可以把这个入口环境给优化掉？答案不言而喻，入口环境没意义的情况下为啥要保持入口环境？尾递归，就恰好是这种情况。
>
> **手动优化尾递归**
>
> 假设我们的语言没有原生支持尾递归优化，那么要怎么在语言层面上手动实现一个尾递归优化呢？这**其实就是一个把递归变成循环的过程嘛**。

## 幂等（idempotent）

> 💡 [数学之美](https://zhuanlan.zhihu.com/p/55222212)
>
> **幂等是指被自己重复运算，结果还等于自己**。这个规则放在计算机世界里，稍微弱化成一个函数 `f(x)` 可以被调用任意多次，其副作用保持不变。注意，这里的不变并不意味着没有副作用 —— 比如删除数据库里的一条主键为 k 的记录，无论调用多少次，其副作用都是 k 这条记录不存在。从这个意义上讲，没有副作用的纯函数（pure function）一定是幂等的，幂等函数不一定是纯函数。
>
> **幂等的好处是带来（副作用的）确定性**。HTTP GET / PUT / DELETE 被设计成幂等的，是因为资源的获取，替换和删除无论被调用一次还是多次，资源的状态保持不变。这样，调用者可以多次调用（刷新页面）而不必担心引发错误。
>
> 在一个分布式的世界里，幂等是皇冠上的钻石。我们要尽可能（或者说不得不）将系统设计为幂等，来应对各种各样的不确定性。比如郭靖通过互联网给华筝转账 10 个金叶子，华筝可能没收到，也可能收到了但是给靖哥哥的回复在网络上丢了，两种情况郭靖都需要重传这笔交易，然而重传导致的后果可能是郭靖明明只需要给华筝转 10 个金叶子，却转了 20 个。如果设计成为幂等，我们可以在转账交易中加入一个唯一标识，这样重复的转账就会被丢弃，从而保证一致的副作用。

## 交换律（commutative）

> 💡 [数学之美](https://zhuanlan.zhihu.com/p/55222212)
>
> 交换律是说给定任意 `x`、`y`，对于运算 `*`，如果 `x * y = y * x`，那么我们就认为这个运算是可交换的。拿人话来说就是**我们可以改变处理的事件的顺序而不影响其最终的结果。**
>
> 在计算机的世界里，**交换律意味着我们可以打算指令（或者消息）的顺序，进行乱序执行**。在我们这个热力学第二定律统治的宇宙下，乱序执行一定比顺序执行更有能效。在一个消息系统里，如果消息要按照发送的序列严格处理，就意味着在接收端需要使用队列来存储和排序已经收到的消息，前一个消息没有处理，不能处理下一个消息，那么，这样的系统效率比较低；如果我们能够将其改进成为消息可以按照收到的顺序处理，也就是满足了交换律，那么，效率可以成量级地提高。

## 结合律（associative）

> 💡 [数学之美](https://zhuanlan.zhihu.com/p/55222212)
>
> 结合律是说给定任意的 `x`、`y`、`z`，对于运算 `*`，如果 `(x * y) * z = x * (y * z)`，那么我们就说这个运算是可结合的。拿人话来说就是，**只要参与计算的元素的顺序不变，我可以随意改变运算的顺序，而不会影响最终的结果**。
>
> 在计算机的世界里，**结合律意味着计算的顺序可以发生变化**。比如快排算法，在 partition 之后，先处理小于基准点的数组，还是先处理大于基准点的数组，并没有关系，所以它是满足结合律的。
>
>我们进一步思考，可以发现，**满足结合律意味着处理过程中的局部状态并不受全局状态的影响，或者说独立于全局状态**，于是，**结合律还意味着并发处理** —— 对于一个给定的列表，如果处理列表的算法是满足结合律的，那么就意味着我们可以对列表中的子列表进行并发计算，而并不影响最终的结果。反过来表述，一切可以分治的算法，都满足结合律。

## Y Combinator

- [重新发明 Y 组合子 JavaScript(ES6) 版](http://picasso250.github.io/2015/03/31/reinvent-y.html)
- [Y 不动点组合子用在哪里？](https://www.zhihu.com/question/21099081)
- [函数式编程的 Y Combinator 有哪些实用价值？](https://www.zhihu.com/question/20115649/answer/14029761)

## [回调函数是什么？](https://www.zhihu.com/question/19801131)

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220418-g6h.png)

## CPS

> [干货｜详解 Algebraic Effects 代数效应](https://zhuanlan.zhihu.com/p/380855727)

CPS 是一种编程风格，通过回调函数来返回结果和控制流程。在 CPS 风格中，每一个函数都会显式的接收一个回调函数，通过回调函数来传递当前函数计算结果并控制下一个函数的调用。

```js
// 用 JavaScript 代码演示 ( 1 + 2 ) × 2 = 6

{
  // 默认版本
  const add = (v1, v2) => v1 + v2
  const multi = (v1, v2) => v1 * v2

  const temp = add(1, 2)
  // 同步
  const result = multi(temp, 2)
  console.log('同步', result) // 6

  // 假设有个产品经理忽然提了一个需求 "add 这个过程需要 1s 后才返回结果"
  setTimeout(() => {
    const result = multi(temp, 2)
    console.log('异步', result)
  }, 1000)
}

{
  // CPS 版本
  const add = (v1, v2, next) => next(v1 + v2)
  const multi = (v1, v2, next) => next(v1 * v2)

  add(1, 2, (r1) => {
    multi(r1, 2, (r2) => {
      console.log('同步', r2) // 6
    })
  })

  // 假设有个产品经理忽然提了一个需求 "add 这个过程需要 1s 后才返回结果"
  const addAsync = (v1, v2, next) => setTimeout(next, 1000, v1 + v2)
  addAsync(1, 2, (r1) => {
    multi(r1, 2, (r2) => {
      console.log('异步', r2) // 6
    })
  })
}
```

每一个函数的都接受一个回调函数 next，且计算结果都通过 next 延续给下一个函数，通过 CPS 可以**提升对程序流程控制：当前函数拥有对后续流程的控制**。

> 直呼好家伙，CPS 原来就是被我们嗤之以鼻回调地狱。

## CallBag

> [Staltz - Callback Heaven](https://zhuanlan.zhihu.com/p/38039481)

## Hash

![20230306165648](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230306165648.png)

## Stream

> [用 JS 代码解释 Java Stream](https://zhuanlan.zhihu.com/p/61456650)

## [时间复杂度 O(logN) 意味着什么？](https://juejin.cn/post/6844903481191432206)

![20230306034906](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230306034906.png)

## [P 问题、NP 问题、NP 完全问题和 NP 难问题](https://zhuanlan.zhihu.com/p/73953567)

复杂度被分为两种级别：一种是 `O(1)`，`O(logN)`，`O(N^2)` 等，我们把它叫做多项式级的复杂度，**因为它的规模 N 出现在底数的位置**；另一种是 `O(2^N)` 和 `O(N!)` 型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。

**P 问题**：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于 P 问题。

**NP 问题**： NP 问题不是非 P 类问题。NP 问题是指可以在多项式的时间里验证一个解的问题。NP 问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。

**NPC 问题**：同时满足下面两个条件的问题就是 NPC 问题。首先，它得是一个 NP 问题；然后，所有的 NP 问题都可以约化到它。NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。

**NP-Hard 问题**：它满足 NPC 问题定义的第二条但不一定要满足第一条。NP-Hard 问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是 NP 问题。即使 NPC 问题发现了多项式级的算法，NP-Hard 问题有可能仍然无法得到多项式级的算法 约化：(Reducibility，有的资料上叫“归约”)。简单地说，一个问题 A 可以约化为问题 B 的含义即是，可以用问题 B 的解法解决问题 A，或者说，问题 A 可以“变成”问题 B。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。

## [有限状态机](https://www.bilibili.com/video/BV11e4y1W7CF?p=20)

![SCR-20230217-j02](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/SCR-20230217-j02.png)

## [面向对象](https://www.bilibili.com/video/BV11e4y1W7CF?p=10)

![20230306224432](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230306224432.png)

![20230306224306](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230306224306.png)

## DSL

> [前端 DSL 实践指南（上）—— 内部 DSL](https://zhuanlan.zhihu.com/p/107947462)
