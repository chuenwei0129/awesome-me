# 计算机知识图谱（一）<!-- omit in toc -->

***👀 TIPS: 二级标题可返回目录***

---

> ## 目录

- [图灵机](#图灵机)
  - [参考资料](#参考资料)
  - [读书笔记](#读书笔记)
  - [总结](#总结)
  - [拓展：罗素悖论](#拓展罗素悖论)
  - [拓展：停机问题](#拓展停机问题)
- [布尔逻辑与逻辑门](#布尔逻辑与逻辑门)
- [计算机编程语言](#计算机编程语言)
- [计算机系统 64 位 32 位指的是什么？](#计算机系统-64-位-32-位指的是什么)
- [复杂指令集 CISC 和精简指令集 RISC](#复杂指令集-cisc-和精简指令集-risc)
- [多核 CPU 和多个 CPU 有何区别？](#多核-cpu-和多个-cpu-有何区别)

## [图灵机](#目录)

### 参考资料

- [图灵机的解释](https://mp.weixin.qq.com/s/oKrsznBAumrNvz4_xtktXw)
- [什么是图灵完备？](https://www.zhihu.com/question/20115374/answer/288346717)
- [为什么所有编程语言都是数据+指令?](https://www.bilibili.com/video/BV1Za411t7c6)

### 读书笔记

> **数学运算的本质特征**：

1. 在每一步中，只需要关注少数符号。
2. 每一步采取的行动，仅仅取决于当前的运算符号、计算人当前的记忆状态。

**运算行为过程中的人，是完全可以由机器取代的**。这就是图灵最初给出的，自动运算机器的抽象逻辑归纳，也是用来证明判定问题不存在算法的方法：**如果一个问题无法用图灵机来完成，那么可以说，没有任何算法程序可以解决这个问题。也就是说，凡是能用算法方法解决的问题，也一定能用图灵机解决。**

> **图灵完备**

在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。———— 维基百科

> **Brainfuck is fully Turing-complete.**

`Brainfuck` 的工作机制与图灵机高度一致。

首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。

语言里的 8 个有效字符分别是：

- `>` 指针向右移动一格
- `<` 指针向左移动一格
- `+` 使指针当前格数值加一
- `-` 使指针当前格数值减一
- `.` 把当前格数值按 ASCII 表输出到终端
- `,` 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格
- `[` 当指针当前值为 0 时，程序跳转至与之对应的 `]` 之后；否则程序正常执行
- `]` 程序跳转回与之对应的 `[` 处

有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 'A' 对应的值为 65，可以使用 `5 * 13` 算出 65 并输出得到字符 'A'。

```bf
+++++

[
>+++++++++++++
<-
]

>.
```

**👟 解释：** 把指针初始处的格子命名为 `cell 0`，`cell 0` 右边的那个格子命名为 `cell 1`。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 `cell 0` 的值最终被递减为 0 的时候，循环结束。此时 `cell 1` 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 `cell 1`，输出此格子，则在终端会看到 'A'。

**🐟 拓展：** *brainfuck 还有一个用处，一门新语言功能语法很复杂，要用数学证明的方式确定性说明它图灵完备会很麻烦，但只要用这门新语言实现一个 brainfuck 的解释器，那么就必然证明了是图灵完备的*

### 总结

图灵机解决了几个问题：

1. **可计算性问题**。一个数是否是可计算的，称为可计算数。可计算数只是实数的一部分，大多数实数都是不可计算的。（通用计算机）
2. **可判定性问题**。是否存在通用的过程，判断某个公式是可以证明的。（停机问题）
3. **人类计算者与计算机等价**。通过图灵测试判定计算机的智能。（人工智能）

### 拓展：罗素悖论

理发师悖论由哲学家罗素在 1903 年提出，也称为罗素悖论。有一个理发师打广告，说：“我只给本城所有不给自己刮脸的人刮脸。”

问题是：理发师能不能给他自己刮脸呢？如果他不给自己刮脸，他就属于“不给自己刮脸的人”；如果他给自己刮脸，他就属于“给自己刮脸的人”，他就不该给自己刮脸。

在理发师悖论的基础上，罗素构建了一个“集合” S： S 由一切不是自身元素的集合组成。然后，罗素问：S 是否属于 S 呢？根据排中律，一个元素或者属于某个集合，或者不属于某个集合。因此，对于一个给定的集合，某个元素或者属于该集合，或者不属于该集合。

但对罗素提出的这个“集合” S 是否属于 S，却没有那么容易判断：如果 S 属于 S，根据 S 的定义，S 就不属于 S；反之，如果 S 不属于 S，同样根据定义，S 就属于 S。

### 拓展：停机问题

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220412-h59.png)

## [布尔逻辑与逻辑门](#目录)

> [你管这破玩意叫 CPU ？](https://zhuanlan.zhihu.com/p/367927405)

## [计算机编程语言](#目录)

> [你管这破玩意叫编程语言？](https://zhuanlan.zhihu.com/p/359941312)

## [计算机系统 64 位 32 位指的是什么？](#目录)

<https://www.youtube.com/watch?v=Wu2A4fpFzgs>

## [复杂指令集 CISC 和精简指令集 RISC](#目录)

我们可以继续举个例子，比如说我们要命令一个人吃饭，那么我们应该怎么命令呢？我们可以直接对他下达“吃饭”的命令，也可以命令他“先拿勺子，然后舀起一勺饭，然后张嘴，然后送到嘴里，最后咽下去”。

从这里可以看到，对于命令别人做事这样一件事情，不同的人有不同的理解，有人认为，如果我首先给接受命令的人以足够的训练，让他掌握各种复杂技能（即在硬件中实现对应的复杂功能），那么以后就可以用非常简单的命令让他去做很复杂的事情——比如只要说一句“吃饭”，他就会吃饭。

但是也有人认为这样会让事情变的太复杂，毕竟接受命令的人要做的事情很复杂，如果你这时候想让他吃菜怎么办？难道继续训练他吃菜的方法？我们为什么不可以把事情分为许多非常基本的步骤，这样只需要接受命令的人懂得很少的基本技能，就可以完成同样的工作，无非是下达命令的人稍微累一点——比如现在我要他吃菜，只需要把刚刚吃饭命令里的“舀起一勺饭”改成“舀起一勺菜”，问题就解决了，多么简单。这就是“复杂指令集”和“精简指令集”的逻辑区别。

> [分不清ARM和X86架构，别跟我说你懂CPU！](https://zhuanlan.zhihu.com/p/21266987)

## 多核 CPU 和多个 CPU 有何区别？

<https://zhuanlan.zhihu.com/p/85819786>

[CPU 核数与线程数有什么关系？](https://zhuanlan.zhihu.com/p/391588682)
