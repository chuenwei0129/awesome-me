# 计算机知识图谱

***👀 TIPS: 二级标题可返回目录***

---

> ## 目录

- [计算机知识图谱](#计算机知识图谱)
  - [图灵机](#图灵机)
    - [📚 学习](#-学习)
    - [📒 笔记](#-笔记)
    - [💭 总结](#-总结)
    - [🌐 拓展：罗素悖论](#-拓展罗素悖论)
    - [🌐 拓展：停机问题](#-拓展停机问题)
  - [计算机是如何启动的？](#计算机是如何启动的)
  - [你管这破玩意叫 CPU ？](#你管这破玩意叫-cpu-)
  - [计算机系统 64 位 32 位指的是什么 ?](#计算机系统-64-位-32-位指的是什么-)
  - [复杂指令集 CISC 和精简指令集 RISC](#复杂指令集-cisc-和精简指令集-risc)
  - [基于 IEEE 754 标准的双精度 64 位的浮点数](#基于-ieee-754-标准的双精度-64-位的浮点数)
  - [位运算](#位运算)
    - [进制转换](#进制转换)
    - [原码、反码、补码](#原码反码补码)
  - [进程、线程、协程](#进程线程协程)

## [图灵机](#目录)

### 📚 学习

- [图灵机的解释](https://mp.weixin.qq.com/s/oKrsznBAumrNvz4_xtktXw)
- [什么是图灵完备？](https://www.zhihu.com/question/20115374/answer/288346717)
- [为什么所有编程语言都是数据+指令?](https://www.bilibili.com/video/BV1Za411t7c6)

### 📒 笔记

> **数学运算的本质特征**：

1. 在每一步中，只需要关注少数符号
2. 每一步采取的行动，仅仅取决于当前的运算符号、计算人当前的记忆状态

**运算行为过程中的人，是完全可以由机器取代的**。这就是图灵最初给出的，自动运算机器的抽象逻辑归纳，也是用来证明判定问题不存在算法的方法：**如果一个问题无法用图灵机来完成，那么可以说，没有任何算法程序可以解决这个问题。也就是说，凡是能用算法方法解决的问题，也一定能用图灵机解决。**

> **图灵完备**

在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。

> **Brainfuck is fully Turing-complete.**

BF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。

语言里的 8 个有效字符分别是：

- `>` 指针向右移动一格
- `<` 指针向左移动一格
- `+` 使指针当前格数值加一
- `-` 使指针当前格数值减一
- `.` 把当前格数值按 ASCII 表输出到终端
- `,` 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格
- `[` 当指针当前值为 0 时，程序跳转至与之对应的 `]` 之后；否则程序正常执行
- `]` 程序跳转回与之对应的 `[` 处

有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 'A' 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 'A'。

```sh
+++++

[
>+++++++++++++
<-
]

>.
```

把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 'A'。

**brainfuck 还有一个用处，一门新语言功能语法很复杂，要用数学证明的方式确定性说明它图灵完备会很麻烦，但只要用这门新语言实现一个brainfuck 的解释器，那么就必然证明了是图灵完备的**

### 💭 总结

图灵机解决了几个问题：

1. **可计算性问题**。一个数是否是可计算的，称为可计算数。可计算数只是实数的一部分，大多数实数都是不可计算的。（通用计算机）
2. **可判定性问题**。是否存在通用的过程，判断某个公式是可以证明的。（停机问题）
3. **人类计算者与计算机等价**。通过图灵测试判定计算机的智能。（人工智能）

### 🌐 拓展：罗素悖论

理发师悖论由哲学家罗素在 1903 年提出，也称为罗素悖论。有一个理发师打广告，说：“我只给本城所有不给自己刮脸的人刮脸。”问题是：理发师能不能给他自己刮脸呢？如果他不给自己刮脸，他就属于“不给自己刮脸的人”；如果他给自己刮脸，他就属于“给自己刮脸的人”，他就不该给自己刮脸。

在理发师悖论的基础上，罗素构建了一个“集合” S： S 由一切不是自身元素的集合组成。然后，罗素问：S 是否属于 S 呢？根据排中律，一个元素或者属于某个集合，或者不属于某个集合。因此，对于一个给定的集合，某个元素或者属于该集合，或者不属于该集合。但对罗素提出的这个“集合” S 是否属于 S，却没有那么容易判断：如果 S 属于 S，根据 S 的定义，S 就不属于 S；反之，如果 S 不属于 S，同样根据定义，S 就属于 S。

### 🌐 拓展：停机问题

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220412-h59.png)

## [计算机是如何启动的？](#目录)

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220412-g4a.png)

> **知乎：**[计算机是如何启动的？](https://www.zhihu.com/question/40831686)

## [你管这破玩意叫 CPU ？](#目录)

> **知乎：**[你管这破玩意叫 CPU ？](https://zhuanlan.zhihu.com/p/367927405)

## [计算机系统 64 位 32 位指的是什么 ?](#目录)

> **▶️ YouTube：**[计算机系统 64 位 32 位指的是什么 ?](https://www.youtube.com/watch?v=Wu2A4fpFzgs)

## [复杂指令集 CISC 和精简指令集 RISC](#目录)

我们可以继续举个例子，比如说我们要命令一个人吃饭，那么我们应该怎么命令呢？我们可以直接对他下达“吃饭”的命令，也可以命令他“先拿勺子，然后舀起一勺饭，然后张嘴，然后送到嘴里，最后咽下去”。

从这里可以看到，对于命令别人做事这样一件事情，不同的人有不同的理解，有人认为，如果我首先给接受命令的人以足够的训练，让他掌握各种复杂技能（即在硬件中实现对应的复杂功能），那么以后就可以用非常简单的命令让他去做很复杂的事情——比如只要说一句“吃饭”，他就会吃饭。

但是也有人认为这样会让事情变的太复杂，毕竟接受命令的人要做的事情很复杂，如果你这时候想让他吃菜怎么办？难道继续训练他吃菜的方法？我们为什么不可以把事情分为许多非常基本的步骤，这样只需要接受命令的人懂得很少的基本技能，就可以完成同样的工作，无非是下达命令的人稍微累一点——比如现在我要他吃菜，只需要把刚刚吃饭命令里的“舀起一勺饭”改成“舀起一勺菜”，问题就解决了，多么简单。这就是“复杂指令集”和“精简指令集”的逻辑区别。

> **知乎：**[分不清ARM和X86架构，别跟我说你懂CPU！](https://zhuanlan.zhihu.com/p/21266987)

## [基于 IEEE 754 标准的双精度 64 位的浮点数](#目录)

> **微信：**[从科学记数法到浮点数标准 IEEE 754](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)

## [位运算](#目录)

### 进制转换

![二进制与十进制转换方法](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/terminal/SCR-20220408-acz.png)

### 原码、反码、补码

> 参考

- [JavaScript 中的位运算和权限设计](https://juejin.cn/post/6844903988945485837)
- [一文搞明白位运算、补码、反码、原码](https://juejin.cn/post/6844903912425259022)

## [进程、线程、协程](#目录)

不请自来。
看见上面几位的回答我真的是醉了。说几句我的理解。
首先来一句概括的总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述。是运行中的程序指令的一种描述，这需要与程序中的代码区别开来。

另外注意这里我说的进程线程概念，和编程语言中的API接口对应的进程/线程是有差异的。

下面细说背景：
CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备则难以望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。而且因为速度差异，CPU实际的执行时间和等待执行的时间是数量级的差异。比如工作1秒钟，休息一个月。所以多个任务，轮流着来，让CPU不那么无聊，给流逝的时间增加再多一点点的意义。这些任务，在外在表现上就仿佛是同时在执行。

一个必须知道的事实：执行一段程序代码，实现一个功能的过程之前 ，当得到CPU的时候，相关的资源必须也已经就位，就是万事俱备只欠CPU这个东风。所有这些任务都处于就绪队列，然后由操作系统的调度算法，选出某个任务，让CPU来执行。然后就是PC指针指向该任务的代码开始，由CPU开始取指令，然后执行。

这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了的进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。

串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载进程A的上下文，然后开始执行A，保存进程A的上下文，调入下一个要执行的进程B的进程上下文，然后开始执行B,保存进程B的上下文。。。。

========= 重要的东西出现了========
进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。

进程就是上下文切换之间的程序执行的部分。是运行中的程序的描述，也是对应于该段CPU执行时间的描述。
在软件编码方面，我们说的进程，其实是稍不同的，编程语言中创建的进程是一个无限loop，对应的是tcb块。这个是操作系统进行调度的单位。所以和上面的cpu执行时间段还是不同的。
进程，与之相关的东东有寻址空间，寄存器组，堆栈空间等。即不同的进程，这些东东都不同，从而能相互区别。
线程是什么呢？
进程的颗粒度太大，每次的执行都要进行进程上下文的切换。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：

程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。

这里a，b，c的执行是共享了A进程的上下文，CPU在执行的时候仅仅切换线程的上下文，而没有进行进程上下文切换的。进程的上下文切换的时间开销是远远大于线程上下文时间的开销。这样就让CPU的有效使用率得到提高。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。线程主要共享的是进程的地址空间。

到此全文结束，再一个总结：

进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。

注意这里描述的进程线程概念和实际代码中所说的进程线程是有区别的。编程语言中的定义方式仅仅是语言的实现方式，是对进程线程概念的物化。

我们先来做一个思维实验. 想象一下我们有一台最简单的计算机.

我们先完全不考虑什么操作系统什么虚拟内存, 就当这些东西完全不存在.

这台 "计算机" 的全部功能就是每秒钟神奇地从 "磁盘" 找到一条指令, 送入 "CPU" , 让 "CPU" 按顺序执行.

假设磁盘上有个程序A, 里面包含17条指令, 那么我们的计算机就需要17秒去完成这个程序. 而这17秒之内, 我们的计算机无法做别的事情. 这看起来很蠢不是么? 想象一下一台电脑无法边打字边听音乐.

所以我们要对计算机做出改进, 让他能够交替的执行程序A程序B程序C程序D.

再一次假设全知全能的我们完成了对计算机的改造, 现在我们的计算机可以做到同时执行多个程序.

还是那个拥有17条指令的程序A和一个拥有42条指令的程序B. 我们可以先执行一秒钟程序A, 再执行一秒钟程序B, 再执行一秒钟程序A. 看上去在同时执行两条程序似的.

那程序A对应的进程到底是什么? 是那17条指令? 是那17秒钟? 好像都不是.

进程A就是处理这17条指令的过程; 而进程B就是处理这42条指令的过程.

什么? 进程就是过程? process is process? 这说了和没说有什么区别?

没错, 很遗憾的说, 对于一个还未入门的人来说, 这就是最低程度的抽象了.

你看, 哪怕是最最简单的计算机, 我们依旧无法说清「进程到底是什么」.

因为进程这个概念本身就是抽象的.

关于「进程是什么」的回答在网络上到处都是, 而你却特地跑来知乎问, 说明你对那些文章都不满意, 你希望得到一个很漂亮的回答, 一个让人一眼看过去就茅塞顿开的回答. 实际上这是很难的. 就好比人们总是希望一句话就说清楚生活的意义是什么. 实际上也是很难的.

费曼在<The Feynman Lectures on Physics>里说过微观世界无论是对新手还是物理学家都是抽象的. 而我们的教科书却还是试图用行星绕着太阳这样的模型去描述电子绕着质子.

Things on a very small scale behave like nothing that you have any direct experience about. They do not behave like waves, they do not behave like particles, they do not behave like clouds, or billiard balls, or weights on springs, or like anything that you have ever seen. (...)
Because atomic behavior is so unlike ordinary experience, it is very difficult to get used to, and it appears peculiar and mysterious to everyone--both to the novice and the experienced physicist.
所以我到底想要表达什么呢?

大概就是:
