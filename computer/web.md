# 计算机基础知识图谱（一）<!-- omit in toc -->

***👀 TIPS: 二级标题可返回目录***

---

> ## 目录

## [浏览器多进程架构](#目录)

### 目前多进程架构（已过时）

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

|    进程    |                                                                                                                功能                                                                                                                |
| :--------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| 浏览器进程 |                                                                                    主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。                                                                                    |
|  渲染进程  |   核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。   |
|  GPU 进程  | 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 |
|  网络进程  |                                                           主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。                                                           |
|  插件进程  |                                                           主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。                                                           |

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/SCR-20220424-ltq.png)

### 未来面向服务的架构

Chrome 正在经历架构变革，它转变为将浏览器程序的每一模块作为一个服务来运行，从而可以轻松实现进程的拆解或聚合。
通常观点是当 Chrome 运行在强力硬件上时，它会将每个服务分解到不同进程中，从而提升稳定性，但是如果 Chrome 运行在资源有限的设备上时，它会将服务聚合到一个进程中从而节省了内存占用。

**强力硬件进程模型图：**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/SCR-20220424-lqa.png)

**资源受限的设备上：**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/SCR-20220424-lr6.png)

### 浏览器的进程模式

为了节省内存，Chrome 提供了四种进程模式（Process Models），不同的进程模式会对 tab 进程做不同的处理。

- **Process-per-site-instance** (default) - 同一个 **site-instance** 使用一个进程
- **Process-per-site -** 同一个 **site** 使用一个进程
- **Process-per-tab -** 每个 tab 使用一个进程
- **Single process -** 所有 tab 共用一个进程

> 🍐 这里需要给出 site 和 site-instance 的定义

- **site** 指的是相同的 `registered domain name` 和 `scheme`。比如 `a.baidu.com` 和 `b.baidu.com` 就可以理解为同一个 **site**（注意这里要和  `Same-origin policy` 区分开来，同源策略还涉及到子域名和端口）。
- **site-instance** 满足下面两中情况并且打开的新页面和旧页面属于上面定义的同一个 **site**，就属于同一个 **site-instance**

  - 用户通过 `<a target="_blank">` 这种方式点击打开的新页面
  - JS 代码打开的新页面（比如 `window.open`)

`Process-per-site-instance` 是 Chrome 默认使用的模式，也就是几乎所有的用户都在用的模式。当你打开一个 tab 访问 `a.baidu.com` ，然后再打开一个 tab 访问 `b.baidu.com`，这两个 tab 会使用**两个进程**。而如果你在 `a.baidu.com` 中，通过 JS 代码打开了 `b.baidu.com` 页面，这两个 tab 会使用**同一个进程**。

### 每个 iframe 的渲染进程 —— 站点隔离

关闭所有插件，写一个 html 文件并打开，内容如下所示：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>iframe</title>
  </head>
  <body>
    <iframe src="https://linjingyi.cn" width="300" height="400"></iframe>
    <iframe src="https://baidu.com" width="300" height="400"></iframe>
  </body>
</html>
```

在代码中使用了两个 iframe 框架，打开后的任务管理器如下所示：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/v2-6c61510658ee0b2de8ff07ce7b8e50a6_1440w.jpg)

在 Chrome 任务管理器中，虽然只打开了一个标签页，但是两个 iframe 页面都单独占了一个进程。

### 查看 Windows 系统任务管理器

虽然 Chrome 有任务管理器，但是 Windows 系统也自带了任务管理器。

**Chrome 任务管理器：**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/v2-b380a595721a3cf5840428686cc0dbee_1440w.jpg)

**Windows 任务管理器：**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/v2-e023b26e513fe5ccdc4912d583fd0dd2_1440w.jpg)

对比很明显，为什么在 Chrome 任务管理器中只有 `5` 个进程，而 Windows 任务管理器中却有 `7` 个进程。这是因为 Chrome 有一些辅助进程并不会在任务管理器中显示，比如**预渲染进程**是一个额外的渲染辅助进程，当有渲染需求时直接改进程，省去创建进程的时间。

## [导航流程](#目录)

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/SCR-20220424-mwn.png)

### 1. 处理输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。

当用户输入关键字并键入回车之后，当前页面没有监听 `beforeunload` 事件或者同意了继续后续流程，便进入了加载状态。但此时页面显示的依然是之前打开的页面内容，并没立即替换页面。因为需要等待提交文档阶段，页面内容才会被替换。

### 2. 开始导航

**如果有 `Service Worker`**

`Service Worker` 是在渲染进程中运行的 JavaScript 代码。但是当导航请求进入时，浏览器进程如何知道该站点有 `Service Worker`？

当注册一个 `Service Worker` 时，保持 `Service Worker` 的作用域作为一个引用。当一个导航发生时，网络进程用已注册的 `Service Worker` 作用域来检查域名，如果已经为该 URL 注册了一个 `Service Worker`，浏览器进程会找一个渲染进程来执行 `Service Worker` 的代码。`Service Worker` 可能从缓存中加载数据，无需从网络请求数据，或者可以从网络请求新资源。

如果 `Service Worker` 最终决定从网络请求数据，则浏览器进程和渲染器进程之间的往返可能会导致延迟。**导航预加载**是一种通过与 `Service Worker` 启动并行加载资源来加速此过程的机制。它用一个头部来标记这些请求，允许服务器决定为这些请求发送不同的内容；例如，只更新数据而不是完整文档。

**未设置 `Service Worker`**

1、请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。

2、 连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

3、 服务器接收到请求信息后，会根据请求信息生成响应数据，并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容。

> **重定向**

如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。**网络进程会从响应头的 Location 字段里面读取重定向的地址。**

  ![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/SCR-20220424-nln.png)

> **读取响应结果**

**Content-Type** 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 `Content-Type` 的值来决定如何显示响应体的内容。

如果 `Content-Type` 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。

> **安全检查**

恶意名单检查：如果域和响应数据在恶意站点名单中，则网络进程发出和显示警告页面。
跨域读取检查：`CrossOriginReadBlock` 检查，敏感的跨站点数据不进入渲染器进程

### 3. 准备渲染进程

如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 `process-per-site-instance`。

**打开一个新页面采用的渲染进程策略就是：**

- 通常情况下，打开新的页面都会使用单独的渲染进程；
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

> **由于网络请求可能需要几百毫秒才能得到响应，为加速此过程，在开始导航网络进程发送`URL` 请求时，已经主动进行查找、启动渲染进程，数据接收完成后，渲染进程已备用。**

### 4. 提交导航

现在数据和渲染器进程已准备就绪，`IPC` 将从浏览器进程发送到渲染进程以提交导航。渲染进程确认提交完成，导航完成。文档加载开始。

1. `UI` 更新：地址栏更新、安全指示器、站点设置 `UI` 会反映新页面站点信息。
2. 选项卡的会话历史记录更新(前进/后退)，为便于关闭浏览器后恢复，历史记录到磁盘。

    ![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/20210107213807807.png)

### 5. 初始化 load complete

提交导航后，渲染器进程将继续加载资源并呈现页面，**一旦渲染器进程“完成”（onload 事件在所有帧上触发执行完成后）渲染**，它就会将 `IPC` 发送回浏览器进程。`UI` 线程停止选项卡的加载转圈。

### 6. 导航到其他站点

导航完成后，再次将不同的 `URL` 放到地址栏导航，浏览器会检查当前渲染网站的`beforeunload` 事件。如有设置导航或关闭选项卡时发出警报“离开这个网站吗？” 包含 `JavaScript` 代码的选项卡内的所有内容都由渲染进程处理。

## [HTTP 缓存](#目录)

### 强缓存和协商缓存

与强缓存相关的 `header` 字段有两个：

**expires：** 这是 http1.0 时的规范；它的值为一个绝对时间的 GMT 格式的时间字符串，如 `Mon, 10 Jun 2015 21:31:12 GMT`，如果发送请求的时间在  expires 之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源

另一个请求头为 `Cache-Control`。**这个缓存指令是单向的**，也就是说请求中设置的指令，不一定包含在响应中，请求中如果没有传 `Cache-Control`，`server` 也可以返回 `Cache-Control`。

**客户端发起请求后，服务器返回 `Cache-Control： max-age=30`，代表资源在客户端可以缓存 30 秒，30 秒内客户端的请求可以直接从缓存获取，超过 30 秒后需要向服务器发起网络请求。**

`max-age` 是 `HTTP` 缓存控制最常用的属性，表示资源存储的最长时间，需要注意的是，时间的计算起点是响应报文的创建时刻（即 `Date` 字段，也就是离开服务器的时刻），超过后客户端需要重新发起请求

除此之外，还有其它属性值如下:

- `no-cache`: **缓存但重新验证**服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回 304），则缓存才使用本地缓存副本。

- `no-store`: 这才是真正的不允许缓存，比如秒杀页面这样变化非常频繁的页面就不适合缓存

- `must-revalidate`：一旦资源过期（比如已经超过 max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/http-11.jpg)

`Cache-Control` 只能刷新数据，但不能很好地利用缓存，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版，存在一定的性能问题，所以 `HTTP` 又引入了条件缓存（协商缓存）。

条件请求以 `If` 开头，有「If-Match」，「If-Modified-Since」，「If-None-Match」,「If-Range」,「If-Unmodified-Since」五个头字段，我们最常用的是「if-Modified-Since」和「If-None-Match」这两个头字段，所以重点介绍一下。

- `if-Modified-Since`：指的是文件最后修改时间，服务器只在所请求的资源**在给定的日期时间之后对内容进行过修改的情况下**才会将资源返回，如果请求的资源从那时起未经修改，那么**返回一个不带有消息主体的 `304` 响应**，需要第一次请求提供「Last-modified」，只能精确到一秒，第二次请求就可以在 「if-Modified-Since」首部带上此值了

- `If-None-Match`：条件请求首部，对于 `GET` 和 `HEAD` 请求方法来说，当且仅当服务器上没有任何资源的 `ETag` 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 `200`，

![](../Images/http-12.jpg)

> ETag 是实体标签（Entity Tag）的缩写，**是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变**，主要解决修改时间无法准确区分文件变化的问题，比如文件在一秒内修改了多次，由于修改时间是秒级的，用 `if-Modified-Since` 就会误认为资源没有变化，而每次文件修改了都会修改 `ETag`，也就是说 `ETag` 可以精确识别资源的变动, 所以如果对资源变化很敏感觉的话，应该用 `If-None-Match`
>
> 注：ETag 有强，弱之分，强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有「W/」标记，只要求资源在语义上没啥变化，比如加了几个空格等等。

需要注意的是不管是 `if-Modified-Since` 还是 `If-None-Match`，**这两者只会在资源过期（即存活时间超 max-age）后才会触发**，

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/SCR-20220424-nlf.png)

### 用户操作对缓存的影响

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/browser/bVbwrEd.webp)

## [渲染流程](#目录)

## [事件循环](#目录)

## [V8 引擎](#目录)

## [浏览器多进程架构](#目录)
## [浏览器多进程架构](#目录)
## [浏览器多进程架构](#目录)
## [浏览器多进程架构](#目录)
## [浏览器多进程架构](#目录)

## [科普](#目录)

### 为什么 Chrome 的 navigator 属性值里会看到AppleWebkit ？

`UA` 是浏览器的身份证，通常，在发送 HTTP 请求时，UA 会附带在 HTTP 的请求头中 user-agent 字段中，这样服务器就会知道浏览器的基础信息，然后服务器会根据不同的 UA 返回不同的页面内容，比如手机上返回手机的样式，PC 就返回 PC 的样式。

在浏览器的控制台中输入：`navigator.userAgent` 查看当前浏览器的 UA 信息。

- FireFox 中的打印的信息是：

  ```js
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:68.0) Gecko/20100101 Firefox/68.0"
  ```

- Chrome 中打印的信息是：

  ```sh
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36'
  ```

服务器会根据不同的 UA 来针性的设计不同页面，所以当出了一款新浏览器时，他如果使用自己独一无二的 UA，那么之前的很多服务器还需要针对他来做页面适配，这显然是不可能的。

比如 Chrome 发布时他会在他的 UA 中使用 “Mozilla” ，“AppleWebKit”，等关键字段，用来表示他同时支持 Mozilla 和 AppleWebKit，然后再在最后加上他自己的标示，如 Chrome/xxx。

### 现在的浏览器可以同时打开多个页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？

端口一样的，网络进程知道每个 tcp 链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程

### tcp 传送数据时 浏览器端就做渲染处理了么？如果前面数据包丢了 后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？

接收到 http 响应头中的 content-type 类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做 DOM 解析了！基于 http 不用担心数据包丢失的问题，因为丢包和重传都是在 tcp 层解决的。http 能保证数据按照顺序接收的！

### 同一个域名同时最多只能建立 6 个 TCP 连接 是不是意思是同一域名同时只能发送6个 AJAX 请求吗？

”同一个域名同时最多只能建立 6 个 TCP 连接“ 指的不光是指Ajax，还包括页面中的资源加载，只要是一个域名下的资源，浏览器同一时刻最多只支持6个并行请求。不过这是 HTTP/1.1 的规则，HTTP/2 已经不用这套规则了。




## [参考资料](#目录)

- [[译] 现代浏览器内部揭秘（第一部分）](https://juejin.cn/post/6844903679389073415)
- [[译] 现代浏览器内部揭秘（第二部分）](https://juejin.cn/post/6844903692890537992)

<!-- 1. 浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容 + 默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL。
1. 用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得。
1. 浏览器进程会通过进程间通信（IPC）将 URL 请求发送给网络进程。
1. 网络进程获取到 URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接 200 返回；否则，进入网络请求过程。
1. 网络进程请求 DNS 返回域名对应的 IP 和端口号，如果之前 DNS 数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的 IP 和端口号，如果没有端口号，http 默认 80，https 默认 443。如果是 https 请求，还需要建立 TLS 连接。
1. Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于 6 个，会直接建立 TCP 连接。
1. TCP 三次握手建立连接，http 请求加上 TCP 头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输。
1. 网络层在数据包上加上 IP 头部——包括源 IP 地址和目的 IP 地址，继续向下传输到底层。
1. 底层通过物理网络传输给目的服务器主机。
1. 目的服务器主机网络层接收到数据包，解析出 IP 头部，识别出数据部分，将解开的数据包向上传输到传输层。
1. 目的服务器主机传输层获取到数据包，解析出 TCP 头部，识别端口，将解开的数据包向上传输到应用层。
1. 应用层 HTTP 解析请求头和请求体，如果需要重定向，HTTP 直接返回 HTTP 响应数据的状态 301 或者 302，同时在请求头的 Location 字段中附上重定向地址，浏览器会根据 code 和 Location 进行重定向操作，重新进行第 4 步；如果不是重定向，首先服务器会根据请求头中的 If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回 304 状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200 的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：`Cache-Control:Max-age=缓存存活的相对时间`。
1. 响应数据又顺着应用层(server) ——> 传输层(server) ——> 网络层(server) ——> 网络层(client) ——> 传输层(client) ——> 应用层(client)的顺序返回到网络进程。
1. 数据传输完成，TCP 四次挥手断开连接。如果，浏览器或者服务器在 HTTP 头部加上 `Connection:Keep-Alive`，TCP 就一直保持连接。保持 TCP 连接可以省下下次需要建立连接的时间，提示资源加载速度。
1. 网络进程将获取到的数据包进行解析，根据响应头中的 `Content-type` 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 `text/html` 类型，就通知浏览器进程获取到文档准备渲染。（接收到 http 响应头中的 content-type 类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做 DOM 解析了！）
1. 浏览器进程获取到通知，根据当前页面 B 是否是从页面 A 打开的并且和页面 A 是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程（Process-per-site-instance 模式判断）。
1. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程。
1. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 web 页面，此时的web 页面是空白页。
1. 渲染进程对文档进行页面解析和子资源加载，HTML 通过 HTML 解析器转成 DOM Tree，CSS 按照 CSS 规则和 CSS 解释器转成 CSSOM TREE，两个 tree 结合，形成 render tree（不包含 HTML 的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来。 -->
