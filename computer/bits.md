# 搞明白位运算、补码、反码、原码<!-- omit in toc -->

- [TL;DR](#tldr)
  - [补码、反码、原码](#补码反码原码)
  - [位运算](#位运算)
    - [位移运算](#位移运算)
    - [逻辑运算](#逻辑运算)
- [原码、反码、补码](#原码反码补码)
  - [原码](#原码)
  - [反码](#反码)
  - [补码](#补码)
- [位移运算](#位移运算-1)
  - [正数位移运算](#正数位移运算)
  - [负数位移运算](#负数位移运算)
  - [无符号右移](#无符号右移)
  - [总结](#总结)
- [逻辑运算](#逻辑运算-1)
- [常用的按位运算技巧](#常用的按位运算技巧)
  - [使用按位非 `~` 判断索引存在](#使用按位非--判断索引存在)
  - [使用按位与 \& 去掉高位](#使用按位与--去掉高位)
  - [使用异或交换两个数](#使用异或交换两个数)
  - [x \& (x-1)](#x--x-1)
  - [常用性质](#常用性质)
    - [a 与自身之间的操作](#a-与自身之间的操作)
    - [a 与 0 之间的操作](#a-与-0-之间的操作)
    - [按位与、按位或的还原计算](#按位与按位或的还原计算)
    - [判断奇偶（取出最后一位）](#判断奇偶取出最后一位)
    - [比较两值是否相等](#比较两值是否相等)
    - [将 a 第 i + 1 个二进制位设为 1](#将-a-第-i--1-个二进制位设为-1)
    - [将 a 第 i + 1 个二进制位设为 0](#将-a-第-i--1-个二进制位设为-0)
    - [取出 a 第 i + 1 个二进制位上的 1](#取出-a-第-i--1-个二进制位上的-1)
    - [在 a 第 i + 1 个二进制位，插入 b 对应位置的二进制位](#在-a-第-i--1-个二进制位插入-b-对应位置的二进制位)
    - [删除二进制序列中最后一个值为 1 的位置](#删除二进制序列中最后一个值为-1-的位置)
    - [计算 a 的负数](#计算-a-的负数)
    - [仅保留 a 在二进制位中最后一个 1](#仅保留-a-在二进制位中最后一个-1)
    - [生成二进制位全为 1 的数](#生成二进制位全为-1-的数)
    - [保留 a 二进制序列中最后的 i - 1 位，其余补 0](#保留-a-二进制序列中最后的-i---1-位其余补-0)
    - [将 a 二进制序列中最后 i - 1 位全部置为 0](#将-a-二进制序列中最后-i---1-位全部置为-0)
    - [判断 a 的二进制序列最高位是否为 1](#判断-a-的二进制序列最高位是否为-1)
    - [在二进制序列中，仅保留最高位的 1，其他设为 0，输出该数](#在二进制序列中仅保留最高位的-1其他设为-0输出该数)
- [综合运用](#综合运用)

## TL;DR

> **并不是『应该避免位运算』，真正该用的地方当然是要用。而是要『避免误用位运算』。**

### 补码、反码、原码

1. 对于计算机来说用原码直接运算，效率不高；用反码直接运算，符号位可以直接参加运算，但是结果会不对；为了解决反码的问题就出现了补码。
2. 原码利用二进制中的第一位来表示符号位，`0` 表示正数，`1` 表示负数。
3. 正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。
4. 正数的补码和原码、反码一样，负数的补码就是 `反码 + 1`。

### 位运算

#### 位移运算

1. 所有的按位操作符的操作数都会被**转成补码**形式的有符号 `32` 位整数。
2. 在对补码进行移动时，**符号位是固定不动的**。
   1. 左移：无论正负数，高位非符号位丢弃，低位补 `0`
   2. 右移：低位移出(舍弃)，高位的所有空位补符号位，即**正数补 `0`，负数补 `1`**。
3. 无符号右移是指在进行移动时，符号位也会跟着一起移动。

```JS
m << n === m * (2 的 n 次方)
m >> n === Math.floor(m / (2 的 n 次方)) // 无论正负
```

#### 逻辑运算

|     运算符      |   用法   |                                          描述                                           |
| :-------------: | :------: | :-------------------------------------------------------------------------------------: |
|  按位与（AND）  | `a & b`  |   对于每一个比特位，只有两个操作数相应的比特位都是 `1` 时，结果才为 `1`，否则为 `0`。   |
|  按位或（OR）   | `a \| b` |  对于每一个比特位，当两个操作数相应的比特位至少有一个 `1` 时，结果为 `1`，否则为 `0`。  |
| 按位异或（XOR） | `a ^ b`  | 对于每一个比特位，当两个操作数相应的比特位有且只有一个 `1` 时，结果为 `1`，否则为 `0`。 |

## 原码、反码、补码

### 原码

| 十进制 |   原码    |
| :----: | :-------: |
|   2    | 0000 0010 |
|   -2   | 1000 0010 |

原码其实是最容易理解的，只不过需要利用二进制中的第一位来表示符号位，`0` 表示正数，`1` 表示负数，所以可以看到，一个 8 位数字用二进制原码表示的话，取值范围是 `-111 1111` ~ `+111 1111`，换成十进制就是 `-127` ~ `127`。

### 反码

在数学中我们有加减乘除，而**对于计算机来说最好只有加法**，这样计算机会更加简单高效，我们知道在数学中 `5 - 3 = 2`，其实可以转换成 `5 + (-3) = 2` ，这就表示减法可以用加法表示，而乘法是加法的累积，除法是减法的累积，所以在计算机中只要有加法就够了。

一个数字用原码表示是容易理解的，但是需要单独的一个 `bit` 来表示符号位。并且在进行加法时，计算机需要先识别某个二进制原码是正数还是负数，识别出来之后再进行相应的运算。这样效率不高，能不能让计算机在进行运算时不用去管符号位，也就是说**让符号位也参与运算**，这就要用到反码。

| 十进制 |   原码    |   反码    |
| :----: | :-------: | :-------: |
|   2    | 0000 0010 | 0000 0010 |
|   -2   | 1000 0010 | 1111 1101 |

**正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。**

用反码直接运算：

| 十进制 | 原码      | 反码      |
| ------ | --------- | --------- |
| 5      | 0000 0101 | 0000 0101 |
| -3     | 1000 0011 | 1111 1100 |

```js
  5-3
= 5+(-3)
= 0000 0101(反码) + 1111 1100(反码)
= 0000 0001(反码)
= 0000 0001(原码)
= 1
```

这不对呀? `5 - 3 = 1`？为什么差了 `1`？

我们来看一个特殊的运算：

```js
  1-1
= 1+(-1)
= 0000 0001(反码) + 1111 1110(反码)
= 1111 1111(反码)
= 1000 0000(原码)
= -0

  0+0
= 0000 0000(反码) + 0000 0000(反码)
= 0000 0000(反码)
= 0000 0000(原码)
= 0
```

我们可以看到 `1000 0000` 表示 `-0`，`0000 0000` 表示 `0`，虽然`-0` 和 `0` 是一样的，但是在用原码和反码表示时是不同的，我们可以理解为在用一个字节表示数字取值范围时，这些数字中多了一个 `-0`，所以**导致我们在用反码直接运算时符号位可以直接参加运算，但是结果会不对**。

### 补码

**为了解决反码的问题就出现了补码**。

**正数的补码和原码、反码一样，负数的补码就是 `反码 +1`。**

| 十进制 | 原码      | 反码      | 补码      |
| ------ | --------- | --------- | --------- |
| 5      | 0000 0101 | 0000 0101 | 0000 0101 |
| -3     | 1000 0011 | 1111 1100 | 1111 1101 |

```js
  5-3
= 5+(-3)
= 0000 0101(补码) + 1111 1101(补码)
= 0000 0010(补码)
= 0000 0010(原码)
= 2

  1-1
= 1+(-1)
= 0000 0001(补码) + 1111 1111(补码)
= 0000 0000(补码)
= 0000 0000(原码)
= 0

  0+0
= 0000 0000(补码) + 0000 0000(补码)
= 0000 0000(补码)
= 0000 0000(原码)
= 0
```

所以，我们可以看到补码解决了反码的问题。

**所以对于数字，我们可以使用补码的形式来进行二进制表示**。

## 位移运算

JavaScript 中有三个位移运算：

- `<<`：左移
- `>>`：右移
- `>>>`：无符号右移

### 正数位移运算

```js
console.log(2 << 1) // 4
console.log(2 >> 1) // 1
```

位运算是基于二进制 `bit` 来的，所以我们需要将十进制转换为二进制之后再进行运算：

- `2 << 1`：十进制 `2` 转换成二进制为 `00000000 00000000 00000000 00000010`，再将二进制左移一位，**高位丢弃，低位补 `0`**，所以结果为 `00000000 00000000 00000000 00000100`，换算成十进制则为 `4`

- `2 >> 1`：十进制 `2` 转换成二进制为 `00000000 00000000 00000000 00000010`，再将二进制右移一位，**低位丢弃，高位补 `0`**，所以结果为 `00000000 00000000 00000000 00000001`，换算成十进制则为 `1`

### 负数位移运算

我们再来看 `-2 << 1` 与 `-2 >> 1`

| 十进制 | 原码                                | 反码                                | 补码                                |
| ------ | ----------------------------------- | ----------------------------------- | ----------------------------------- |
| 2      | 00000000 00000000 00000000 00000010 | 00000000 00000000 00000000 00000010 | 00000000 00000000 00000000 00000010 |
| -2     | 10000000 00000000 00000000 00000010 | 11111111 11111111 11111111 11111101 | 11111111 11111111 11111111 11111110 |

> **规则：**
>
> 1. 所有的按位操作符的操作数都会被**转成补码**形式的有符号 `32` 位整数。
>
> 2. 在对补码进行移动时，**符号位是固定不动的**。
>
> 3. 按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即**正数补 `0`，负数补 `1`**。

`-2 << 1`，表示 `-2` 的补码左移一位后为 `10000000 00000000 00000000 00000010`，该补码对应的反码为：

```js
  11111111 11111111 11111111 11111100
- 1
= 11111111 11111111 11111111 11111011
```

该反码对应的原码为：符号位不变，其他位取反，为 `10000000 00000000 00000000 00000100` 十进制表示为 `-4`

同理 `-2 >> 2`，表示 `-2` 的补码右移 `2` 位（低位丢弃，高位补 `1`）后为 `11111111 11111111 11111111 11111111`，该补码对应的反码为：

```js
  10111111 11111111 11111111 11111111
- 1
= 11111111 11111111 11111111 11111110
```

该反码对应的原码为：符号位不变，其他位取反，为 `10000000 00000000 00000000 00000001` 十进制表示为 `-1`

### 无符号右移

上面在进行左移和右移时，在对补码进行移动时，符号位是固定不动的，而无符号右移是指在进行移动时，符号位也会跟着一起移动。 比如 `-2 >>> 1`。

- -2 用原码表示为 `10000000 00000000 00000000 00000010`
- -2 用反码表示为 `11111111 11111111 11111111 11111101`
- -2 用补码表示为 `11111111 11111111 11111111 11111110`
- -2 的补码右移 `1` 位为：`01111111 11111111 11111111 11111111`

右移后的补码对应的反码、原码为：`01111111 11111111 11111111 11111111` （因为现在的符号位为 `0`，表示正数，**正数的原、反、补码都相同**）

所以，对应的十进制为 `-2 >>> 1 = 2147483647`

### 总结

```js
2 << 1 = 4 = 2 * 2
2 << 2 = 8 = 2 * 2 * 2
2 << n = 2 * (2 的 n 次方)
m << n = m * (2 的 n 次方)
```

## 逻辑运算

按位操作符将其操作数当作 `32` 位的比特序列（由 `0` 和 `1` 组成）操作，返回值依然是标准的 `JavaScript` 数值。`JavaScript` 中的按位操作符有

|     运算符      |   用法   |                                          描述                                           |
| :-------------: | :------: | :-------------------------------------------------------------------------------------: |
|  按位与（AND）  | `a & b`  |   对于每一个比特位，只有两个操作数相应的比特位都是 `1` 时，结果才为 `1`，否则为 `0`。   |
|  按位或（OR）   | `a \| b` |  对于每一个比特位，当两个操作数相应的比特位至少有一个 `1` 时，结果为 `1`，否则为 `0`。  |
| 按位异或（XOR） | `a ^ b`  | 对于每一个比特位，当两个操作数相应的比特位有且只有一个 `1` 时，结果为 `1`，否则为 `0`。 |
|  按位非（NOT）  |   `~a`   |                   反转操作数的比特位，即 `0` 变成 `1`，`1` 变成 `0`。                   |

下面举几个例子，主要看下 `AND` 和 `OR`

```py
# 例子1
    A = 10001001
    B = 10010000
A | B = 10011001

# 例子2
    A = 10001001
    C = 10001000
A | C = 10001001
```

```py
# 例子1
    A = 10001001
    B = 10010000
A & B = 10000000

# 例子2
    A = 10001001
    C = 10001000
A & C = 10001000
```

## 常用的按位运算技巧

所有的技巧，斯坦福计算机系都整理好了

> [Bit Twiddling Hacks](http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting)

### 使用按位非 `~` 判断索引存在

<!-- 负数在内存里面（机器数）使用补码表示，正数是用原码 -->
`-1` 的补码全为 `1`，按位非之后就变成全为 `0`，正数的补码和原码一样，所以 `~-1 === 0`

### 使用按位与 & 去掉高位

**例如:**

```js
let A = 0b01000110 // 十进制为 70
let B = 0b10000101 // 十进制为 133

let _ = 0b00001111

console.log((A & _).toString(2)) // 110
console.log((B & _).toString(2)) // 101
```

a, b 的前 4 位和 `0000` 与一下之后就都变成 `0` 了，而后四位和 `1111` 与一下之后还是原来的数。**这个实际的作用是有一个数字它的前几位被当作 A 用途，而后几位被用当 B 用途，为了去掉前几位对 B 用途的影响，就可以这样与一下。**

**判断奇偶数：**

**方法：** 将该数字与 `1` 进行按位与，如果结果为 `0` 则是偶数，如果是 `1` 则为奇数

**原理：** 因为一个 int 类型的整数，低位二进制数字决定该 int 类型的数字的奇偶性，最低位为 `1` 则奇数，为 `0` 则偶数。

```JS
// 1 => 0b000......0001
// 忽略高位，只对最低位操作

// 1 => 0b00000001
// 3 => 0b00000011
// 2 => 0b00000010

// 1 & 3 => 0b00000001 === 1
// 1 & 2 => 0b00000000 === 0
```

### 使用异或交换两个数

> [利用异或方式交换两个变量值的原理是什么？](https://www.zhihu.com/question/62003033)

- **异或满足交换律和结合律**
- x ^ x === 0
- x ^ 0 === x

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/web/v2-6640855360beda8b89d2b86064344521_1440w.png)

**不建议在实际使用中采用这样的写法**。

这种方法存在一个缺陷：如果 `a` 和 `b` 引用的是同一个变量的话，使用这种方法会使得这个变量变为 `0`

```js
// 异或交换两个数
// 算术运算右侧必须是 "any"、"number"、"bigint" 或枚举类型。
let a: any = { x: 1 }
let b = a

a = a ^ b
b = a ^ b
a = a ^ b

console.log(a) // 0
```

这种奇技淫巧虽然看起来十分巧妙，但这样并不见得能够比朴素的交换来的更快。

### x & (x-1)

- `x & -x` 可以获得最低一位 `1` 表示的十进制数

  ```js
  console.log(1 & -1) // 1
  console.log(2 & -2) // 2
  console.log(3 & -3) // 1
  console.log(4 & -4) // 4
  console.log(5 & -5) // 1
  console.log(6 & -6) // 2
  // ...
  console.log(8 & -8) // 8
  ```

- `x & (x - 1)` 可以获得去掉最后一个 `1` 后的值

  ```js
  console.log(2 & 1) // 0
  console.log(3 & 2) // 2
  console.log(4 & 3) // 0
  console.log(5 & 4) // 4
  console.log(6 & 5) // 4
  console.log(7 & 6) // 6
  console.log(8 & 7) // 0
  ```

用 `x & (x-1)` 消去二进制中最右侧的 `1` 可以解决很多问题，比如，**用 `O(1)` 时间检测整数 n 是否是 2 的幂次**；计算在一个 32 位的整数的二进制表式中有多少个 `1` 等。

### 常用性质

在使用位运算技巧解的算法题中，有以下这些常用的性质：

<!-- 不带循环，全部 O(1) -->

#### a 与自身之间的操作

```sh
a & a = a
a | a = a
a ^ a = 0
```

#### a 与 0 之间的操作

```sh
a & 0 = 0
a | 0 = a
a ^ 0 = a
```

#### 按位与、按位或的还原计算

```sh
a | ( a & b ) = a
a & ( a | b ) = a
```

#### 判断奇偶（取出最后一位）

```sh
# 位运算效率高
a & 1 === a % 2
```

#### 比较两值是否相等

```sh
# 比较内存地址是否相同
a ^ b === 0
```

#### 将 a 第 i + 1 个二进制位设为 1

```sh
a |= 1 << i
```

#### 将 a 第 i + 1 个二进制位设为 0

```sh
a &= ~(1 << i)
```

#### 取出 a 第 i + 1 个二进制位上的 1

```sh
a & (1 << i)
```

#### 在 a 第 i + 1 个二进制位，插入 b 对应位置的二进制位

```sh
# a 的 bit 位置 1
# 与 b 的 bit 位相与
a |=1 << i
a & (b & 1 << i)
```

#### 删除二进制序列中最后一个值为 1 的位置

```sh
a & (a - 1)
```

#### 计算 a 的负数

```sh
-a = ~a + 1
```

#### 仅保留 a 在二进制位中最后一个 1

```sh
a & (-a)
```

#### 生成二进制位全为 1 的数

```sh
~0 === -1
~-1 === 0
```

#### 保留 a 二进制序列中最后的 i - 1 位，其余补 0

```sh
a & ((1 << i) - 1)
```

#### 将 a 二进制序列中最后 i - 1 位全部置为 0

```sh
a & ~((1<<i)-1)
```

#### 判断 a 的二进制序列最高位是否为 1

```sh
# 最高位为 1 必然是负数
a < 0
```

#### 在二进制序列中，仅保留最高位的 1，其他设为 0，输出该数

```sh
a = a | (a >> 1)
a = a | (a >> 2)
a = a | (a >> 4)
a = a | (a >> 8)
a = a | (a >> 16)
return (a + 1) >> 1
```

## 综合运用

- [JavaScript 中的位运算和权限设计](https://juejin.cn/post/6844903988945485837)
- [巧用 JS 位运算](https://zhuanlan.zhihu.com/p/34294099)
- [ObservedBits: React Context 的秘密功能](https://zhuanlan.zhihu.com/p/51073183)
- [位运算有什么奇技淫巧](https://www.zhihu.com/question/38206659/answer/392527806)
- [位运算的算法应用](https://juejin.cn/post/6962083070442733598)
