# 谁还不是个科班出身了<!-- omit in toc -->

- [图灵机](#图灵机)
  - [资料](#资料)
  - [笔记](#笔记)
  - [总结](#总结)
  - [拓展：罗素悖论](#拓展罗素悖论)
  - [拓展：停机问题](#拓展停机问题)
- [CPU 的工作原理是什么？](#cpu-的工作原理是什么)
- [计算机系统 64 位 32 位指的是什么？](#计算机系统-64-位-32-位指的是什么)
- [复杂指令集 CISC 和精简指令集 RISC](#复杂指令集-cisc-和精简指令集-risc)
- [多核 CPU 和多个 CPU 有何区别？](#多核-cpu-和多个-cpu-有何区别)
- [CPU 的 4 核 8 线程什么意思？](#cpu-的-4-核-8-线程什么意思)
- [CPU 核数与线程数有什么关系？](#cpu-核数与线程数有什么关系)
- [CPU 空闲时在干嘛？](#cpu-空闲时在干嘛)
- [计算机是如何启动的？](#计算机是如何启动的)
- [数据结构是如何装入 CPU 寄存器的？](#数据结构是如何装入-cpu-寄存器的)
- [不懂 CPU 如何读写内存还敢说自己是程序员？](#不懂-cpu-如何读写内存还敢说自己是程序员)
- [程序？进程？傻傻分不清？](#程序进程傻傻分不清)
- [线程和进程的区别是什么？](#线程和进程的区别是什么)
- [如何评价「线程的本质就是一个正在运行的函数」?](#如何评价线程的本质就是一个正在运行的函数)
- [线程间到底共享了哪些进程资源？](#线程间到底共享了哪些进程资源)
- [线程崩溃是否会造成进程崩溃？](#线程崩溃是否会造成进程崩溃)
- [函数运行时在内存中是什么样子？](#函数运行时在内存中是什么样子)
- [既然每个程序占用的内存都是操作系统管理的，为什么内存泄漏还是个问题？](#既然每个程序占用的内存都是操作系统管理的为什么内存泄漏还是个问题)
- [图解 | 你管这破玩意叫文件系统？](#图解--你管这破玩意叫文件系统)
- [读取文件时，程序经历了什么？](#读取文件时程序经历了什么)
- [100% 弄明白 5 种 IO 模型](#100-弄明白-5-种-io-模型)
- [从科学记数法到浮点数标准 IEEE 754](#从科学记数法到浮点数标准-ieee-754)
- [位运算](#位运算)
  - [进制转换](#进制转换)
  - [原码、反码、补码](#原码反码补码)
- [什么是解释型语言？](#什么是解释型语言)

## 图灵机

### 资料

- [图灵机的解释](https://mp.weixin.qq.com/s/oKrsznBAumrNvz4_xtktXw)
- [什么是图灵完备？](https://www.zhihu.com/question/20115374/answer/288346717)
- [为什么所有编程语言都是数据 + 指令?](https://www.bilibili.com/video/BV1Za411t7c6)

### 笔记

> **数学运算的本质特征**：

1. 在每一步中，只需要关注少数符号。
2. 每一步采取的行动，仅仅取决于当前的运算符号、计算人当前的记忆状态。

> **运算行为过程中的人，是完全可以由机器取代的**。

这就是图灵最初给出的，自动运算机器的抽象逻辑归纳，也是用来证明判定问题不存在算法的方法：**如果一个问题无法用图灵机来完成，那么可以说，没有任何算法程序可以解决这个问题。也就是说，凡是能用算法方法解决的问题，也一定能用图灵机解决。**

> **图灵完备**

在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。———— 维基百科

> **Brainfuck is fully Turing-complete.**

Brainfuck 的工作机制与图灵机高度一致。

首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。

> JS 模拟实现：[Brainfuck.js](brainfuck.js)

语言里的 8 个有效字符分别是：

- `>` 指针向右移动一格
- `<` 指针向左移动一格
- `+` 使指针当前格数值加一
- `-` 使指针当前格数值减一
- `.` 把当前格数值按 ASCII 表输出到终端
- `,` 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格
- `[` 当指针当前值为 `0` 时，程序跳转至与之对应的 `]` 之后；否则程序正常执行
- `]` 程序跳转回与之对应的 `[` 处

有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 'A' 对应的值为 65，可以使用 `5 * 13` 算出 65 并输出得到字符 'A'。

```bf
+++++

[
>+++++++++++++
<-
]

>.
```

**👟 解释：** 把指针初始处的格子命名为 `cell 0`，`cell 0` 右边的那个格子命名为 `cell 1`。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次，左移指针，递减 1 次”。当 `cell 0` 的值最终被递减为 0 的时候，循环结束。此时 `cell 1` 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 `cell 1`，输出此格子，则在终端会看到 'A'。

**🐟 拓展：** *brainfuck 还有一个用处，一门新语言功能语法很复杂，要用数学证明的方式确定性说明它图灵完备会很麻烦，但只要用这门新语言实现一个 brainfuck 的解释器，那么就必然证明了是图灵完备的*

### 总结

图灵机解决了几个问题：

1. **可计算性问题**。一个数是否是可计算的，称为可计算数。可计算数只是实数的一部分，大多数实数都是不可计算的。（通用计算机）
2. **可判定性问题**。是否存在通用的过程，判断某个公式是可以证明的。（停机问题）
3. **人类计算者与计算机等价**。通过图灵测试判定计算机的智能。（人工智能）

### 拓展：罗素悖论

理发师悖论由哲学家罗素在 1903 年提出，也称为罗素悖论。有一个理发师打广告，说：“我只给本城所有不给自己刮脸的人刮脸。”

问题是：理发师能不能给他自己刮脸呢？如果他不给自己刮脸，他就属于“不给自己刮脸的人”；如果他给自己刮脸，他就属于“给自己刮脸的人”，他就不该给自己刮脸。

在理发师悖论的基础上，罗素构建了一个“集合” S： S 由一切不是自身元素的集合组成。然后，罗素问：S 是否属于 S 呢？根据排中律，一个元素或者属于某个集合，或者不属于某个集合。因此，对于一个给定的集合，某个元素或者属于该集合，或者不属于该集合。

但对罗素提出的这个“集合” S 是否属于 S，却没有那么容易判断：如果 S 属于 S，根据 S 的定义，S 就不属于 S；反之，如果 S 不属于 S，同样根据定义，S 就属于 S。

### 拓展：停机问题

> [如何通俗地解释停机问题（Halting Problem）？](https://www.zhihu.com/question/20081359/answer/275107187)

## CPU 的工作原理是什么？

> [你管这破玩意叫 CPU ？](https://zhuanlan.zhihu.com/p/367927405)

## 计算机系统 64 位 32 位指的是什么？

<!-- 32 位内存最大为 2 ^32 === 4g -->
> <https://www.youtube.com/watch?v=Wu2A4fpFzgs>

## 复杂指令集 CISC 和精简指令集 RISC

> 不知道什么原因，特别喜欢精简指令集的设计哲学。就像写代码就要像堆积木一样。RISC 就是用多个小方法互相调用完成复杂的功能，CISC 则是专门写一个大方法完成复杂的功能。

- [你管这破玩意叫精简指令集？](https://zhuanlan.zhihu.com/p/384606064)
- [你管这破玩意叫复杂指令集？](https://zhuanlan.zhihu.com/p/375844125)

## [多核 CPU 和多个 CPU 有何区别？](https://zhuanlan.zhihu.com/p/85819786)

多核 CPU 和多 Die 乃至多路 CPU，**对操作系统等来看，区别不大，BIOS 都报告了同样多的很多 CPU 供他们调度。** 区别主要在于性能（*数据流和指令流的交流，越方便性能越好*）上面，**多核 CPU 性能最好**，但成本最高；多 CPU 成本小，便宜，但性能相对较差。

## CPU 的 4 核 8 线程什么意思？

那是 CPU 说你可以把我认为有 8 个独立工作的单核 CPU 的意思，4 核代表我真的由 4 个可以实际独立工作的单核 CPU 组成，8 线程代表 CPU 说你可以把我认为我是由 8 个可以独立工作的单核 CPU，但是实际上多出来 4 个是我一个人干两个人的活，用的时候小心一点。

## [CPU 核数与线程数有什么关系？](https://zhuanlan.zhihu.com/p/391588682)

> CPU 的核心数和线程个数没有什么必然的关系。

**“线程是为那些不懂状态机的人准备的”**，这句话在单核时代有它的道理，因为在单核时代，所有的任务都不是在同时向前推进，而是“交错”前进，A 前进一点，然后 B 前进一点，线程并不是实现这种“伪并行”唯一的方法，状态机也可以。

但在多核时代，这句话就不再适用了，**对于大多数程序员来说多进程多线程几乎是充分利用多核资源的唯一方法。**

## [CPU 空闲时在干嘛？](https://zhuanlan.zhihu.com/p/356447262)

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220418-eaz.png)

## [计算机是如何启动的？](https://www.zhihu.com/question/40831686)

CPU 的工作就是不断读取指令，然后执行这些指令。

写一段 CPU 能读的程序，加电后，让它去初始化其它硬件，去使用其它硬件。

从最低级的操作硬件的程序读起，逐渐高级，直到普通程序。

## [数据结构是如何装入 CPU 寄存器的？](https://zhuanlan.zhihu.com/p/401956825)

编译器把那些经常使用的数据放到寄存器，剩下的放到内存中，然后利用内存读写指令在寄存器和内存之间来回搬运数据。

## [不懂 CPU 如何读写内存还敢说自己是程序员？](https://zhuanlan.zhihu.com/p/390117048)







## [程序？进程？傻傻分不清？](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485647&idx=1&sn=3336b441482736b4e9a2b32f9d272a5b&source=41#wechat_redirect)

> 程序运行起来之后就叫进程。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220418-fb1.png)

## [线程和进程的区别是什么？](https://www.zhihu.com/question/25532384)

> **进程是资源分配的最小单位，线程是 CPU 调度的最小单位**

进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。

我的理解是进程切换就是 A 进程时间片结束之后 B 进程去使用 CPU 资源，此时要加载的是整个进程的上下文。有了线程的话就是只加载线程的上下文，而某一个线程的上下文小于进程的上下文。

## [如何评价「线程的本质就是一个正在运行的函数」?](https://www.zhihu.com/question/469947035)

> 简化模型

- 进程切 CPU 上下文需要切换 Stack + Heap
- 线程切 CPU 上下文只需要切 Stack

所以本质就是个更快切上下文的东西。

> [进程切换与线程切换的区别？](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485646&idx=1&sn=ab57d6e2e66affefc104e04740356b39&chksm=cfe9944ef89e1d58a87c295cf1c54f78c39238214405b446c8bf4f4371fc29e0fd8d2b3cf9a6&cur_album_id=1923404049802985480&scene=190#rd)

## [线程间到底共享了哪些进程资源？](https://zhuanlan.zhihu.com/p/352707156)

## [线程崩溃是否会造成进程崩溃？](https://www.zhihu.com/question/22397613)

![20230304021637](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230304021637.png)



## [函数运行时在内存中是什么样子？](https://zhuanlan.zhihu.com/p/339866296)

## [既然每个程序占用的内存都是操作系统管理的，为什么内存泄漏还是个问题？](https://www.zhihu.com/question/400104113)

![20230304024232](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230304024232.png)

## [图解 | 你管这破玩意叫文件系统？](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247494176&idx=1&sn=b4680b50090bb3c7b9c49379241c536c&chksm=c2c5908df5b2199b361885b32b07ab0f597ab25cd1d70bb75ca13fb897c200285685318f145f&scene=178&cur_album_id=1703494881072955395#rd)

## [读取文件时，程序经历了什么？](https://zhuanlan.zhihu.com/p/260375849)

## 100% 弄明白 5 种 IO 模型

<!-- 阻塞 ～ 长轮询 -->
<!-- 非阻塞 ～ 轮询 -->
<!-- 多路复用，一个线程做多件事 -->
> [你管这破玩意叫 IO 多路复用？](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247494866&idx=1&sn=0ebeb60dbc1fd7f9473943df7ce5fd95&chksm=c2c5967ff5b21f69030636334f6a5a7dc52c0f4de9b668f7bac15b2c1a2660ae533dd9878c7c&cur_album_id=1700901576128643073&scene=189#wechat_redirect)

## [从科学记数法到浮点数标准 IEEE 754](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)

<!-- 注意小数精度，jit 优化，位运算随便用，位运算会转换 32 位整数 -->
> [浮点数 —— 从惊讶到思考](float.md)

## 位运算

> [JavaScript 的位操作应该避免吗？](https://www.zhihu.com/question/65747485/answer/234725511)

### 进制转换

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220408-acz.png)

### 原码、反码、补码

> [搞明白位运算、补码、反码、原码](bits.md)

## [什么是解释型语言？](https://www.zhihu.com/question/268303059)

语言是用来写代码的，代码是给人看的。

计算机只看得懂程序（ `01010101` ），看不懂代码。

把代码变成程序有两个常用的方法：

1. 把所有的代码变成程序，再执行。**即，先编译再执行**。
2. 把一丢丢代码变成一丢丢程序执行，然后再把一丢丢代码变成一丢丢程序执行，...。**即，边解释边执行**。

谁来编译？谁来解释？谁来执行？

- **编译型**：编译器来编译，系统执行。
- **解释型**：解释器解释并执行。

举个例子 🌰：

你女网友只懂中文（源代码），你只懂英文（机器码 / CPU 指令），现在你俩要搞对象，怎么办？

女网友写下了自己的：`要求.py`:

```py
二号男嘉宾
我要吃好的
我要穿好的
我要住好的
我不会做饭
我不会家务
我脾气不好
```

由于你们语言不通，直接是无法交流的，所以必须要有一个翻译官（ python 解释器）

1. **解释器的执行流程**

    ```py
    二号男嘉宾 => SLOT #2
    我要吃好的 => FOOD +10W
    我要穿好的 => DRESS + 10W
    我要住好的 => HOUSE + 100W
    我不会做饭 => ELEME + 7W
    我不会家务 => BABYSITTER + 3W
    我脾气不好 => PSYCHOLOGIST + 10W
    ```

    翻译官将中文翻译成了你能懂的英文（ CPU 指令），这是你的执行流程：

    ```py
    SLOT #2 => ACK
    FOOD +10W => +10W
    DRESS + 10W => +10W
    HOUSE + 100W => +100W
    ELEME + 7W => +7W
    BABYSITTER + 3W => +3W
    PSYCHOLOGIST + 10W => +10W
    ```

    **每接到一次指令，你就去 `ATM` 取一次钱，一共需要取 `6` 次钱；**

    然后你将继续等待对方开出的条件，进入 `Idle` 状态，直到翻译将新的指令给你，直到条件开完毕，而你又能一直从 `ATM` 里面取出钱来，然后你们就幸福的在一起了。

2. **`JIT` 优化**

    你应该看出来了，`Python` 解释器（翻译官）每次传递一行指令，但要求其实都差不多，所以 `JIT` 这时候就派上用场了，**第一次的过程其实是一样的**，但是你的女网友发现你没有回复她的时候，又说了一遍，还说了第三遍，这个时候如果有 `JIT`（比如 `Pypy`），那么从第二次开始，翻译官给你的就不再是一行一行的指令了，而是：

    ```py
    +10W + 10W + 100W + 7W + 3W + 10W
    ```

    **这时候，你只需要去一次 `ATM`，一次性取出需要的这些钱，你们就能幸福的在一起了。**

    > [JIT 即时编译的原理](https://zhuanlan.zhihu.com/p/46917559)

3. **顺提一下编译型**

    就是翻译官（此处应该叫编译官）把 **你女网友的**`要求.py`直接重新找了一张 `A4` 纸，上面写着：

    ```py
    $$
    ```

    这样每次你女网友拿着这张纸到 `x86` 窗口的 `ATM` 直接就能办理了，**注意，仅此窗口，别家店不可以用的**，咦，好像少了什么人？也是，如果都能直接跟 `ATM` 沟通了，谁还需要男盆友呢？

4. **性能**

    因为解释型语言在编译的时候只是编译成了字节码，运行的时候，还需要解释器挨个把字节码翻译成机器语言才能执行。

    相当于你写的程序，每次都要先「编译」，再运行，运行速度必然比只需要运行不需要编译的编译型语言慢。

    <!-- javascript 运行时确定类型 -->
    `JavaScript` 是一种动态类型语言，在编译时并不能准确知道变量的类型，只可以在运行时确定，这就不像 `c++` 或者 `java` 等静态类型语言，在编译时候就可以确切知道变量的类型。然而，在运行时计算和决定类型，会严重影响语言性能，这也就是 `JavaScript` 运行效率比 `C++` 或者 `JAVA` 低很多的原因之一。
