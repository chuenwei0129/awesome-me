---

group:
  title: 2024 🐲
title: `Node.js` 和浏览器中 `setTimeout()` 的差异
toc: content
---

## 浏览器中的 `setTimeout()`

在浏览器中，`setTimeout()` 的返回值是一个整数（integer），表示定时器的 ID。此外，如果嵌套层级大于 5 且超时时间小于 4 毫秒，超时时间会被设定为最少 4 毫秒。这是为了防止过于频繁的回调影响性能。

## `Node.js` 中的 `setTimeout()`

在 `Node.js` 中，`setTimeout()` 返回的是一个 `Timeout` 对象，而不是一个整数 ID。此外，`Node.js` 中并没有强制实施浏览器中的 4 毫秒规则，因此超时的处理方式有所不同。

## 触发顺序的差异

以下是一个示例代码，展示了在不同环境中定时器的触发顺序差异：

```js
setTimeout(() => {
  console.log(1);
}, 10);

setTimeout(() => {
  console.log(2);
}, 15);

let now = Date.now();
while (Date.now() - now < 100) {
  // 模拟阻塞
}

setTimeout(() => {
  console.log(3);
}, 10);

now = Date.now();
while (Date.now() - now < 100) {
  // 模拟阻塞
}
```

**在浏览器中：**

在浏览器中，Timeout 的触发时间按实际超时时间的迟早进行排序。上例中，三个 Timeout 的触发时间分别为 10 毫秒、15 毫秒和 110 毫秒，所以触发顺序应该是 `1`、`2`、`3`。实际上，由于第二个阻塞（200 毫秒）结束时，所有的 Timeout 都已经过期，因此它们会立即被触发，顺序是 `1`、`2`、`3`。

**在 `Node.js` 中：**

在 `Node.js` 中，事件循环机制有所不同，导致触发顺序不再是 `1`、`2`、`3`，而是 `1`、`3`、`2`。可以通过一个比喻来理解：想象有三个羊圈，分别装有红色、黑色和黄色的羊。每次我们都会选择一个羊毛最多的羊圈，**进入并依次薅羊毛**，直到该圈的羊毛都被薅光，然后再选择下一个羊圈。由于羊毛会不断生长，可能当我们再次回到第一个羊圈时，它的羊毛已经长出来了。这个过程会持续进行，直到所有羊毛都被薅光。
