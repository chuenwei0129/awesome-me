---
title: λ 演算与函数式编程
order: 1
toc: content
group:
  title: 计算机原理
  order: 1
---

## 函数这个翻译有多形象

“函数”一词源自文言文：凡此变数中函彼变数者，则此为彼之函数。大意是：在一组变量中，“包含”或“装着”另一变量变化规律的那个量，就叫做它的“函数”。

“函”本义是“箭囊”，也就是装箭的袋子，引申为“装起来”“包起来”。从这个角度看，把“对输入做点处理，把结果装起来”叫做“函数”，确实非常形象——就像我们在编程里写的 `f(x)` 一样：`f` 是一只“袋子”，`x` 放进去，出来一个结果。

## 传统数学中的函数记号与局限

在传统初等数学中，我们通常这样写函数：

- 直接写成等式：
  \[
  y = x^2 - 2x + 1
  \]
  我们口头说：“\(y\) 是 \(x\) 的函数”。

- 或者先定义一个函数：
  \[
  f(x) = x^2 - 2x + 1,\quad y = f(x)
  \]

再考虑另一个函数：
\[
g(x) = x^2
\]
我们也可以写：
\[
y = g(x - 1)
\]
这看起来好像“\(y\) 也是 \(x-1\) 的函数”。

**其实现代数学本身已经可以区分：**

- 函数对象：`f`、`g` 本身；
- 函数定义：`f: X → Y`，再用 `f(x) = x^2 - 2x + 1` 指出具体规则；
- 函数应用：`f(x)` 表示把函数 `f` 应用在参数 `x` 上。

但在初等阶段，我们往往只关注“代入算结果”，而不强调“函数本身也是一个值”，更不强调“以函数为参数或返回值”的表达方式。这就使得：

- 函数看起来更像“公式”，而不是“可以被传来传去的数据”；
- 对“函数作为一等公民”的理解比较模糊。

λ 演算（Lambda Calculus）的价值之一，就是在形式系统层面，把“函数是什么”“如何应用”用一套极简却精确的记号表达清楚。

## λ 演算：一种极简的函数模型

λ 演算由阿隆佐·丘奇（Alonzo Church）在 20 世纪 30 年代提出，本意是研究“函数”“可计算性”等基础问题。它只有三种构造：

- **变量**：例如 `x`、`y`、`z`
- **抽象（函数定义）**：`λx.M`，表示一个参数为 `x`、函数体为 `M` 的函数
- **应用（函数调用）**：`M N`，表示把函数 `M` 应用到参数 `N` 上

用 λ 演算的记号，我们可以把刚才的函数写成：

```text
λx.(x^2 - 2x + 1)
```

并把应用写成：

```text
(λx.(x^2 - 2x + 1)) 1
```

括号 `(...)` 表示“这是一个整体的函数”，后面紧跟参数 `1` 表示“把这个函数应用到 1 上”。

**这里有两个重点：**

- “函数定义”（`λx.(...)`）和“函数应用”（紧跟参数）严格区分；
- 函数本身就是表达式，可以像普通数据一样传递、返回、组合。

这正是现代函数式编程语言（如 Haskell、OCaml、以及 JavaScript/TypeScript 里的函数式风格）赖以站立的数学基础。

## λ 演算的基本形式规则

在最基础的 λ 演算中，我们只关心“表达式如何一步一步约简（求值）”。核心规则有三类：

- **语法**

  - 变量：`x`
  - 抽象：`λx.M`
  - 应用：`M N`

- **α-转换（改名）**

  - 改参数名但不改变含义：
    `λx.x` 与 `λy.y` 本质上是同一个函数。

- **β-约简（函数应用）**
  - `(λx.M) N` 可以约简为 `M[x := N]`
    即把函数体 `M` 中自由出现的 `x` 都替换成 `N`：
    ```text
    (λx.(x + 1)) 2
    → 2 + 1
    → 3
    ```

在更完整的理论里，还会讨论：

- **η-转换**（函数外观等价的规则）；
- 约简顺序（先约简哪里）与是否会终止等问题。

但对于前端/工程实践者，理解“`λx.M` 是函数定义、`(λx.M) N` 通过替换求值”已经足够支撑后续的直觉。

## 多变量函数、柯里化与高阶函数

在数学里，多变量函数常写作：

\[
f(x, y) = 2x + y
\]

在 λ 演算中，我们不直接写“多参数函数”，而是**写成函数嵌套函数**：

```text
λx.λy.(2x + y)
```

可以理解为：

- 先是一个“接收 `x` 并返回另一个函数”的函数；
- 然后返回的函数“再接收 `y`，并计算 `2x + y`”。

应用时，从左到右依次应用：

```text
((λx.λy.(2x + y)) 1) 2
→ (λy.(2 * 1 + y)) 2
→ 2 * 1 + 2
→ 4
```

如果把参数顺序反过来：

```text
((λy.λx.(2x + y)) 1) 2
→ (λx.(2x + 1)) 2
→ 2 * 2 + 1
→ 5
```

也就是说：

- `λx.λy.(...)` 与 `λy.λx.(...)` 是两个不同的函数；
- 参数顺序会影响最终结果，这点在实际编码时非常重要。

这种“把多参数函数拆成一串一元函数”的思想，就叫做**柯里化（Currying）**。在 λ 演算中，它是一种很自然的写法；在 JavaScript/TypeScript 中，我们也经常这样写高阶函数来提升复用性。

> 约定：`f a b` 按惯例等价于 `((f a) b)`，也就是“先把 `a` 应用给 `f` 得到一个新函数，再把 `b` 应用给这个新函数”。

## λ 演算与函数式编程

λ 演算本身是一个**没有可变状态**的纯计算模型：

- 没有“变量重新赋值”的概念，只有“表达式替换”；
- 计算的过程就是“不断用 β-约简规则把表达式化简”。

这点与现代函数式编程的几个核心理念高度一致：

- **函数是一等公民**：
  - 函数可以作为参数传入；
  - 函数可以作为返回值返回；
  - 可以把函数存入变量、放入数据结构中。
- **尽量减少可变状态**：
  - λ 演算中只有替换，没有 `x = x + 1` 这种命令式赋值；
  - 在函数式风格中，我们鼓励更多使用“返回新值”的方式，而不是“原地修改”。
- **递归与组合**：
  - 在 λ 演算里，我们可以使用固定点组合子等技巧来表达递归；
  - 在实际语言中，这体现为直接写递归函数，或者通过高阶函数（`map`、`reduce` 等）组合行为。

可以粗略地说：**现代函数式编程语言，就是在 λ 演算的思想上加上类型系统、数据结构、IO 能力和工程实践之后得到的产物。**

## λ 演算与图灵机、图灵完备性

λ 演算和图灵机是计算机科学中最经典的两种计算模型：

- **λ 演算**：基于变量、函数抽象、函数应用和表达式替换；
- **图灵机**：基于无限纸带、读写头和有限状态控制器。

虽然形式完全不同，但可以证明：

> 任何在图灵机上可有效计算的函数，也可以在 λ 演算中表达；
> 反之亦然。

这就意味着 λ 演算和图灵机在“可计算能力”上是等价的，二者都是**图灵完备**的模型。这种等价性通常归纳到一个更大的观点：**丘奇–图灵论题**。

> 在忽略时间和空间资源限制的前提下，任何“可有效计算”的函数，都可以被图灵机或 λ 演算这样的模型表达和计算出来。

对工程实践的启示是：

- 只要一种编程语言是图灵完备的（大多数通用语言都满足），理论上就能表达所有可有效计算的算法；
- 我们选择语言和范式（命令式、函数式、面向对象）更多是考虑**表达力、可维护性、类型系统、生态和工程效率**，而不是“能不能算”。

## JavaScript 中的 λ 演算实践

JavaScript 是一门**支持函数式编程风格**的语言。虽然它不是“纯函数式语言”，但以下特性都明确继承了 λ 演算的思想：

- 匿名函数（λ 抽象）；
- 函数作为一等公民；
- 高阶函数；
- 柯里化和部分应用。

下面用几段能直接运行的 JavaScript 代码，把 λ 演算中的概念落地。

### 匿名函数与高阶函数

```js
// 匿名箭头函数，对应 λx.x * x
const square = (x) => x * x;

// 高阶函数：接收一个函数并返回新函数
const withLog = (fn) => (x) => {
  const result = fn(x);
  console.log('input:', x, 'output:', result);
  return result;
};

const loggedSquare = withLog(square);
loggedSquare(3); // 控制台输出：input: 3 output: 9
```

对应到 λ 演算，可以类比成：

```text
square   ≈ λx.(x * x)
withLog  ≈ λf.λx.(log(f(x)))
```

`withLog` 返回的就是“函数作为返回值”的典型高阶函数，这和 λ 演算中 `λx.λy.(...)` 的模式完全一致。

### 柯里化与部分应用

用 λ 演算视角看待多参数函数 `f(x, y) = x + y`：

- λ 演算写作：`λx.λy.(x + y)`
- 先对 `x` 进行应用，再对 `y` 应用。

在 JavaScript 中，我们可以这样实现：

```js
// 柯里化的加法函数，对应 λx.λy.x + y
const add = (x) => (y) => x + y;

const add2 = add(2); // 相当于 λy.2 + y
console.log(add2(3)); // 5
console.log(add(10)(5)); // 15
```

与 λ 演算中的约简对照：

```text
add         ≈ λx.λy.(x + y)
add(2)      ≈ (λx.λy.(x + y)) 2
            → λy.(2 + y)
add(2)(3)   ≈ (λy.(2 + y)) 3
            → 2 + 3
            → 5
```

这种写法带来的工程价值是：

- 可以轻松做“部分应用”，预先固定一部分参数；
- 便于函数组合，例如在 React/Redux、RxJS 等库中，经常用柯里化函数来构建灵活的 API。

### 用函数表达布尔值与条件（类 Church 布尔）

在 λ 演算中，我们甚至可以只用函数来表达布尔值和条件逻辑。例如：

```text
TRUE  = λa.λb.a
FALSE = λa.λb.b
```

在 JavaScript 中也可以写出类似的代码：

```js
// 用纯函数表示布尔值
const TRUE = (a) => (b) => a;
const FALSE = (a) => (b) => b;

// IF 接受一个“布尔函数”cond 和两个分支 a / b
const IF = (cond) => (a) => (b) => cond(a)(b);

console.log(IF(TRUE)('yes')('no')); // 'yes'
console.log(IF(FALSE)('yes')('no')); // 'no'
```

这里的 `TRUE` 和 `FALSE` 完全没有使用内置的 `true` / `false`，而是用**“选择哪个参数”**来表达真假。这和 λ 演算中的 Church 布尔是一致的。

这样的设计虽然在工程中不会直接用（毕竟 JS 自带布尔类型），但非常直观地展示了：

> 只用函数，我们就能构造出布尔、自然数、条件分支等所有常见概念——这正是 λ 演算图灵完备性的直观来源。

### 与 TypeScript / React 等现代前端栈的联系

在 TypeScript 中，我们可以把刚才的柯里化函数加上类型：

```ts
const add =
  (x: number) =>
  (y: number): number =>
    x + y;
```

- 这是直接把“从数字到数字，再到数字”的函数类型表达出来；
- 对应 λ 演算中的 `x: Number`、`y: Number`、`Number` 返回值，只不过 TS 把类型显式写在了代码里。

在 React 中，我们也能看到 λ 演算思想的影子：

- `setState(prev => ...)`：

  - 把“状态更新”抽象成函数 `(prevState) => nextState`；
  - 这就是“把状态变换表达为函数”的典型函数式实践。

- 自定义 Hook 或高阶组件：
  - 本质上就是“以函数为输入、返回函数”的模式；
  - 和 `withLog`、`λx.λy.(...)` 的结构非常接近。

这些都是 λ 演算向现代前端工程实践迁移的具体体现。

## 小结

- 传统数学记号已经可以区分“函数对象”和“函数应用”，但在初等教学中对“函数作为值”“函数作为一等公民”缺少强调。
- λ 演算用极简的三种构造（变量、抽象、应用），配合 α、β 约简规则，为函数及计算提供了精确的形式模型。
- 多参数函数在 λ 演算中自然地体现为柯里化形式 `λx.λy.(...)`，这与我们在 JavaScript/TypeScript 中常用的柯里化、高阶函数写法高度一致。
- λ 演算与图灵机在可计算能力上是等价的，都是图灵完备模型，是理论计算机科学的基础之一。
- 在 JavaScript 实践中，通过匿名函数、高阶函数、柯里化，以及用函数表达布尔和条件，我们可以非常直观地感受到 λ 演算思想如何渗透到现代前端开发中。
