## 语义化

语义化的目的是为了让网页能够友好地被搜索引擎抓取到，一般是用在官网首页，信息分发等功能上。

但如果网页的主要功能不是可检索，自然不需要做 seo 和语义化了。

大部分现代的前端框架例如 Vue,Angular,React 都不会过多的考虑 seo，毕竟是应用开发，不是入口网页。

现在的做法大都是用静态页面做入口和 SEO，应用内部还是用 SPA，不然无法实现太过复杂的功能。

## 组合，依赖注入，控制反转

实际上组合，依赖注入，控制反转虽然含以上有点差别。比如组合是较为笼统的概念，依赖注入是一种实现方式，控制反转是要实现的目标。但实际上当我们在说这些词的时候，懂的人自然会懂。组合的意思是，一个类的组成包含多个其他类。比如汽车包含轮子，不管这个轮子是邓禄普还是普利司通，是薄胎还是越野专用，汽车都包含它（这个概念）。依赖注入即是轮胎这个组成部分直到汽车实例化时才会确定。控制反转即是对于汽车轮胎的定义并非耦合在汽车这一类中，而是在汽车的外部进行控制的。所以就很明确了，在 JavaScript 语境下，依赖注入就是函数参数是函数而已（高阶函数，因为 JS 没有类），而在 TypeScript 语境下，依赖注入就是在类的构造函数中传入另一个类，类实例化时包括其参数的类也会被实例化。

## mvvm

从这里可以看出，如果说 ViewModel 是传统意义上的“前端”的话，那么这个架构已经没有后端了（如果愿意把数据库管理员叫做后端的话，当我没说）这并不叫前后端分离，应该叫消灭掉传统后端所以你的理解并没有错，MVVM 本质上就是 MVC，但是这个 MVC 实在前端实现的。它的 M 也不是数据库里的数据源，而是后端网络接口提供的数据源。这就是 GraphQL 出现的原因，直接将数据库映射成网络接口，但是这种方案我是接受不了，使用 MVVM 的话“后端”已经没有多少工作可以做了，为何不能做戏做全套？facebook 不同，其数据接口几乎全是集群计算的网络接口。回头再看状态管理，不管是 rx，redux 还是 vuex，都是因为前端同后端环境不同，存在页面刷新，缓存失效等问题，数据源也不像后端那样数据库本身满足事务的四大特性。所以凡是涉及请求，最好的方式都是全部放置于状态管理器中（Store 就是 M）MVC 本身概念是具有“普世价值”的，及凡是数据转换，必定是这个流程。不过当时 React 发布的时候，为了方便理解（毕竟那时候前后端泾渭分明），才出现 MVVM 这一概念。因此，前后端的分发到现在已经没有意义了。如果真要这么分的话，分布式大数据存储，集群计算，人工智能才能叫后端，网络接口到 web 展示统统只能叫前端。实际上很多企业就是这么划分职能的，PHP 前端工程师，Python 前端工程师，JavaScript 前端工程师们？我说的对么？另外说一句，我是非常反对 ngrx 的，都用 rx 了，本身的 scan 方法不用，分发出一大堆 replaySubject 干嘛？

## spa

但是 web 中，一次页面刷新意味着资源重置，延迟非常大（缓存策略又会导致更新不及时），请求数据量的增多也会对服务器造成负担。

为了解决这些问题，web 才引入了单页面，防止刷新资源引起的网络和 js 重复编译的延迟，并增强了用户体验。

回忆一下大学的数据库课程，老师在讲解原子事物的时候，提到过事务的特性：操作要么全部成功，要么全部失败回滚——原子性必须使数据从一个一致性状态变换到另一个一致性状态——一致性（把一致换成有序比较好理解）对一项数据的操作不能被其他操作干扰——隔离性一旦操作完成，在没有后续操作的情况下，数据不可更改——持续性

如果是“静态页面”，那么每一次操作之后的页面都是完全不同的页面，其中的数据都是完完全全由后端逻辑和数据库决定的，用户的操作满足事务的特性。但是如果是 SPA？就要用到状态管理和本次存储了。这也是为什么 flux 的 store，redux 实现时要细分，vuex 的 mutation 必须同步（隔离性），angular 建议在服务中处理数据，并为每一个服务数据使用可观察对象订阅的方式展现（一致性）。你必须保证你的每一次数据更改，都必须满足事务的全部特性，三大框架所提供的不同方案，不管是 react 的 state，vue 的 defineObjectProperties 还是 Angular 的 zone 事件代理，以及 Rx，Redux，Vuex，包括浏览器的特性 service worker，localstorage， webSQL，IndexedDB 全都是为保证这些特性服务的。所以，当资源大小已经使你不得不采用 SPA 的时候，当用户的网络延迟已经使你不得不采用 SPA 的时候，才是 SPA 出马的时候。比如银行系统数以千万记的一次请求，比如企业 CMS 的增加效率，使得操作零延迟，比如复杂的功能实现，步骤繁琐到使用“静态页面”用户使用体验会极差。如果不是上诉情况，根本没有使用 SPA 的必要。所以你不能说单页面是 Web 的趋势，只能说是一个细分领域而已。我倒认为 SPA 恰恰不是趋势！在 5G 网络和 WASM 普及的未来，SPA 的存在是否有必要？很多时候我们并不是在追逐 SPA，而是追逐组件化工程化的大前端之路，这些和 SPA 其实关系并不大。“静态页面”也可以和工程化，构建工具紧密结合。

## 组件

首先，组件也是节点啊，事件是针对节点的，所以你的问题是子节点或者子节点的子节点都需要触发事件对么？如果是这样你的逻辑需要修改一下，有两种可能的方向：1. 判断事件的来源包含所有子组件的节点；2. 利用 eventPhrase 判断，子组件中过滤出‘AT_TARGET’。组件也是节点，也就是说 shadowDOM 也是节点，原生的事件机制同样起作用，Webkit-blink 系是先捕获再冒泡，IE-chakra 系是只有冒泡。

道理上来说服务器端技术你最多浅尝则之，根本负担不起上了一点体量的产品。

## 工程化

作者：江湖术士
链接：https://www.zhihu.com/question/274940977/answer/382073376
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

但是这个世界并没有那么简单，首先当头棒喝的就是——1. 目前的中国互联网，技术在产品中的占比非常非常的低！尤其是前端！不得不承认，目前中国的互联网市场还处在激烈竞争的阶段，新产品新形态层出不穷，而前端离用户最近，受其影响最深。产品可以容忍数据段进行长时间的研发优化，但决不允许应用端太过拖沓，因为在互联网的红海之中（尤其是中国互联网市场野蛮生长的情况下），拖延意味着死亡！实现功能优先，技术选型靠边！2.前端领域极其缺乏研究氛围，绝大多数公司对于前端岗位没有有效的评价体系！相信大家周围都有这样的故事，BAT 的员工，985，211 的毕业生不管实力如何，都会受到 HR 的优待，尤其是今年，BAT 为相当一部分刚毕业的 985 大学生开出 30 万以上的高薪。别觉得不公平，这是企业的一种避险行为，由于没有完整的能力评价体系（我不是针对谁，任何公司都没有，别觉得 BAT 就例外），公司只能依靠看得见的数值和标准去框定人员，当然也会被少数人钻了空子。这也不能怪企业，人均产出那么低，企业也拿不出钱来投进员工发展这一无底洞。对于已经工作的人员来说，评价体系就变成你的产出，看得见的能用数字框定的产出。而对于刷数据这种事情，你觉得是用 less+bootstrap 做一大堆静态页面来得快，还是连数据处理，请求代理都拿过来的 SPA 来得快？绝大多数公司会认为你这种半年只能做一个网站的菜鸟实力平平。3.用户体会不到差异一线的用户怎么看待杰出前端工程师的作品呢？答案是，和普通页面没有区别。你幸幸苦苦做的 SPA（两周工时），和普通后台托管的静态页面（半天工时），对于用户来说真的没什么大的区别，页面跳转还保证了数据一致性，你还不需要进行状态管理。现在连普及 Vue 和 React 的时机都还没到，绝大多数的 Vue 都是运用在增强交互上。普通用户体会不到技术的迭代，缺乏必要的鉴赏能力。别嘲笑用户，你能区分 C 画幅和全画幅么？你能区分静电发声单元和平板振膜发声单元么？不能，说实话，你也是会被 SOC 核心数，手机相机像素数，耳机低音炮，相机是不是佳能带跑偏的普通用户而已，你体会不到别人的努力，你也别指望你的先进技术能够被用户感受到。4.效率问题就我亲身经历来说，17 年年初在 Angular 刚发布的时候，我在一家上市公司与团队（5 人）利用 Angular 技术栈研发一款电子签名办公自动化的 web App。尽管加班异常厉害，身体都差点垮掉，但是还是用了将近 4 个月才上线，上线之后产品的反馈也不经如人意。离职之后在一家创业公司实习，利用 Vue 仅仅两个星期（2 人团队，后端 tornado），就完成了一个短视频工会管理系统，运行良好。当然也是因为有了 Angular 的开发经验，Vue 用起来就跟玩儿一样有关系。不过这个效率差异也大得让人深思啊。5.人生规划在市场还在普及 SPA 的时候，Angular 的方案显得太过遥远，不接地气。另外最重要的一点，Angular 的目标是为了把人的作用降低（换言之就是将程序员的价值变低），辛辛苦苦学习 Angular，换来一个光荣的“螺丝钉”头衔，会不会太不划算了？如果你自私的话，你应该反对工程化才对，如果整个系统离了你就运行不了，老板才会肯和你分钱，不是么？从技术角度来说工程化当然是理想国，不过我还是认为程序员不应该站在老板的角度思考问题，别人只是把你当工具而已。

## 时间循环

问：如果没有 WebApi 的话会有事件循环么？

答：存粹的单线程不可能有异步，因为线程会阻塞，因此只能实现 while 语句不能实现事件循环
为了在单线程执行的代码中处理多线程甚至多进程的状态变更，事件循环应运而生
跟你 JS 代码都不是一个线程甚至不是一个进程的，WebAPI 当然都是异步的咯。

https://developer.mozilla.org/zh-CN/docs/Web/API

说来也是奇怪，由于最开始 JavaScript 是面向非编程人员设计的语言，设计者不希望编程人员触碰底层实现，因此才将 JavaScript 单线程化（其他的功能全部以 WebApi 的形式提供）但是大家却意外发现以单线程 ev（事件循环）的方式调用多线程或多进程 api 可以有效地解决网络高延迟导致 io 挂起的问题。JavaScript 一下子从前端设计师专用工具变成了标准的后端编程语言。但是，由于语言本身的单线程特性，JavaScript 无论在前端还是在后端，都无法仅仅依靠自身实现异步（大家将这种异步方式叫做协程异步，是不是字面意思？lua 大神切勿喷人，我知道 lua 是中断执行的真协程，这个是加上监听器的假协程）不过 JavaScript 工程师应该感到自豪，编程的一个重要思想就是不要重复造轮子，所以这些 API 什么的，压根就不应该由我们自己来写（你们面试 JS 的时候 C++被问懵逼了可别来找我，我只是说这是趋势，不是说真能这么干）好吧，最后总结一下，webapi 你去看 MDN 吧，非常多，另外清楚一点，只要是前端中出现的异步，统统都是 webapi。
document.querySelector 是 webapi，可他不是异步的呀。
部分 webapi
当然也是 webapi，mdn 的 webapi 里面有，Worker 是让 web 应用有多线程能力，而不是让 JavaScript 有多线程能力，注意区分。

## react 不变性

https://www.zhihu.com/question/47171917/answer/487020087

让引用对象可判等，到底有多少种方法？proxy，深浅复制，序列化，id 判定，最短路径变更（immutable），根变更甚至还有更加无聊的，直接抛弃数据驱动，用事件驱动模型（ng zone 请你站起来）那么多办法，各位为何紧咬着 immutability 不放呢？虽然我也喜欢 immutability，但是喜欢不代表它就是放诸四海皆准的真理，就算函数式代表数据思维自顶向下演绎逻辑，但是硬件实现可还是图灵，不是邱奇，现实一点吧，朋友们

前端怎么上手 node + mongo？
江湖术士
江湖术士
DAYZ is coming
请不要下载，mongo 官方网站，注册 altas，选个顺眼的，按照提示一路撸下来。

## 业务分包

作者：江湖术士
链接：https://www.zhihu.com/question/410876268/answer/1371798256
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Vue.component('async-example', function (resolve, reject) {
setTimeout(function () {
// 向 `resolve` 回调传递组件定义
resolve({
template: '<div>I am async!</div>'
})
}, 1000)
})
首先看看充分条件，组件都能按需加载，这个应该没有疑问。其次，vue-router 只是官方出品的工具，没有 vue-router，你自己实现路由也可以的。然后看必要条件，是不是只有路由的使用场景会用到按需加载呢？显然不是，分包是个权衡的过程，如果你的应用恰好是每个路由页面把资源划分成相似大小，那是可以基于路由来做分包的。但是如果你一个页面的资源就非常臃肿，页面内做分包也是合理的。资源，依赖，数据，最好还是按照业务逻辑划分，再来实现按需加载比较好。因为“按需加载”加载的“需”，是“需求”的“需”，业务才是评判的准绳。应该按照业务将应用划分成一个个的 module，每个 module 有相对独立的状态，依赖，并且能灵活地进行组装，这种概念其实和后端的微服务相似，在大型应用中开发中非常适合。当然，你还是需要判断你的应用，如果应用本身很轻，按需加载其实是完全没有必要的。

## jsx 相比模板有什么优点？

优点：方便，两种代码可以在一起混写，不用考虑不同文件类型如何组织的问题可以将逻辑和视图交织写在一起，遇到列表，嵌套结构等逻辑视图时，思维负担比模板更小缺点：两种不同体系的语言元素写在一起，会显著降低可读性短时间内不可能成为规范 JSX 是一个牺牲可读性，增强视图可编程性和编程效率的工具，灵活是优点，但并非没有代价另外提一句，所谓对 ts 支持更好，对代码提示和类星提示支持更好的，全是伪命题，并不符合实际情况

作者：江湖术士
链接：https://www.zhihu.com/question/411745998/answer/1381041093
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Vue 一如既往地简单，充分说明扣掉不变性的 React 是真的好用

如何评价鲁迅的「猛兽总是独行，牛羊才成群结队」？
江湖术士
江湖术士
DAYZ is coming
2 人赞同了该回答
独行，并且死掉一大半，剩下的就是猛兽

结队，大概率好生活着，然后堕落成牛羊

怕死就别学猛兽了

你会发现，根本就没有业务逻辑存在的地方~（只有个 JSX 渲染逻辑，vm -> view 层）

是的，React 16.8 - 就是 View

服务提供商+依赖注入这是普遍被大众接受的概念，命名非常严谨这是 SOA 接入分层架构的普遍做法，所以命名也保持一致，有助于快速理解其实现原理对象的用法，你可能看不清具体发生了什么，但是 setup 里面，很方便看出来 function UperSetup(){
provide('token', data)
}

function SubSetup(){
const data = inject('token')
}
UperSetup 先于 SubSetup 运行，对象（SubSetup data）在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中

作者：江湖术士
链接：https://www.zhihu.com/question/480363422/answer/2068117319
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
