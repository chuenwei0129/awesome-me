# 一个真正高级的 JS 技巧：惰性函数，让分支判断只发生一次

我们写业务代码的时候，经常会掉进一个坑：
**明明某个条件在整个页面生命周期里都不会变，却每一次调用都在重复判断。**

比如：

- 浏览器到底支不支持某个 API？
- 当前用户是不是 VIP？
- 当前运行环境是浏览器还是 Node？

这些信息，一般在当前页面生命周期内是稳定不变的。
但我们常常习惯性地：

```js
function doSomething() {
  if (xxx) {
    // 分支 A
  } else {
    // 分支 B
  }
}
```

然后这个判断就会在函数的每一次调用中重复执行。

今天要聊的就是一个很“高级但好用”的小技巧：**惰性函数（Lazy Function Definition）**。
它的核心思路是：

> 把“函数到底该怎么实现”的决定，延迟到第一次执行时再做；
> 做完决定后，把这个函数改写成一个**固定版本**，以后再也不做分支判断。

---

## 先看一个实际需求：复制文本

假设我们有一个“复制文本到剪贴板”的需求，直觉上可以这么写：

```js
function copyText(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    // 支持新 API
    return navigator.clipboard.writeText(text);
  } else {
    // 不支持，走老方案
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();
    const ok = document.execCommand('copy');
    document.body.removeChild(textarea);
    return ok;
  }
}
```

这段代码功能上没有问题，但是存在两个问题：

1. **每次复制都要判断一次浏览器能力**
   - “支不支持 `navigator.clipboard.writeText`”这件事，本质上在本次页面生命周期里是不会变的。
2. **这段判断逻辑会一直污染主调用路径**
   - 实际上，我们只需要在“第一次复制”时搞清楚能力，然后选定一个实现即可。

那能不能做到：

- 第一次调用 `copyText` 的时候：做能力判断，选定一个分支；
- 从第二次开始：直接走这个分支，不再做任任何判断。

这就是惰性函数的用武之地。

---

## 什么是“惰性函数”？一句话定义

> 惰性函数（Lazy Function Definition）就是：
> **第一次执行时才决定“自己到底是哪种实现”，并把自己改写成该实现，后续调用不再做分支判断的函数。**

具体来说：

- 页面刚加载时，这个函数是“带分支逻辑”的版本；
- 第一次调用时，根据条件选定某个实现，并把这个函数变量指向新的实现；
- 之后再调用它，就是一个**没有分支判断的纯版本**。

听起来有点抽象，我们直接用上面的复制需求改写一遍。

---

## 实战：惰性函数版 `copyText`

下面是一个典型的惰性函数写法：

```js
function copyText(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    // 支持新 API：把 copyText 改写成“只用新 API”的版本
    copyText = function (text) {
      return navigator.clipboard.writeText(text);
    };
  } else {
    // 不支持：改写成“只用老方案”的版本
    copyText = function (text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      const ok = document.execCommand('copy');
      document.body.removeChild(textarea);
      return ok;
    };
  }

  // 别忘了：第一次调用时也要真正执行一遍
  return copyText(text);
}
```

这个页面在**刚加载**时：

- `copyText` 还是原来的“带 `if` 判断”的版本；
- 它只是一个函数声明，暂时什么也没做。

当你第一次调用：

```js
copyText('你好，惰性函数');
```

执行流程是这样的：

1. **第一次调用，进入有分支的版本**
   - 判断浏览器是否支持 `navigator.clipboard.writeText`。
2. **根据能力，重写 `copyText` 本身**
   - 支持：`copyText = function (text) { return navigator.clipboard.writeText(text); };`
   - 不支持：`copyText = function (text) { ... execCommand 方案 ... };`
3. **立刻调用新的版本执行一次**
   - `return copyText(text);`

从第二次开始：

```js
copyText('再来一次复制');
```

这个 `copyText` 已经不再是最初的那段“带 if 的函数”了，而是“只包含一个分支”的具体实现：

- 要么永远用 `navigator.clipboard.writeText`；
- 要么永远用 `execCommand` 的兼容方案。

于是：

- 判断逻辑只发生了**一次**；
- 主调用链上的代码变得更干净、也略微更高效。

---

## 再来一个偏业务的例子：VIP 用户逻辑

再举一个更贴近业务的例子。

假设后端在 SSR 时就把当前用户是不是 VIP 写到页面里：

```html
<script>
  window.__IS_VIP__ = true; // 或 false
</script>
```

我们现在有这个需求：

- 如果是 VIP，点击按钮就直接复制内容；
- 如果不是 VIP，点击按钮先弹付费对话框。

朴素版本大概是这样：

```js
function copyOrPay(text) {
  if (window.__IS_VIP__) {
    return copyText(text);
  } else {
    showPayDialog();
    return false;
  }
}
```

这在功能上也没问题，但如果你能确定：

- 本页面里用户的 VIP 状态**不会在不刷新页面的情况下改变**（比如付费后会整页刷新）；

那你完全可以用惰性函数，把这个判断只做一次。

惰性函数版：

```js
let isVip = window.__IS_VIP__;

function copyOrPay(text) {
  if (isVip) {
    // 改写成“只负责复制”的版本
    copyOrPay = function (text) {
      return copyText(text);
    };
  } else {
    // 改写成“只负责弹付费”的版本
    copyOrPay = function (text) {
      showPayDialog();
      return false;
    };
  }

  return copyOrPay(text);
}
```

第一次调用时：

- 如果 `isVip === true`，就把 `copyOrPay` 固定成“只复制”的实现；
- 否则就固定成“只弹付费”的实现。

之后你在这个页面再怎么调用 `copyOrPay`，**都不会再去做 if 判断**了。

---

## 惰性函数适合解决什么问题？

惰性函数的核心价值就是一句话：

> **把“只需要做一次的判断/初始化”，从高频调用路径里移出去。**

换句话说：

- 对于那些**条件在页面生命周期内稳定不变**的逻辑；
- 对于那些**初始化开销很大**、但后续复用成本极低的资源；

惰性函数是一个非常自然、优雅的优化工具。

典型适用场景包括：

1. **环境/能力检测**

   - 判断是否支持某个浏览器 API，再决定用哪个实现：
     - `IntersectionObserver` vs `scroll` 监听；
     - `ResizeObserver` vs `window.onresize`；
     - 是否支持某种 WebGL/Canvas 能力，等等。

2. **昂贵的初始化**

   - 初始化一个很重的对象或 SDK：
     - 首次用到某个第三方 SDK 时才去加载脚本、创建实例；
     - 初始化大型图表库，把“第一次初始化”的开销从全局中剥离出来。
   - 典型模式是：
     ```js
     function doSomething() {
       // 第一次调用时执行昂贵初始化，并重写函数
       doSomething = function () {
         // 后续直接复用
       };
       return doSomething();
     }
     ```

3. **兼容层封装**
   - 为旧浏览器提供降级方案，并希望在每个环境里都只选定一次分支。

---

## 什么时候不应该用惰性函数？

惰性函数并不是一个“随便用都香”的技巧，用错了反而会挖坑给自己。

几点需要特别注意：

### 1. 条件必须“基本不变”

惰性函数的前提是：

> **驱动分支的条件，在当前页面生命周期内是稳定的。**

比如：

- 浏览器是不是支持 `navigator.clipboard`：通常是稳定的；
- 当前运行环境是 Node 还是浏览器：稳定的；
- 某个后端能力是否存在：对单次请求来说通常稳定。

但有些条件是明显**会变**的，比如：

- 用户是否登录；
- 用户是否 VIP（在 SPA 中，可能随时升级而不刷新页面）；
- 当前主题：黑暗模式 / 亮色模式。

如果这些条件会在不刷新页面的前提下频繁变化，那么惰性函数会把你第一次的判断结果**锁死**，后续就算状态变了，逻辑也不会跟着变。这种场景就不应该用惰性函数。

### 2. 不要为了“炫技”牺牲可读性

对很多逻辑来说，一次 `if` 判断对性能的影响基本可以忽略不计。

相比之下，惰性函数带来的：

- 函数自我改写；
- 状态在函数体里变来的变去；

对阅读者的理解成本更高。

所以：

- 如果性能要求没那么苛刻、判断也很便宜，**简单直白的 if/else 更合适**；
- 惰性函数适合用在“瓶颈代码”、“基础库/工具函数”等对性能非常敏感的地方。

### 3. 注意调试和测试

惰性函数有一个特点：

- **第一次调用和后续调用，执行的是两份不同的代码。**

这会带来一个测试上的要求：

- 需要分别测试：
  - 第一次调用时的行为（含重写逻辑）；
  - 重写之后的版本是否符合预期。

在调试时也要注意：

- 打断点的时候要搞清楚：
  你现在打的是“第一次执行”版本，还是“重写后”的版本。

---

## 惰性函数的“工厂”写法（进阶）

上面的例子都是“手写惰性函数”，有时候你会发现这个模式用得比较多，可以抽象一个简单的“惰性工厂”。

例如：

```js
function createLazy(fn) {
  let realFn = null;
  return function (...args) {
    if (!realFn) {
      // 第一次真正创建“真实实现”
      realFn = fn();
    }
    return realFn(...args);
  };
}
```

用法举例：

```js
// 比如初始化一个很重的对象
function initVeryExpensiveStuff() {
  console.log('初始化一个非常昂贵的对象...');
  const instance = {
    run(x) {
      console.log('运行：', x);
    },
  };
  return instance;
}

// 创建一个惰性函数
const doSomething = createLazy(() => {
  const expensive = initVeryExpensiveStuff();
  return (x) => expensive.run(x);
});

// 第一次调用时才会真正初始化
doSomething('第一次调用'); // 会看到“初始化...”日志
doSomething('第二次调用'); // 不会再初始化
```

这个模式本质上就是：

- 用一个闭包变量 `realFn` 存储真实实现；
- 第一次调用延迟初始化；
- 后续调用直接复用。

它和“在函数体内重写自己”是同一个思想，只是写法不同，各有取舍。

---

## 总结：高级感不在写法，而在思路

惰性函数本身的代码并不复杂，几行就能写出来。真正体现“高级”的，是背后的思考方式：

- 这个条件是**每次都要重新判断**，还是**仅需要判断一次**？
- 这段初始化是**必须一上来就做**，还是**第一次真正用到时再做**？
- 我能不能把“只需要做一次的工作”从高频调用路径上剥离出去？

当你开始自然地想到这些问题，并用惰性函数、懒加载等技巧来优化代码时，你写的就不再只是“能跑”的代码，而是**既对业务负责，又对性能和架构负责的代码**。

惰性函数不是银弹，也不是必须用的花活，但在合适的场景里，它绝对是一个非常值得加入工具箱的高级技巧。

如果你有某段代码总是在做“重复但稳定的判断”，不妨试着用惰性函数重构一次，感受一下那种“第一次选定分支，后面就一路畅通”的畅快感。
