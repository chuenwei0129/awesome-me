---
title: TCP 篇
order: 3
toc: content
group:
  title: 基础知识
---

## 什么是 TCP？

TCP，即传输控制协议，是一种**面向连接的、可靠的、基于字节流的传输层通信协议**，广泛应用于互联网数据传输。其主要特点包括：

- **面向连接**：TCP 协议确保通信双方建立稳定的连接，实现一对一的数据传输。不同于 UDP 协议，TCP 不支持同时向多个接收方发送数据，即不支持一对多通信。
- **可靠性**：TCP 通过各种机制保证数据包在各种网络条件下都能可靠到达接收端。
- **字节流服务**：在 TCP 协议中，数据被视为一连串的字节流。数据在传输过程中可能被分割成多个 TCP 数据包，接收端需要根据 TCP 数据包的顺序正确组装数据，并处理重复或乱序的数据包。

## 什么是连接？

简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。

- **Socket**：由 IP 地址和端口号构成，是网络通信的端点。
- **序列号**：用于解决数据包乱序问题。
- **窗口大小**：用于流量控制，控制发送方的数据传输速率。

## TCP 是面向字节流的协议，UDP 是面向报文的协议？

### 为什么 UDP 是面向报文的协议？

UDP (用户数据报协议) 是一个简单的网络通信协议，它之所以被描述为面向报文的协议，主要是因为它在传输数据时保持了数据的边界。**这意味着当应用层向 UDP 层发送一个消息时，该消息会被封装在一个 UDP 数据报中并直接发送，而不会被拆分或合并。**

#### UDP 的工作方式

- **不分割消息**：在通过 UDP 发送数据时，操作系统将用户的消息作为一个整体处理，不会将其分割成多个部分。消息在添加了 UDP 头部信息后，整体交给网络层处理，保证了数据报中的数据部分正好是完整的用户消息。
- **消息边界保持**：因此，每个 UDP 数据报的界限就自然成了一个用户消息的界限。这就是为什么我们说 UDP 是面向报文的：它保留了消息的完整性和边界。

#### 接收 UDP 报文

- **报文的独立接收**：当接收方收到 UDP 报文时，每个报文都被独立地处理和传递给应用层。如果有多个 UDP 报文到达，操作系统会将它们依次放入一个队列中。
- **按报文读取**：应用程序通过调用 `recvfrom()` 等系统调用来读取数据，每次调用通常会从队列中取出一个完整的 UDP 报文，并将其内容复制到用户指定的缓冲区中。这保证了应用层每次读取的都是一个完整的、未经拆分的用户消息。

### 为什么 TCP 是面向字节流的协议？

TCP (传输控制协议) 是一种面向连接的、可靠的、面向字节流的通信协议。它的面向字节流特性主要体现在如何处理和传输数据。

#### 字节流的含义

- **分组传输**：TCP 将长消息切分为较小的数据包进行传输，而不是一次性发送整个消息。这意味着大的用户消息可能会被拆分成多个 TCP 报文段 (数据包) 进行发送。
- **无边界保留**：与面向报文的 UDP 不同，TCP 传输的数据是连续的字节流，没有固定的边界。因此，接收方无法仅从 TCP 报文本身区分出原始的消息边界。

#### TCP 传输示例

让我们以发送 “Hi。” 和 “I am Xiaolin” 这两个消息为例，说明 TCP 的这一特性。

- **发送端**：发送方在调用 `send` 函数时，数据首先被复制到操作系统内核的协议栈中。实际发送时间取决于多种因素，如发送窗口大小和网络拥塞控制机制。
- **接收端**：由于 TCP 是面向字节流的，接收方可能以任何分割接收到这些数据。例如，两个消息可能合并为一个 TCP 报文发送，或者一个消息被拆分成多个报文发送。

第一种情况，这两个消息被分到同一个 TCP 报文，像这样：

![20240415011742](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415011742.png)

第二种情况，“I am Xiaolin” 的部分随 “Hi” 在一个 TCP 报文中发送出去，像这样：

![20240415011811](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415011811.png)

第三种情况，“Hi。” 的一部分随 TCP 报文被发送出去，另一部分和 “I am Xiaolin” 一起随另一个 TCP 报文发送出去，像这样。

![20240415011834](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415011834.png)

类似的情况还能举例很多种，这里主要是想说明，我们不知道 “Hi。” 和 “I am Xiaolin” 这两个用户消息是如何进行 TCP 分组传输的。

#### TCP 粘包问题

- **粘包现象**：**当多个消息在传输过程中合并成一个 TCP 报文，或一个消息被分割成多个报文时，接收方在没有额外信息的情况下难以确定消息的界限**。这就是所谓的 TCP 粘包问题。
- **应对策略**：为了解决粘包问题，应用层协议可能需要引入特定的消息边界标识，如长度前缀、特殊分隔符等。

## 三次握手

### 三次握手过程

TCP，作为一种面向连接的协议，要求在数据传输前先建立可靠的连接。这一过程通过一个被称为 “三次握手” 的机制完成，旨在初始化双方的 Socket、序列号和窗口大小。以下是三次握手的具体步骤：

- **开始阶段**：最初，客户端和服务端都处于 CLOSE 状态。服务端开始监听某个端口，进入 LISTEN 状态，准备接受连接请求。

  ![20240415160306](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415160306.png)

- **第一次握手**：客户端生成一个随机的初始序列号 (client_isn)，并发送一个 SYN 报文给服务端。这个报文的 SYN 标志位设为 1，且不携带应用层数据。发送后，客户端进入 SYN-SENT 状态。

  ![20240415160438](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415160438.png)

- **第二次握手**：服务端接收到 SYN 报文后，也生成一个随机的初始序列号 (server_isn)，并将确认应答号设置为 client_isn+1。服务端同时设置 SYN 和 ACK 标志位为 1，然后将此报文发送给客户端，进入 SYN-RCVD 状态。

  ![20240415160546](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415160546.png)

- **第三次握手**：客户端收到服务端的报文后，向服务端发送一个 ACK 报文，其确认应答号设为 server_isn+1。这次报文可以携带数据，发送后客户端进入 ESTABLISHED 状态。

  ![20240415160657](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415160657.png)

- **连接建立完成**：服务端接收到客户端的 ACK 报文后，也进入 ESTABLISHED 状态，至此，TCP 连接建立完成，双方可以开始数据传输。

### 为什么是三次握手？不是两次、四次？

三次握手的设计旨在确保连接的可靠性和序列号的同步，同时防止资源浪费。以下是详细解释：

1. **防止历史连接的初始化**：三次握手可以确保不会错误地初始化已过期的连接请求，避免服务端因历史连接而浪费资源。

   如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，**妥妥地浪费了服务端的资源**。

   ![20240415161536](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415161536.png)

   因此，要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。

   ![20240415161159](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415161159.png)

   所以，TCP 使用三次握手建立连接的最主要原因是防止 “历史连接” 初始化了连接。

2. **同步双方的初始序列号**：序列号是 TCP 协议中保证数据可靠传输的关键。三次握手确保了双方的初始序列号都能被对方确认接收，从而同步。

   TCP 协议的通信双方，都必须维护一个 “序列号”，序列号是可靠传输的一个关键因素，它的作用：

   - **接收方可以去除重复的数据**；
   - **接收方可以根据数据包的序列号按序接收**；
   - **可以标识发送出去的数据包中，哪些是已经被对方收到的** (通过 ACK 报文中的序列号知道)

   序列号在 TCP 连接中占据着非常重要的作用，所以**当客户端发送携带 “初始序列号” 的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送 “初始序列号” 给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。**

   ![20240415161928](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415161928.png)

   两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。
   四次握手则因为第二步和第三步可以合并为一步，实际上是冗余的。

3. **避免资源浪费**：三次握手机制还能防止因网络延迟导致的 SYN 报文重复发送问题。如果没有第三次确认，**服务端可能会为每个重复的 SYN 报文建立新的连接，造成资源的无谓浪费**。

   ![20240415162039](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415162039.png)

### 为什么第三次握手可以携带数据，而前两次不行？

TCP (传输控制协议) 的三次握手过程是建立可靠连接的关键步骤，确保双方都准备好进行数据传输。这个过程涉及三个步骤：SYN (同步序列编号)、SYN-ACK (同步和确认)、ACK (确认)。理解为什么第三次握手可以携带数据，而前两次不行，需要深入了解 TCP 的工作原理和设计目的。

#### 第一次握手 (SYN)

客户端发送一个 SYN (同步序列编号) 报文到服务器。在这个阶段，客户端试图建立连接，指示它想要开始通信，并提供一个初始序列号 (ISN)，以便同步序列号。这个序列号用于后续数据传输的字节流排序。在这个阶段，不传输应用层数据是因为连接还没有建立，双方还没有同步彼此的初始序列号，因此任何传输的数据都可能无法被正确地排序或确认。

#### 第二次握手 (SYN-ACK)

服务器接收到 SYN 报文后，回应一个 SYN-ACK 报文。这个报文确认 (ACK) 了客户端的 SYN 报文，并且也包含服务器自己的同步序列号，为服务器到客户端的数据传输做准备。在这个阶段，尽管服务器已经准备好发送数据，但它仍然不发送应用层数据。这是因为服务器还没有接收到客户端对自己序列号的确认，所以它不能确定客户端已经准备好接收数据。

#### 第三次握手 (ACK)

客户端收到 SYN-ACK 报文后，发送一个 ACK 报文作为响应，确认收到了服务器的序列号。从这一点开始，连接被认为是建立的，双方都确认了对方的初始序列号。在这个阶段，客户端可以开始携带数据发送 ACK 报文，因为此时连接已经建立，双方都同步了彼此的序列号，可以确保数据的正确排序和确认。

#### 为什么第三次握手可以携带数据

- **连接已建立**：在第三次握手后，双方都确认了彼此的初始序列号，连接被认为是建立的。这意味着双方都准备好接收数据，能够正确地排序和确认接收到的数据包。
- **效率**：允许第三次握手携带数据可以提高协议的效率。如果等待握手完全完成后再发送数据，会增加一个 RTT (往返时间)，从而延迟数据传输的开始。
- **兼容性**：TCP 的设计允许灵活性和高效性。虽然在大多数情况下，第三次握手不携带数据也不会对性能产生显著影响，但在某些情况下，这种方法可以稍微提高效率。

综上所述，TCP 的三次握手过程是精心设计的，以确保连接的可靠性和数据传输的正确性。允许第三次握手携带数据是这一设计中的一个优化，使得在确认连接的同时就可以开始数据传输。

### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题。

![20240415165719](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415165719.png)

## 四次挥手

### 四次挥手过程

![20240415170316](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415170316.png)

### 为什么挥手需要四次？

关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。

服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，**而服务端可能还有数据需要处理和发送**，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，因此是需要四次挥手。

但是在特定情况下，四次挥手是可以变成三次挥手的。

### 什么情况会出现三次挥手？

当被动关闭方 (上图的服务端) 在 TCP 挥手过程中，**“没有数据要发送” 并且 “开启了 TCP 延迟确认机制”，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。**

![20240415170551](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415170551.png)

## TCP 重传、滑动窗口、流量控制、拥塞控制

### 重传机制

TCP 通过序列号和确认应答机制实现可靠传输。当 TCP 数据包成功到达接收方时，接收方会发送一个确认应答消息，表明数据已经被接收。

![20240415184704](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415184704.png)

TCP 会在以下情况下进行数据重传：

1. 数据包丢失。
2. 确认应答丢失。

![20240415184731](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415184731.png)

RTT (Round-Trip Time) 是指从发送数据包到收到确认应答的时间差，即数据包的往返时间。

![20240415185113](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415185113.png)

### 滑动窗口

传统的 TCP 通信模式要求每发送一个数据包就等待一个确认应答，这样的逐个确认方式虽然简单，但效率低下。

![20240415185434](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415185434.png)

这个模式就有点像我和你面对面聊天，你一句我一句。如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。

为了提高效率，TCP 引入了滑动窗口机制。窗口大小指的是可以连续发送但尚未收到确认的最大数据量。这允许发送方根据接收方的处理能力和网络条件灵活调整发送速率，提高通信效率。

窗口实质上是操作系统分配的缓存空间，用于存储已发送但未确认的数据。如果数据被确认，相应的缓存区域就会被清空，以便存放新的数据。

![20240415185527](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415185527.png)

TCP 头里有一个字段叫 Window，也就是窗口大小。

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

所以，通常窗口的大小是由接收方的窗口大小来决定的。

### 流量控制

发送方不能无脑的发数据给接收方，要考虑接收方处理能力。

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，**TCP 提供一种机制可以让 “发送方” 根据 “接收方” 的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

### 拥塞控制

> 为什么要有拥塞控制呀，不是有流量控制了吗？

前面的流量控制是避免 “发送方” 的数据填满 “接收方” 的缓存，但是并不知道网络的中发生了什么。

一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包。

**当网络出现拥塞时，TCP 会主动减少数据发送量，避免加剧网络拥堵**，这就是拥塞控制。拥塞控制通过维护一个 “拥塞窗口” 来调整发送方的数据发送量，以此确保网络的稳定和公平使用。

## TCP 协议有什么缺陷？

### 建立连接的延迟问题

TCP 协议，作为许多基于网络的应用的基石，如 HTTP 1.0/1.1、HTTP/2、HTTPS 等，要求在数据传输前完成一系列握手过程。特别是对于采用 HTTPS 的网站，数据传输前不仅要完成 TCP 的三次握手，还需进行 TLS 的四次握手，这无疑增加了数据传输的延迟。

值得一提的是，TLS 握手可以与 TCP 的三次握手同时进行，但这需要满足以下条件：

- 客户端和服务器都启用了 TCP Fast Open 功能，并且使用的是 TLS 1.3 版本；
- 客户端和服务器之间已有过一次成功的通信记录。

### 队头阻塞问题

作为一种字节流协议，TCP 需要确保接收到的数据既完整又有序。这意味着，如果较早序列号的数据包在传输过程中丢失，即便后续的数据包已经到达，应用层也无法读取这些数据，直到丢失的数据包被重新传输并接收。这种现象就是所谓的队头阻塞。

![20240415193743](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415193743.png)

HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求，所以 HTTP/2 队头阻塞问题就是因为 TCP 协议导致的。

### 网络迁移导致的重新连接

当使用基于 TCP 的协议 (如 HTTP) 时，TCP 连接是通过四元组 (源 IP、源端口、目标 IP、目标端口) 唯一确定的。因此，当移动设备从 4G 网络切换到 WIFI 网络时，IP 地址的变化迫使现有的 TCP 连接断开并重新建立，包括 TCP 三次握手和 TLS 四次握手的延迟，以及 TCP 慢启动过程，都会让用户感受到明显的网络卡顿。这种连接迁移的高成本是 TCP 协议的又一个局限性。

## 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

IP 层的分片 (Fragmentation) 和 TCP 层的最大报文段大小 (MSS，Maximum Segment Size) 都是网络通信中的重要概念，它们处理的问题虽然相似，但目的和应用场景有所不同。理解它们之间的关系，需要先了解每个概念的基本功能和设计目的。

### IP 层分片

IP 层分片是网络层面的一种机制，用于将数据包分割成更小的片段，以适应下一个跳点 (next hop) 的最大传输单元 (MTU，Maximum Transmission Unit)。不同的网络可能有不同的 MTU 限制，如果一个数据包的大小超过了这个限制，它就需要在传输前被分割成多个较小的片段。这个过程是在 IP 层完成的，对上层协议 (如 TCP 或 UDP) 是透明的。

### TCP 层的 MSS

MSS 是 TCP 层的一个概念，指的是 TCP 报文段中可以包含的最大数据量，不包括 TCP 头部。MSS 的主要目的是为了提高网络效率，避免 IP 层分片。在建立 TCP 连接时，双方会通过发送 SYN 报文交换各自的 MSS 值。这个值通常是根据连接两端的网络接口的 MTU 减去固定的 IP 头部和 TCP 头部的长度来确定的，以确保整个 TCP 报文段 (包括 TCP 头部和数据) 不会超过 MTU，从而避免在 IP 层进行分片。

### 为什么 TCP 层还需要 MSS？

尽管 IP 层可以处理分片，但过度依赖 IP 分片会带来几个问题：

1. **效率降低**：IP 层分片和重组需要消耗额外的处理资源，这会降低网络效率。如果每个分片都独立传输，丢失任何一个分片都会导致整个数据包需要重传，增加了网络负载和延迟。

2. **可靠性问题**：分片增加了数据在传输过程中丢失的风险。因为 IP 层不提供端到端的可靠性保证，如果任何一个分片丢失，整个原始数据包都需要重新发送。

3. **安全性考虑**：分片可能会影响安全设施的效能，比如入侵检测系统 (IDS) 和防火墙可能难以分析经过分片的数据包，因为它们需要重组完整的数据包才能进行有效的分析。

通过在 TCP 层使用 MSS 来限制数据段的大小，可以有效避免这些问题。设置 MSS 以适应最小的 MTU 可以确保数据包在整个传输路径上不需要被分片，从而提高了传输效率，降低了丢包率，同时也减少了安全风险。

总之，虽然 IP 层提供了分片机制以支持大数据包的传输，但 TCP 层的 MSS 设置是为了优化网络通信，减少对 IP 分片的依赖，从而提高整体的网络性能和可靠性。

## 有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？

TCP 四元组可以唯一的确定一个连接：

- 源地址和目的地址的字段 (32 位) 是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。
- 源端口和目的端口的字段 (16 位) 是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

![20240414180504](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240414180504.png)

服务端在特定端口上监听客户端的连接请求。理论上，对于 IPv4 地址空间，服务端的最大 TCP 连接数约为$2^{48}$，这个数字来源于：

- 客户端 IP 地址的可能性：$2^{32}$(IPv4 地址空间)
- 客户端端口的可能性：$2^{16}$(端口号范围)

然而，**实际上服务端能够处理的并发 TCP 连接数远低于理论值**，受到系统资源 (如文件描述符和内存) 限制。

## TCP 和 UDP 可以使用同一个端口吗？

在网络编程中，TCP 和 UDP 是两种不同的协议，**它们可以共享相同的端口号**，因为端口号是与协议绑定的，形成了一个唯一的地址。下面是使用 Node.js 编写的两个简单的服务端程序示例，一个使用 TCP，另一个使用 UDP，它们都绑定到端口号 8888 上。

## 多个 TCP 服务进程可以绑定同一个端口吗？

TCP 服务进程在启动时需绑定到一个特定的 IP 地址和端口上，以侦听来自客户端的连接请求。通常情况下，如果尝试将多个服务进程绑定到相同的 IP 地址和端口组合，系统会报错 “Address already in use”，防止绑定操作。

### 场景：服务重启与端口占用问题

在服务进程重启的场景中，经常遇到端口占用 (“Address in use”) 的问题。这通常是因为：

- 服务进程在关闭连接时启动了 TCP 的四次挥手过程，导致端口短暂进入 `TIME_WAIT` 状态，大约持续 2 倍的最大报文生存时间 (2MSL)。
- 如果在这个 `TIME_WAIT` 期间尝试重新启动服务并重新绑定到相同的 IP 和端口，会因为系统认为该 IP 和端口组合仍在使用中而失败。

### 解决方案：SO_REUSEADDR 选项

为了解决这一问题，可以在绑定地址前对 socket 使用 `SO_REUSEADDR` 选项。这个选项允许在 `TIME_WAIT` 状态的连接存在时，仍然可以绑定到同一端口。这样，即使端口暂时被标记为占用，服务进程也能成功重启并重新绑定到期望的端口。

## 客户端的端口可以重复使用吗？

**可以。**

客户端在与服务器建立 TCP 连接时，**操作系统通常会自动为其分配一个端口**，这个端口并没有特定的要求或限制，其选择范围通常是动态的。

那么，如果客户端已经使用端口 `7890` 与一个服务器建立了连接，是否能再次使用相同的端口 `7890` 与另一个服务器建立新的连接呢？

答案是肯定的。**TCP 连接的唯一性是由四元组 (源 IP 地址、源端口号、目标 IP 地址、目标端口号) 决定的**。这意味着，只要这四个元素中的任何一个不同，系统就会认为它们是两个独立的连接。因此，即使使用相同的客户端端口 `7890`，只要连接的服务器 IP 地址或服务器监听的端口不同，客户端就可以与多个服务器建立独立的连接，而不会发生冲突。

这种设计允许高效地复用端口，支持客户端与多个服务器之间的并发通信，而不必为每个新连接分配一个独立的端口。

## TCP 的 Keepalive 机制

TCP 的 Keepalive 机制，也称为 TCP 保活机制，是一种由操作系统内核实施的功能。它旨在通过定期发送探测报文来检测长时间无数据交换的 TCP 连接是否仍然有效。这个机制帮助确定连接两端的主机是否仍在线，从而决定是否维持或关闭该连接。

### 工作原理

- **正常响应**：如果连接的另一端 (对端程序) 正常运行，那么当发送了 TCP 保活探测报文后，对端将正常响应。这种情况下，TCP 保活计时器将被重置，系统将继续等待下一个保活时间点到来，以再次检测连接状态。
- **异常情况**：如果对端主机发生宕机 (区别于进程崩溃，因为进程崩溃时操作系统在回收进程资源时通常会发送 FIN 报文以关闭连接，而主机宕机则无法被直接感知)，或因其他原因导致报文不可达，那么发送的 TCP 保活探测报文将得不到任何响应。如果这种无响应状态连续发生数次，达到了设定的保活探测次数上限，TCP 将判断该连接已经不再有效，并将其关闭。

### 重要性

TCP 的 Keepalive 机制在维护长连接时尤为重要，尤其是在那些长时间保持连接但数据交换不频繁的应用场景中。它确保了即使在网络环境变化或对端主机状态改变的情况下，应用程序也能及时得知连接状态，从而作出相应的处理。

### 注意事项

- Keepalive 是可选功能，并非所有 TCP 连接默认启用。它通常需要通过配置操作系统或应用程序来启用。
- 保活机制的使用需要谨慎，因为不当的配置可能导致不必要的网络流量和资源消耗，尤其是在网络状况不佳或连接数众多的环境中。

## 拔掉网线后，原本的 TCP 连接还存在吗？

让我们探讨一个常见的疑问：当网线被拔出，我们的 TCP 连接是否依然存在？

直观上，人们可能会认为，既然物理连接已断开，那么建立在其上的 TCP 连接自然也应随之终止。这种想法类似于，当一方的有线电话线被拔掉时，通话无疑是被迫中断的。

然而，这种理解并不完全准确。

实际上，TCP 连接的存续与否并不直接受拔掉网线这一物理行为的影响。在 Linux 系统内，TCP 连接是通过名为 `struct socket` 的结构体表示的，其中包含了连接状态等关键信息。**拔掉网线并不会改变这个结构体的内容，因此，从操作系统的角度看，TCP 连接的状态并未因此而改变。**

客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。

**有数据传输时的情形：**

- **网线临时拔出**：如果在网线被拔出期间，服务端尝试发送数据，但在达到重传次数上限前客户端重新连接了网线，那么原有的 TCP 连接仍然有效，仿佛未发生任何中断。
- **网线长时间拔出**：反之，如果服务端的重传次数达到上限，客户端仍未恢复连接，则服务端会终止 TCP 连接。此时，即便客户端稍后恢复网络连接，由于服务端已关闭相应的连接，任何来自客户端的数据都将被拒绝，表现为接收到 RST 报文，导致客户端也关闭 TCP 连接。

**无数据传输时的情形：**

- **未启用 TCP keepalive**：若双方均未启用 TCP keepalive 机制，在网线拔出期间，若无数据传输尝试，TCP 连接状态理论上将保持不变，直至有外部操作改变此状态。
- **启用了 TCP keepalive**：若双方启用了 TCP keepalive 机制，则在网线拔出期间，该机制可能探测到连接的不活跃状态并最终关闭连接。但如果网线在探测周期内被重新连接，TCP 连接仍可保持活跃状态。

## TCP 连接，一端断电和进程崩溃有什么区别？

### 客户端的进程崩溃

当客户端的进程发生崩溃，操作系统的内核会介入处理，自动发起一个正常的连接终止过程。这包括向服务端发送一个 FIN 报文，启动所谓的 “四次挥手” 过程，以优雅地关闭 TCP 连接。这个过程确保了双方都明确连接已经终止，资源得以释放。

### 客户端断电 (宕机)

相对地，如果客户端主机突然断电或宕机，情况就大不相同了。由于客户端突然失去电力，它将无法发送任何报文，包括四次挥手中的 FIN 报文。这种情况下，TCP 连接的终止依赖于服务端的后续行为：

- **服务端尝试发送数据**：如果服务端在客户端宕机后尝试发送数据，它将因为收不到响应而开始重传。根据 TCP 协议的重传机制，服务端会在一定时间后 (取决于 `tcp_retries2` 内核参数设定的阈值) 放弃，并关闭连接。
- **服务端不发送数据**：如果服务端不主动发送数据，TCP 连接的命运则取决于是否启用了 TCP keepalive 机制：
  - **启用 TCP keepalive**：若服务端启用了该机制，在一段时间内没有数据交换时，它将自动探测对方主机是否仍在线。如果探测失败，表明对方主机不可达，服务端将关闭连接。
  - **未启用 TCP keepalive**：若未启用该机制，服务端可能长时间不知道客户端已经宕机，因此，TCP 连接会一直保持在 ESTABLISHED 状态，直到有外部因素介入。

## 什么是丢包？

### 数据包传输过程

数据包从发送到接收，经历一个复杂的旅程：开始于应用层，下探至物理层，再回升至应用层。这一过程涉及封装、传输、路由选择、解封装等多个步骤，其中缓冲区管理、中断处理、数据重组等环节对于确保数据的准确和高效传输至关重要。

![20240414164452](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240414164452.png)

网络中的丢包现象可发生在多个环节。

### 端内网络丢包原因

- **建立连接时的丢包**：TCP 连接队列容量有限，一旦满载，新到达的数据包将被抛弃。
- **流量控制导致的丢包**：若所有数据包不受控制地涌向网卡，超出其处理能力，系统将通过排队规则 (qdisc) 进行流量控制。当数据发送过快，且流控队列长度不足时，丢包现象随之发生。
- **网卡丢包**：网卡或其驱动问题，如网线质量不佳或接触不良，也会导致丢包。
- **接收缓冲区丢包**：当接收缓冲区满载，TCP 接收窗口将缩至零，此时若仍有数据包到达，将不得不丢弃这些数据包。

### 端间网络丢包原因

除了端内因素，数据包在传输过程中还需经过长距离的外部网络，包括各种路由器、交换机和光缆等设备，这些环节同样可能发生丢包。

### 应对丢包的策略

尽管丢包几乎不可避免，但 TCP 协议提供了一种有效的解决方案。通过等待接收端的确认响应 (ack 包)，并在未收到响应时重传数据，TCP 协议确保了数据包能够可靠地到达接收端。

### TCP 协议的局限性

虽然 TCP 协议在网络层面提供了可靠的数据传输保障，但其作用范围仅限于传输层。一旦数据包到达接收端的传输层，其后的处理 (如应用程序的数据解析和使用) 则超出了 TCP 的职责范围。因此，如果应用层处理出现问题 (如应用崩溃)，即便 TCP 确保了数据传输的可靠性，用户仍可能遇到数据丢失的情况。

![20240415012745](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240415012745.png)

例如，在即时通讯软件中，即使 TCP 确保消息成功传输至接收方的传输层，如果接收方应用程序在读取数据时发生崩溃，则该消息无法正常显示给用户，从用户角度看，这条消息就是 “丢失” 的。
