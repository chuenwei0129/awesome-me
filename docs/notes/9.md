# 【深度】用 JavaScript 直观理解 Continuation 与 CPS：从回调地狱到 React Fiber

在日常代码里，我们写的几乎都是**“直接风格”（Direct Style）**：函数返回结果，调用方拿到结果再继续做事。

**Continuation-Passing Style（CPS，续延传递风格）**则反过来：函数不返回结果，而是把“之后要做的事情”封装成一个函数（Continuation），由被调用者来主动调用它。

理解 Continuation = **“程序的未来”**。这不仅能帮你彻底看清 Promise、async/await 的本质，更是理解 **Koa 中间件原理** 和 **React Fiber 可中断渲染** 的一把钥匙。

---

## 0. 一句话版：CPS 是什么？

简单来讲，CPS 是一种**控制流显式化**的编程风格。

### 对比图解

```javascript
// ➤ 直接风格（Direct Style）
// 控制流由 JS 引擎的“调用栈”隐式管理
function foo(x) {
  return x + 1;
}

// ➤ CPS 风格
// 控制流由程序员通过 returnPoint 显式管理
function cpsFoo(x, returnPoint) {
  // 把结果传给“未来”
  returnPoint(x + 1);
}
```

**核心区别：**

1.  **参数多了一个 `returnPoint`**：它代表 caller 所在的“世界”，也就是“接下来要做的事”。
2.  **没有 `return` 值**：函数不通过栈返回数据，而是直接跳转到 `returnPoint`。

这就是 CPS 的初衷之一：**把层层嵌套的调用世界“摊平”**。这是一种典型的“Desugar（脱糖）”过程——编译器常将高级语法还原为这种结构规整的形式，以便于优化。

---

## 1. 基础实战：从求和看控制流反转

我们看一个稍微复杂点的例子：计算 `(a + b) * 2`。

### 直接风格

```javascript
function calc(a, b) {
  const sum = a + b;
  return sum * 2;
}

const result = calc(1, 2); // 隐式：返回值传回给这里
console.log(result); // 6
```

👉 **特征**：`calc` 执行完，弹出栈帧，控制权回到主程序。

### CPS 风格

在 CPS 里，我们不返回，而是把“后续步骤”传进去：

```javascript
// k (continuation) 是一个函数，代表：拿到结果后，未来要做什么
function calcCps(a, b, k) {
  const sum = a + b;
  const doubled = sum * 2;
  k(doubled); // 显式移交控制权
}

// 调用：
calcCps(1, 2, (result) => {
  console.log(result); // 这里就是“程序的未来”
});
```

👉 **特征**：`calcCps` 不返回，而是带着数据直接冲向未来（调用 `k`）。

---

## 2. Continuation 的本质：三态模型

如果不理解 Continuation，可以试着把程序的执行点切分为三段：

1.  **过去**：已经计算完的数据（上下文）。
2.  **现在**：正在执行的指令。
3.  **未来（Continuation）**：从现在开始，剩下要执行的所有代码。

在 JavaScript 中，函数 + 闭包 天然就是模拟 Continuation 的利器。一旦“未来”变成了参数，它就成了一等公民：**可以被保存、被修改、被忽略，甚至被调度。**

---

## 3. 高级能力解锁

### 3.1 暂停与恢复（Time Slicing 的雏形）

既然“未来”只是一个函数，那我可以选择**现在不调用它**，把它存起来，等浏览器空闲了再调用。

```javascript
let savedContinuation = null;

function pauseableAdd(a, b, k) {
  // 冻结未来：不立即执行 k，而是存起来
  savedContinuation = () => k(a + b);
}

// 触发计算
pauseableAdd(1, 2, (res) => console.log('结果:', res));

console.log('计算暂停中...');

// ... 模拟：过了一会儿，用户点击了“继续”按钮
setTimeout(() => {
  if (savedContinuation) {
    console.log('恢复执行');
    savedContinuation();
  }
}, 1000);
```

**🔥 业界应用：React Fiber**
React 16+ 的 Fiber 架构本质上就是手动实现了类似 Continuation 的效果。
旧版 React 递归渲染一旦开始就无法停止（Direct Style）。Fiber 将渲染任务拆分成链表节点（Fiber Node），每个节点执行完后，React 都会检查“现在还有时间吗？”。

- 有时间 -> 调用下一个节点的 Continuation。
- 没时间 -> **暂停**（保存当前节点指针），让出主线程给浏览器绘制，下一帧再**恢复**。

### 3.2 拦截与增强（中间件/AOP）

我们可以像“套娃”一样包装 Continuation，在它执行前后插入逻辑。这正是 **Redux Middleware** 和 **Koa** 的核心原理。

```javascript
// 一个日志中间件工厂
function withLogging(nextContinuation) {
  return (result) => {
    console.log('📋 Log: 准备处理结果', result);
    nextContinuation(result); // 继续原本的流程
    console.log('✅ Log: 处理完毕');
  };
}

// 原始业务
function fetchData(k) {
  k('Data Payload');
}

// 组装：给业务流程穿上“日志马甲”
fetchData(
  withLogging((data) => {
    console.log('渲染页面:', data);
  }),
);

// 输出：
// 📋 Log: 准备处理结果 Data Payload
// 渲染页面: Data Payload
// ✅ Log: 处理完毕
```

### 3.3 丢弃与异常（Catch）

异常处理的本质，就是**丢弃“成功分支”的 Continuation，跳转到“失败分支”的 Continuation**。

```javascript
function riskyTask(onSuccess, onFailure) {
  const roll = Math.random();
  if (roll > 0.5) {
    onSuccess('Win!');
  } else {
    onFailure(new Error('Lost!')); // 丢弃 onSuccess，直接跳去 onFailure
  }
}

riskyTask(
  (res) => console.log(res),
  (err) => console.error('出错了:', err.message),
);
```

这也解释了为什么 Promise 有 `.then()` 和 `.catch()` —— 它们就是注册了两个不同的未来通道。

---

## 4. ⚠ 现实开发中的“坑”：栈溢出

虽然 CPS 理论上很美，但在 JavaScript 中有一个致命缺陷：**调用栈限制**。

在支持**尾调用优化（TCO, Tail Call Optimization）**的语言（如 Scheme, Haskell）中，CPS 形式的递归不会增加调用栈深度。
**但大多数 JS 引擎（包括 Chrome V8）并未完全支持 TCO**。这意味着，如果你写一个深层递归的 CPS 函数，栈会无限增长直到爆炸。

```javascript
// ❌ 危险：在 JS 中会导致 Maximum call stack size exceeded
function recursiveCPS(n, k) {
  if (n === 0) return k(0);
  // 这一步调用会导致栈帧不断叠加
  recursiveCPS(n - 1, (res) => k(res + n));
}
```

**✅ 解决方案：Trampoline（蹦床函数）**
如果要在 JS 中使用重度 CPS（如编写编译器或解释器），通常需要配合 `Trampoline` 技巧：让函数不直接调用下一个函数，而是**返回一个“要调用下一个函数的指令”**，由外部一个循环来执行这个指令。这样栈永远只有一层。

---

## 5. 总结：CPS 在前端的幽灵

虽然我们很少手写 `k(x)`，但 CPS 的幽灵无处不在：

1.  **Promise/Async/Await**：不仅是语法糖，更是对 Continuation 的标准化封装，解决了回调地狱（Callback Hell）中 `k` 难以组合的问题。
2.  **React Hooks**：`useEffect` 的依赖数组变化重新执行，某种程度上也是一种“重新调度未来”的机制。
3.  **Koa/Express**：`next()` 其实就是显式调用的 Continuation。

**专家建议**：

- **读源码时**：当你看到 `next`、`callback`、`dispatch` 这些词时，试着带入 Continuation 的视角，你会发现复杂的库瞬间变得清晰。
- **写代码时**：虽然不建议手写 CPS 业务逻辑，但在设计通用组件（如弹窗管理器、步骤条 Wizard）时，借鉴 CPS “把控制权交出去”的思想，能极大解耦 UI 和逻辑。
