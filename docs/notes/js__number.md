---
group:
  title: javaScript
  order: 3
title: Number
toc: content
order: 3
---

## JS 神奇的 Number

你以为自己从小学就懂的 number，在 JavaScript 中其实和你想的不完全一样。

下面这些例子在 JS 里都是真的：

```js
console.log(Number.isInteger(37.0)); // true
console.log(37 === 37.0); // true

console.log(18.9 * 100); // 1889.9999999999998  期望：1890
console.log(64.68 * 100); // 6468.000000000001   期望：6468

console.log(0.1 + 0.2 === 0.3); // false
console.log(0.10000000000000001 === 0.1); // true

console.log((0.1).toPrecision(17)); // '0.10000000000000001'
console.log((0.1 + 0.2).toPrecision(16)); // '0.3000000000000000'
console.log((0.1 + 0.2).toPrecision(17)); // '0.30000000000000004'

console.log((1.005).toFixed(2)); // '1.00' 而不是期望的 '1.01'

function testPrecisionLoss() {
  let num = 2 ** 53;
  while (true) {
    if (++num % 13 === 0) {
      return num;
    }
  }
}
// testPrecisionLoss(); // 小心：这会导致无限循环！

JSON.parse('{"a":180143985094813214124}');
// 实际结果：{ a: 180143985094813220000 }
```

这些看起来“反直觉”的行为，其实都源自同一件事：

> **JavaScript 中所有的 Number 都是 IEEE 754 标准的 64 位双精度浮点数。**

---

## 一、小数点、定点数和浮点数

### 1. 小数点本质上是“对齐规则”

**小数点在数制中代表一种对齐方式**。

要直观比较 `1000` 和 `200` 的大小，我们可以把它们右对齐：

```text
1000
0200
```

从左到右比较，`1` 比 `0` 大，所以 `1000` 更大。

那如果是比较 `1000` 和 `200.01` 呢？需要先把小数点对齐：

```text
1000.00
0200.01
```

**小数点的位置在进制表示中至关重要，位置差一位，数值大小就差一个进制倍**（十进制就是十倍）。

在计算机中也是这样，只不过用的是二进制。在做加减、比较时，必须先“对齐小数点”，才能复用整数加法的逻辑。

处理小数点位置有两大类做法：

- **定点数（fixed-point）**：小数点位置预先约定好，不会变；
- **浮点数（floating-point）**：小数点位置可以随指数变化“浮动”。

### 2. 定点数：小数点写死的世界

**定点数，就是小数点永远在固定的位置上。**

比如我们约定一种 32 位无符号定点数，小数点永远在第 5 位二进制数后面：

- 整数部分：5 位
- 小数部分：27 位

它能表示的最大值是 `11111.111111111111111111111111111`（二进制）：

- 整数部分 $11111$ 是 $2^5 - 1 = 31$
- 小数部分是 27 个 1，其值为 $1 - 2^{-27}$
- 最大值 = $31 + (1 - 2^{-27}) = \mathbf{32 - 2^{-27}}$，一个**非常接近但小于 32 的数**
- 最小非零值是 $2^{-27}$

**定点数可以看作是“小数点预设好位置”的数，整数可以视为小数点“永远在末尾”。**

优点：

- 实现简单，大部分运算和整数类似

缺点：

- **绝对精度是固定的**（这里是 $2^{-27}$）
- 动态范围很小：既想表示很大数又想表示非常小的数时，空间浪费严重

这就是为什么需要“让小数点会动”的浮点数。

### 3. 浮点数：把科学记数法搬进计算机

浮点数的核心思想就是“科学记数法”：

![20251117173008](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/awesome-me/20251117173008.png)

在计算机里：

- **尾数（significand / fraction / mantissa）**：有效数字部分
- **指数（exponent）**：决定整体的量级（小数点“往左/往右挪多少位”）
- **基数**：对二进制来说是 2

指数可以改变小数点的实际位置，使其“浮动”，因此叫浮点数。

在计算机科学中，浮点是一种对实数的近似表示方式，可以简单理解为：

> **浮点数 ≈ “科学计数法”在二进制上的实现**。

---

## 二、浮点数在内存中的样子（以 32 位为例）

完整讲 IEEE 754 之前，先看一个具体例子：
**如何用 32 位浮点数存储 `20.25`**。

想要存储一个 32 位浮点数，在内存或硬盘中要占用 32 个二进制位：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-32e425cdb908c47586267e59228fcd22_1440w.png)

这 32 个二进制位从高到低（从 bit 31 到 bit 0），分成 3 部分：

- **sign**：符号位（1 bit）
- **biased exponent**：偏移指数位（8 bit）
- **fraction**：尾数位（23 bit）

### 步骤 1：把 20.25 转成二进制

把整数和小数部分分别处理：

```text
// 整数部分：20
20 / 2 = 10     ... 0
10 / 2 = 5      ... 0
5  / 2 = 2      ... 1
2  / 2 = 1      ... 0
1  / 2 = 0      ... 1
=> 从下往上读：10100

// 小数部分：0.25
0.25 * 2 = 0.5  ... 0
0.5  * 2 = 1    ... 1
=> 从上往下读：01

// 合并整数和小数
20.25₁₀ = 10100.01₂
```

### 步骤 2：转成二进制“科学计数法”

把 `10100.01₂` 写成 `1.xxxx × 2ⁿ` 的形式：

$10100.01_2 = 1.010001_2 \times 2^4$

- 尾数部分（规范化后）：`1.010001₂`
- 指数：`4`

### 步骤 3：确定符号位

20.25 是正数，所以符号位 `sign = 0`。

### 步骤 4：计算指数位（带偏移）

IEEE 754 单精度（32 位）：

- 指数位宽：8 bit
- 指数偏移量：127

这里指数是 4：

- 实际存储的指数值 = 4 + 127 = 131
- 131 的二进制是 `10000011₂`

所以：

```text
biased exponent = 1000 0011
```

### 步骤 5：计算尾数位

尾数只存储**小数部分**，规范化后首位 `1` 不显式存储（隐含 1）。

- 规范化尾数：`1.010001`
- 去掉整数部分的 `1` → `010001`
- 填充 0 到 23 位：`01000100000000000000000`

### 小结：组合成 32 位浮点数

三部分如下：

- 符号位：`0`
- 指数位：`1000 0011`
- 尾数位：`0100 0100 0000 0000 0000 000`

合在一起：

```text
0 1000 0011 0100 0100 0000 0000 0000 000
```

你可以用这个在线工具验证：
[浮点数转二进制工具](https://tooltt.com/floatconverter/)

### 反向推导一次

从 `0 1000 0011 0100 0100 0000 0000 0000 000` 还原成十进制：

1. 符号位为 `0` → 正数
2. 指数位 `1000 0011₂` = 131 → 实际指数 = 131 - 127 = 4
3. 尾数位存的是 `0100 0100 0000 0000 0000 000`
   - 加上隐含 `1` → `1.010001₂`
4. 所以值为：

   $1.010001*2 \times 2^4 = 10100.01_2 = 20.25*{10}$

到这里，你已经看到浮点数在内存中的真实样子。

> 更系统的补充可以参考：
>
> - [从科学记数法到浮点数标准 IEEE 754](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)
> - [IEEE754 标准：浮点数在内存中的存储方式](https://zhuanlan.zhihu.com/p/343033661)

---

## 三、“储物柜模型”：浮点数的精度本质

### 1. 故事从一个“储物柜”开始

想象有一台神奇的计算机，它的内存只有一个限制：**总共只能记住 100 个不同的数字**。我们用这 100 个“储物柜”来表示某个数值范围。

#### 场景一：表示 0 到 10 之间的小数

要表示 `[0, 10)`：

- 范围长度：10
- 储物柜数量：100
- 每个柜子之间的间隔：10 / 100 = **0.1**

可精确表示的数是：

```text
0.0, 0.1, 0.2, ..., 9.9
```

如果要存 `0.15` 呢？它正好在 `0.1` 和 `0.2` 的中间，没有对应储物柜，只能舍入到其中一个。

> **精度丢失的本质：真实值无法落在离散刻度上，只能被舍入到最近的刻度。**

#### 场景二：表示 0 到 100 之间的整数

用同样 100 个储物柜表示 `[0, 100)`：

- 范围长度：100
- 储物柜数量：100
- 每格间隔：100 / 100 = **1**

可精确表示的数是：

```text
0, 1, 2, ..., 99
```

所有整数都可以完美表示，没有精度问题。

#### 场景三：表示 0 到 1000 的数

用 100 个储物柜表示 `[0, 1000)`：

- 范围长度：1000
- 储物柜数量：100
- 每格间隔：1000 / 100 = **10**

可精确表示的数是：

```text
0, 10, 20, 30, ..., 990
```

想存 `25` 怎么办？也没有对应刻度，只能舍入到 `20` 或 `30`。这时连一些“小整数”都失真了。

> **当需要覆盖更大范围时，在储物柜数目有限的前提下，每格的“粒度”就不得不变粗，导致整数也可能无法精确表示。**

这个简化模型就是浮点数在不同范围下精度变化的本质。

### 2. JS 里的真实“储物柜”：64 位双精度浮点数

现在回到真实世界。JS 的 Number 实现是：

> **IEEE 754 double（64 位双精度浮点数）**

64 个二进制位分成三组：

1. **符号位（sign, 1 bit）**：正/负
2. **指数位（exponent, 11 bit）**：决定量级区间
3. **尾数位（fraction, 52 bit）**：在区间内精细划分刻度

可以这样理解：

- 指数位选定一个区间，比如 `[1, 2)`、`[2, 4)`、`[1024, 2048)` 这样的范围；
- 尾数位提供 $2^{52}$ 个离散刻度，把这个区间“填满”。

因为“每个区间里都给你差不多多的刻度（≈ $2^{52}$ 个）”，所以：

- 数值越靠近 0，**刻度越密**（可以非常精细地表示很多小数）；
- 数值越巨大，**刻度越稀**（相邻两个可表示数的间隔会变大，大整数开始“不连贯”）。

这对应了我们刚才“储物柜的间距随范围变大而变粗”的模型，只是这里划分不是一次性的，而是按指数分段进行。

---

## 四、JS 的安全整数范围与精度丢失

### 1. 安全整数：哪些整数可以“一对一”表示？

在 JS 中，有两个重要常量：

```js
Number.MAX_SAFE_INTEGER === 2 ** 53 - 1; // 9007199254740991
Number.MIN_SAFE_INTEGER === -(2 ** 53 - 1);
```

在这个闭区间内：

> **每一个整数都有唯一的双精度浮点表示（one-by-one 映射）。**

也就是说，在 $[-(2^{53} - 1), 2^{53} - 1$) 范围内，
整数和 Number 是“一一对应”的，叫做**安全整数**。

超过这个范围会发生什么？

- 会有不同整数“挤在同一个储物柜里”
- 有些整数无法精确表示，只能 round 到某个邻近的浮点数
- 结果就是：自增、自减、取模、JSON 解析等操作都可能出现不可预期行为

### 2. 无限循环的示例：testPrecisionLoss

```js
function testPrecisionLoss() {
  let num = 2 ** 53;
  while (true) {
    if (++num % 13 === 0) {
      return num;
    }
  }
}
```

为什么会无限循环？

- 当 `num` 达到某个巨大值时，`++num` 在双精度下**不再改变数值**
- 对 JS 引擎来说，`num` 已经“卡”在某个离散刻度上，自增到下一个整数在数轴上太近，落不到下一个浮点刻度
- 所以 `++num` 后 `num` 不变，`% 13` 的结果永远一样 ⇒ 无限循环

这就是“大整数精度丢失”的直接后果。

### 3. JSON 解析时的大整数截断

```js
JSON.parse('{"a":180143985094813214124}');
// 实际结果：{ a: 180143985094813220000 }
```

这个数远远大于 `Number.MAX_SAFE_INTEGER`，
在解析为 JS Number 时：

- 被迫舍入到最近的可表示双精度数
- 导致尾部多位完全错误

> **注意：在解析/序列化 JSON 时，如果需要传输大整数，应该使用字符串或 BigInt。**

例如：

```json
{
  "id": "180143985094813214124"
}
```

在 JS 中：

```js
const obj = JSON.parse(jsonStr);
// obj.id 是字符串，需要时可用 BigInt：BigInt(obj.id)
```

> 相关讨论可参考：
>
> - [JavaScript 里最大的安全的整数为什么是 2 的 53 次方减一？](https://www.zhihu.com/question/29010688)

---

## 补充：Number 的边界与常量

前面我们从“储物柜模型”和“安全整数”角度讲了 Number 的范围，这里再把 JS 中和数值边界相关的几个常量集中讲一下，方便在实战中查阅与使用。

### 1. 与范围相关的常量

#### 1.1 最大有限值：Number.MAX_VALUE

```js
Number.MAX_VALUE; // 1.7976931348623157e+308
```

含义：

- **JS 中可表示的最大有限正数**
- 再大就会变成 `Infinity`：

```js
Number.MAX_VALUE * 2; // Infinity
```

可以类比为“浮点数的右边界”，和前面说的“储物柜覆盖范围”有关。

---

#### 1.2 最小正非零值：Number.MIN_VALUE

```js
Number.MIN_VALUE; // 5e-324
```

含义：

- “**大于 0 的最小正数**”，是一个非常接近 0 的正数
- 注意：它**不是**「最小负数」，也不是「最小整数」

```js
Number.MIN_VALUE > 0; // true
-Number.MIN_VALUE < 0; // true
Number.MIN_SAFE_INTEGER; // 这是最小安全整数，完全不同概念
```

`MIN_VALUE` 对应的是「非规格数」区的最小值：
再小就只能变成 `0` 了。

---

#### 1.3 安全整数范围：MAX_SAFE_INTEGER / MIN_SAFE_INTEGER

```js
Number.MAX_SAFE_INTEGER; // 9007199254740991 === 2 ** 53 - 1
Number.MIN_SAFE_INTEGER; // -9007199254740991 === -(2 ** 53 - 1)
```

含义：

- 在这个闭区间内，**每个整数都有唯一的双精度浮点表示**：
  - “整数 ↔ Number” 是一对一的
- 超出这个范围就会出现：
  - 不同整数被映射到同一个 Number
  - 自增、自减可能不再改变值
  - 取模、JSON 解析等操作结果异常

实战中的经验就是：

> 所有可能超过 `MAX_SAFE_INTEGER` 的整数字段，都不要直接用 Number 存。

---

### 2. 与精度相关的常量

#### 2.1 Number.EPSILON：最小可区分间隔

```js
Number.EPSILON; // 2.220446049250313e-16
```

含义（在 1 附近）：

- 1 和大于 1 的**下一个可表示双精度浮点数**之间的差值
- 即：`1 + Number.EPSILON !== 1` 但 `1 + Number.EPSILON / 2 === 1`

```js
1 + Number.EPSILON === 1; // false
1 + Number.EPSILON / 2 === 1; // true
```

它常被用来做“误差范围内比较”：

```js
function nearlyEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) <= epsilon;
}

nearlyEqual(0.1 + 0.2, 0.3); // true
0.1 + 0.2 === 0.3; // false
```

注意：

- `EPSILON` 是在 1 附近的间隔大小
- 数值越大，相邻可表示数的间隔（ULP）也越大
  → 这和前面讲的“指数决定区间、尾数线性填充”完全一致

---

### 3. 和 NaN / Infinity 相关的常量

最后补充两组最常用的“特殊值”常量，虽然你在后文已讲原理，这里可以给出他们在 Number 上的直接访问方式。

```js
Number.POSITIVE_INFINITY; // Infinity
Number.NEGATIVE_INFINITY; // -Infinity
Number.NaN; // NaN
```

它们分别是：

- 正无穷：`Number.POSITIVE_INFINITY`（等价于全局的 `Infinity`）
- 负无穷：`Number.NEGATIVE_INFINITY`
- 非数值结果：`Number.NaN`（等价于全局的 `NaN`）

你可以在代码中用这些常量来强调语义，例如：

```js
if (result === Number.POSITIVE_INFINITY) {
  // 溢出，或者除以 0 的结果
}

if (Number.isNaN(result)) {
  // 运算无意义或非法输入
}
```

---

## 五、浮点数的舍入规则：round to nearest, ties to even

JavaScript 的 Number 运算遵循 IEEE 754 默认舍入模式：

> **round to nearest, ties to even**
> 向最近的可表示值舍入；
> 如果刚好在两个值正中间（tie），选尾数最低位为偶数的那个。

### 1. “最近”是什么意思？

浮点数的世界不是连续的，而是一条离散刻度尺。
在某个指数区间内，相邻的两个可表示值间有固定间隔。

类比一下：

- 如果我们规定“十进制只保留 1 位小数”，刻度是：
  ```text
  ..., 1.1, 1.2, 1.3, 1.4, ...
  ```
  相邻刻度间隔是 0.1。

真实的 IEEE 754 是二进制世界：

- 刻度是类似 $(某个尾数) × 2^\text{指数}$ 的形式；
- 一旦指数固定，相邻两个尾数对应的间隔就是固定的 ULP（Unit in the Last Place）。

“向最近的舍入”就是：

- 如果结果更靠近下面那一格 ⇒ 向下舍；
- 如果更靠近上面那一格 ⇒ 向上舍。

### 2. 什么是 tie（中点）？

还有一种尴尬情况：

> 真实结果刚好在两个可表示值的正中间。

这时上下距离一样远，就是 **tie**。

类比“只保留一位十进制小数”的世界：

- 刻度：1.2 和 1.3
- 中点：1.25
- 1.25 离 1.2 和 1.3 的距离都为 0.05 ⇒ tie

二进制世界也是类似，只不过是“某位 bit 之后是 1000...0”这种情况。

### 3. ties to even：为什么要“选偶数”？

如果在 tie 时总是向上，会有系统性偏差（整体偏大）。

IEEE 754 的选择是：

> 当在中点上时，在上下两个候选值中，
> **选尾数最低有效位（LSB）为 0 的那个（对应偶数）。**

举个简化的二进制例子：

- 假设只保留两位小数（二进制）：`xx.yy`
- 相邻刻度：`10.10₂` (2.5) 和 `10.11₂` (2.75)
- 中点：`10.101₂` (2.625)

原数正好是 `10.101₂`：

- 候选 1：`10.10₂`，最低位 bit = 0（偶数）
- 候选 2：`10.11₂`，最低位 bit = 1（奇数）
- ties to even ⇒ 选 `10.10₂`（2.5）

这么做的好处是：大量运算累积时，整体偏差倾向被削弱。

### 4. JS 中可见的结果

例如：

```js
(1.005).toFixed(2); // '1.00'
Number((1.005).toFixed(2)); // 1
```

原因是：

- 内部的 `1.005` 实际存储略小于 1.005，比如 1.004999999...
- 在“保留两位小数”的意义上，它更接近 1.00 而不是 1.01
- 再加上舍入规则和底层二进制刻度，最终落到 `'1.00'`

需要记住的是：

> **只要规范没特别说明，JS 数值运算使用的就是 round to nearest, ties to even。**

---

## 补充：Number 的常见方法与易踩坑点

前面讲的是 Number 的“底层特性”，这节集中说一说日常最常用、也最容易坑到人的几个 API：
**转字符串的**（`toString`/`toFixed`/`toPrecision` 等），和**从字符串转 Number 的**（`Number`/`parseInt`/`parseFloat`）。

### 1. 数字转字符串相关方法

#### 1.1 `Number.prototype.toString(radix)`

```js
(255).toString(); // '255'           默认 10 进制
(255).toString(16); // 'ff'            十六进制
(10).toString(2); // '1010'          二进制
(10).toString(8); // '12'            八进制
(10).toString(36); // 'a'             36 进制
```

要点：

- `radix` 取值范围是 `2 ~ 36`，不传时默认 10
- 非整数也可以转，不过小数部分是按当前 double 表示转成字符串，会暴露浮点误差：

```js
(0.1).toString(); // '0.1'
(0.1 + 0.2).toString(); // '0.30000000000000004'
```

**坑点提醒：**

- `toString` 不负责“帮你修正”浮点误差，它只是把当前存储的二进制浮点值按指定进制“翻译”为字符串。
- 如果你在 debug 时看到奇怪的小数，很可能不是 `toString` 的问题，而是数本身在内存里就已经是那个值了。

---

#### 1.2 `toFixed(digits)`：保留小数位数

```js
(1.2345).toFixed(2); // '1.23'
(1.2355).toFixed(2); // '1.24'
(1.005).toFixed(2); // '1.00'  ← 著名坑点
```

特点：

- 以**字符串形式**返回，保留 `digits` 位小数，会进行四舍五入（实质上遵循 IEEE 754 的舍入规则）
- `digits` 范围通常是 `0 ~ 20`（不同实现可能略有出入）

**关键坑点：和浮点误差叠加。**

```js
(1.005).toFixed(2); // '1.00' 而不是期望的 '1.01'
Number((1.005).toFixed(2)); // 1
```

原因并不是 `toFixed` 舍入错了，而是：

- 内存中的 `1.005` 实际并不是精确的 1.005，而是略小一点，比如 1.004999999...
- 在“保留两位小数”的视角下，它比 1.00 更近，而不是 1.01
- 再加上 IEEE 754 的 round to nearest, ties to even，结果落在 `'1.00'`

实战建议：

- 对金额、计费这类严肃场景，不要直接依赖 `toFixed` 做精度控制。
  更稳妥的方案是：
  - 全程用整数（分/厘等）运算，然后在显示时格式化；
  - 或使用十进制高精度库（如 `decimal.js` / `big.js`）。

---

#### 1.3 `toPrecision(precision)`：保留有效数字

```js
(123.456).toPrecision(3); // '123'
(123.456).toPrecision(4); // '123.5'
(0.00123456).toPrecision(3); // '0.00123'
(0.1).toPrecision(17); // '0.10000000000000001'
```

特点：

- 控制的是“**有效数字总数**”，而不是小数位数
- 返回值是字符串，有时会自动切换成科学计数法

容易误解的点：

- `(0.1).toPrecision(17) === '0.10000000000000001'` 很容易让人误以为“JS 把 0.1 算错了”
- 实际上这是把 double 内部真实值以尽可能多的精度打印出来的结果，**正是浮点误差的体现**

你文章前面给的例子：

```js
console.log((0.1).toPrecision(17)); // '0.10000000000000001'
console.log((0.1 + 0.2).toPrecision(16)); // '0.3000000000000000'
console.log((0.1 + 0.2).toPrecision(17)); // '0.30000000000000004'
```

本质就是“打印出来看到的就是储物柜里的真实值”。

---

#### 1.4 `toExponential(fractionDigits)`：科学计数法

```js
(123456).toExponential(); // '1.23456e+5'
(123456).toExponential(2); // '1.23e+5'
(0.0000123).toExponential(2); // '1.23e-5'
```

特点：

- 总是用科学计数法表示
- `fractionDigits`：小数部分保留的位数（即指数前的小数位）

使用场景主要是：

- 需要按科学计数法展示非常大或非常小的数
- 在调试浮点数时看它的指数级别

---

### 2. 字符串转 Number 的方法

#### 2.1 `Number(value)`：整体尝试转换

```js
Number('123'); // 123
Number('123.45'); // 123.45
Number('  0010  '); // 10
Number('0b1010'); // 10  二进制字面量形式
Number(''); // 0
Number('abc'); // NaN
Number(null); // 0
Number(undefined); // NaN
```

特点：

- 尝试将整个字符串当作一个数来解析；无法解析则返回 `NaN`
- 会处理前后空白；不允许中间有非数值字符

**区别于 `parseInt`/`parseFloat`：**

- `Number('123abc')` → `NaN`
- `parseInt('123abc', 10)` → `123`（能解析就解析一段）

---

#### 2.2 `parseInt(string, radix)`：按进制解析整数

```js
parseInt('123', 10); // 123
parseInt('1010', 2); // 10
parseInt('0xFF'); // 255（没传 radix 时，有些实现会按前缀推断）
parseInt('08'); // 8（现代 JS 通常按 10 解析）
parseInt('123.45', 10); // 123  小数部分被截断
parseInt('123abc', 10); // 123  遇到非数字字符就停
parseInt('abc', 10); // NaN  开头就不能解析 -> NaN
```

历史坑点（现在大部分环境已修复，但仍值得提一下）：

- 很早以前的 JS 引擎中，如果不传 radix，且字符串以 `0` 开头，可能被当作八进制：
  ```js
  parseInt('08'); // 旧环境中可能是 0
  ```
- 现代标准中建议**总是显式传 radix**，尤其是解析用户输入时：

```js
parseInt('08', 10); // 强制按十进制 -> 8
```

---

#### 2.3 `parseFloat(string)`

```js
parseFloat('123.45'); // 123.45
parseFloat('  0.1  '); // 0.1
parseFloat('1.23abc'); // 1.23
parseFloat('abc1.23'); // NaN
parseFloat('Infinity'); // Infinity
```

特点：

- 和 `parseInt` 类似，但支持小数点、指数标记（如 `1.23e3`）
- 也是“能解析的前缀就解析，遇到第一个非法字符就停”，否则 NaN

注意：

- 解析出来的结果依然是 double，依然会有浮点精度问题：
  ```js
  parseFloat('0.1') + parseFloat('0.2') === 0.3; // false
  ```

### 补充：Number 常用方法速查表

| 分类         | 方法/写法                     | 作用概述                                          | 返回类型 | 典型坑点/备注                                                               |
| ------------ | ----------------------------- | ------------------------------------------------- | -------- | --------------------------------------------------------------------------- |
| 基本转换     | `Number(value)`               | 将整体 `value` 转成 Number，失败则为 `NaN`        | number   | 对字符串要求严格：`'123abc'` → `NaN`，和 `parseInt` 不同                    |
| 进制字符串   | `num.toString(radix)`         | 按指定进制（2–36）把数字转成字符串                | string   | 会暴露浮点误差：`(0.1+0.2).toString()` → `'0.30000000000000004'`            |
| 固定小数位   | `num.toFixed(digits)`         | 保留 `digits` 位小数并四舍五入                    | string   | 受浮点误差影响，`(1.005).toFixed(2)` → `'1.00'`，不适合严肃金额运算         |
| 有效数字     | `num.toPrecision(precision)`  | 保留总共 `precision` 位有效数字                   | string   | 可能用科学计数法；高精度时会暴露浮点误差：`0.1` → `'0.10000000000000001'`   |
| 科学计数法   | `num.toExponential(digits)`   | 用科学计数法表示，保留 `digits` 位小数            | string   | 主要用于展示/调试非常大或非常小的数                                         |
| 解析整数     | `parseInt(str, radix)`        | 按 `radix` 解析前缀为整数，遇到非法字符即停止     | number   | 不传 radix 可能有历史八进制坑；`parseInt('123abc',10)` → `123`              |
| 解析浮点数   | `parseFloat(str)`             | 解析前缀为浮点数，支持小数点和指数                | number   | `parseFloat('1.23abc')` → `1.23`；解析结果仍是 double，有浮点精度问题       |
| NaN 检测     | `Number.isNaN(value)`         | 严格判断是否为 `NaN`                              | boolean  | 区分于全局 `isNaN`：`Number.isNaN('abc')` → false，而 `isNaN('abc')` → true |
| 有限数判断   | `Number.isFinite(value)`      | 判断是否为有限的 Number（非 `NaN`/±Infinity）     | boolean  | 不做隐式转换：`Number.isFinite('123')` → false                              |
| 整数判断     | `Number.isInteger(value)`     | 判断是否为整数（在安全范围内）                    | boolean  | `Number.isInteger(1.0)` → true；不是 BigInt 判断                            |
| 安全整数判断 | `Number.isSafeInteger(value)` | 判断是否为“安全整数”（在 ±(2^53−1) 范围内的整数） | boolean  | 用于防止大整数精度丢失                                                      |

---

## 六、特殊值：非规格数、±0、±Infinity 和 NaN

IEEE 754 除了“普通”浮点数，还有一些特殊编码：

- **非规格数（Subnormal / Denormal）**
- **正零和负零：+0 和 -0**
- **正无穷和负无穷：+Infinity 和 -Infinity**
- **NaN（Not-a-Number）**

简单说一下它们的意义。

### 1. 非规格数（Subnormal）

当指数最小（全 0）、尾数非 0 时，就进入“非规格数”区：

- 用来表示**非常接近 0 的极小值**
- 这样可以避免从最小规格化数直接跳到 0 的“精度断崖”

它保证了浮点数在接近 0 的地方也有一段“渐进”的数值范围。

### 2. ±0：为什么有两个零？

在 IEEE 754 中：

- +0 和 -0 有不同的 bit 模式（符号位不同）
- 但在大部分比较里，`+0 === -0` 为 true

区别只在某些运算里暴露，比如：

```js
1 / 0; // Infinity
1 / -0; // -Infinity

Object.is(+0, -0); // false
```

**整数零不能做除数，但是浮点数零可以做除数**，得出的就是 ±Infinity。

### 3. ±Infinity：溢出/除零的结果

当运算结果超出可表示范围，或被 0 除时，会得到 Infinity 或 -Infinity：

```js
1 / 0; // Infinity
-1 / 0; // -Infinity
Math.pow(2, 1024); // Infinity（溢出）
```

Infinity 本身仍然是一个合法的 Number，参与比较和运算有自己的规则。

### 4. NaN：不是一个合法数字结果

当运算结果根本“不像一个数”时，就会得到 NaN，例如：

```js
0 / 0; // NaN
Infinity - Infinity; // NaN
Math.sqrt(-1); // NaN
parseInt('abc', 10); // NaN
```

需要注意：

- NaN 在比特层面有很多种不同表示（**远不止 1 个**）
- 但 JS 层面看只有一个 `NaN` 常量
- NaN 不等于任何东西，包括自己：

```js
NaN === NaN; // false
Number.isNaN(NaN); // true
```

关于它为什么不是独立类型、为什么有很多个 bit 模式，可见：

- [为什么在 JavaScript 中 NaN 不能是一个独立的类型？](https://www.zhihu.com/question/379014728)

> 进一步可参考：
>
> - [IEEE754 规范：四，非规格数，±infinity，NaN](https://zhuanlan.zhihu.com/p/343049681)
> - [为什么 0 不能做除数？](https://www.bilibili.com/video/BV1qT4y1B7ot)

---

## 七、实战建议：如何规避 Number 精度坑

前面讲的是原理，这里总结几条在项目中实用的建议。

### 1. 金额类场景不要直接用浮点数

比如电商、支付、财务等金额场景：

- 不要用 `0.1 + 0.2` 这种形式做金额计算
- 通常用「最小货币单位」做整数运算：
  - 元 → 分：`1.23 元` 存成 `123`
  - 再通过除 100 在展示层格式化

或者使用专门的十进制高精度库，例如：

- decimal.js
- big.js

### 2. 大整数用字符串或 BigInt

对于可能超过 `Number.MAX_SAFE_INTEGER` 的 ID、订单号等：

- 通信协议中统一用字符串承载：
  ```json
  {
    "id": "180143985094813214124"
  }
  ```
- 在 JS 中用字符串或 BigInt 处理：
  ```js
  const id = BigInt(obj.id);
  ```

避免让 JSON 解析自动把它变成 Number。

### 3. 比较小数时用误差范围，而非直接 `===`

由于小数精度问题，`0.1 + 0.2 === 0.3` 会是 false。
比较浮点数时，建议使用一个误差阈值：

```js
function nearlyEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) < epsilon;
}

nearlyEqual(0.1 + 0.2, 0.3); // true
```

`Number.EPSILON` 是 JS 中两个可表示浮点数之间的最小间隔（在 1 附近），可以作为默认阈值。

---
