下面我会**系统性地过一遍 React 常用 Hooks**，每个 Hook 都从 **做什么 → 业务中怎么用 → 常见坑 → 正确心智模型** 四个维度展开。整体风格偏**工程实践**，而不是 API 说明书。

---

## 1. useState —— 组件的最小状态单元

### 做什么

`useState` 用来声明**会随时间变化的数据**，是函数组件的状态来源。

```ts
const [state, setState] = useState(initialState);
```

- `initialState`：值 or 初始化函数
- `setState`：值 or updater 函数

---

### 典型业务场景

#### 表单输入

```tsx
const [username, setUsername] = useState('');

<input value={username} onChange={(e) => setUsername(e.target.value)} />;
```

#### 依赖旧状态更新（计数器、toggle）

```tsx
setCount((prev) => prev + 1);
setOpen((prev) => !prev);
```

---

### 常见坑

#### ❌ 1. 直接依赖旧 state 值

```tsx
// ❌ 问题代码
setCount(count + 1);
setCount(count + 1);
```

> 在并发模式 / 批量更新下，`count` 可能是旧值。

✅ 正确写法：

```tsx
setCount((c) => c + 1);
setCount((c) => c + 1);
```

---

#### ❌ 2. 把“派生状态”也放进 state

```tsx
const [fullName, setFullName] = useState(firstName + lastName);
```

这会导致 **状态冗余 & 不一致**。

✅ 正确心智模型：

> **State 只存“源数据”，派生值用计算。**

```tsx
const fullName = `${firstName} ${lastName}`;
```

---

### 心智模型总结

- state 是 **UI 的最小真相源**
- 不要复制 props 到 state
- 更新 state 时，**永远假设它是异步的**

---

## 2. useEffect —— 处理“渲染之外的事情”

### 做什么

`useEffect` 用来处理 **副作用**：请求、订阅、手动 DOM、日志等。

```ts
useEffect(() => {
  // effect
  return () => {
    // cleanup
  };
}, deps);
```

---

### 典型业务场景

#### 请求数据

```tsx
useEffect(() => {
  fetchUser(id).then(setUser);
}, [id]);
```

#### 订阅 & 取消订阅

```tsx
useEffect(() => {
  window.addEventListener('resize', onResize);
  return () => {
    window.removeEventListener('resize', onResize);
  };
}, []);
```

---

### 常见坑

#### ❌ 1. 忽略依赖数组

```tsx
useEffect(() => {
  fetchData(query);
}, []); // ❌ query 变了不会重新请求
```

> ESLint `react-hooks/exhaustive-deps` 是**对的**，不是烦人。

---

#### ❌ 2. 在 effect 里 setState 形成死循环

```tsx
useEffect(() => {
  setCount(count + 1);
}, [count]);
```

---

### 心智模型总结

- **useEffect ≠ 生命周期**
- effect 是对 **某个状态变化的响应**
- 依赖数组 = “我关心哪些输入”

---

## 3. useLayoutEffect —— 同步副作用（慎用）

### 做什么

与 `useEffect` 类似，但：

- **在 DOM 更新后、浏览器绘制前同步执行**
- 会阻塞渲染

---

### 典型业务场景

#### 需要读 DOM 并立刻写 DOM（避免闪屏）

```tsx
useLayoutEffect(() => {
  const height = ref.current.offsetHeight;
  setHeight(height);
}, []);
```

---

### 常见坑

#### ❌ 滥用

```tsx
useLayoutEffect(() => {
  heavyCompute();
});
```

> 会造成掉帧、卡顿。

---

### 心智模型总结

- **99% 场景用 useEffect**
- 用 useLayoutEffect 的理由只能是：

  > “我必须在浏览器绘制前同步修正 DOM”

---

## 4. useReducer —— 复杂状态的“状态机”

### 做什么

把 **状态变更逻辑** 抽离成 reducer。

```ts
const [state, dispatch] = useReducer(reducer, initialState);
```

---

### 典型业务场景

#### 表单 / 复杂交互

```tsx
function reducer(state, action) {
  switch (action.type) {
    case 'setField':
      return { ...state, [action.key]: action.value };
  }
}
```

#### 结合 immer

```ts
const reducer = produce((draft, action) => {
  draft.count++;
});
```

---

### 常见坑

#### ❌ 用 useReducer 但 action 不规范

```ts
dispatch({ count: 1 }); // ❌
```

---

### 心智模型总结

- 当 `useState` 变成 `setXXX` 地狱时，用 reducer
- reducer 是 **纯函数**
- reducer = 前端里的“领域模型”

---

## 5. useRef —— 跨渲染保存值

### 做什么

- 保存 DOM
- 保存不影响渲染的值

```ts
const ref = useRef(initialValue);
```

---

### 典型业务场景

#### DOM 操作

```tsx
inputRef.current.focus();
```

#### 保存定时器 / 上一次值

```ts
const prevCount = useRef(count);
```

---

### 常见坑

#### ❌ 期待 ref 变化触发渲染

```ts
ref.current = 123; // 不会 re-render
```

---

### 心智模型总结

- ref 是 **组件实例上的盒子**
- 用来逃离 React 的响应式系统

---

## 6. forwardRef + useImperativeHandle —— 控制子组件

### 做什么

让父组件调用子组件的方法。

---

### 典型业务场景

#### 表单组件暴露校验方法

```tsx
useImperativeHandle(ref, () => ({
  validate,
  reset,
}));
```

---

### 常见坑

#### ❌ 把 ref 当 props 用

> ref 是**命令式逃生舱**，不是常规通信方式。

---

### 心智模型总结

- ref 用于**行为控制**
- props 用于**数据流动**

---

## 7. useContext —— 跨层共享状态

### 做什么

解决 **prop drilling**

---

### 典型业务场景

- 主题
- 国际化
- 当前用户

```tsx
const theme = useContext(ThemeContext);
```

---

### 常见坑

#### ❌ Context 里放高频变化数据

> 会导致所有消费者重新渲染。

---

### 心智模型总结

- Context 不是状态管理库
- 适合 **低频、全局、稳定数据**

---

## 8. memo / useMemo / useCallback —— 性能工具

### 做什么

- `memo`：避免子组件无意义重渲染
- `useMemo`：缓存计算结果
- `useCallback`：缓存函数引用

---

### 典型业务场景

#### 列表项

```tsx
const Item = memo(({ onClick }) => {});
```

---

### 常见坑

#### ❌ 过早优化

```tsx
useMemo(() => x + 1, [x]);
```

---

### 心智模型总结

- **先写正确，再写快**
- 优化的前提是：你知道慢在哪

---

## 总结一句话版

| Hook             | 本质             |
| ---------------- | ---------------- |
| useState         | 最小状态单元     |
| useEffect        | 对状态变化的响应 |
| useLayoutEffect  | 同步 DOM 修正    |
| useReducer       | 状态机           |
| useRef           | 跨渲染容器       |
| imperativeHandle | 命令式控制       |
| useContext       | 共享只读数据     |
| memo 系列        | 性能优化工具     |

---

如果你愿意，下一步我可以帮你做三件事之一：

1. 用 **一个真实业务 Demo** 把这些 Hook 串起来
2. 从 **Hooks 心智模型（代数效应视角）** 再升一层
3. 结合你之前在做的 **组件库 / Base UI**，说明 Hooks 在设计系统中的使用边界
