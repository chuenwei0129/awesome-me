# 在 JavaScript 里造一条“看不见的河流”：从 React Context 到通用上下文思维

---

### 一、当参数开始淹没你的代码

真正让人崩溃的，往往不是某个复杂算法，而是一条越拉越长的调用链。

A 调 B，B 再调 C，C 在里面做了一些副作用，还要根据结果把值传回去。你本来只想在最外层的 A 里多用一个变量，却发现这一点小小的需求，逼着你把这个变量当作参数，一层一层地塞给 B，再从 B 塞给 C，只因为 C 需要它——而 B 根本不关心它。

很快，函数签名开始长出各种“路过型参数”：
它们不是为了当前函数而存在，只是被迫从这儿经过。

在 React 里，这个问题有一个特别形象的名字：**prop drilling**。为了解决它，React 提供了一个优雅的“虫洞”——`React.Context`。在父组件上创建一个 Context，把值放进去，然后在任意深度的子组件里，通过 `useContext` 把值拿出来，中间所有组件都不必知道这件事的存在。

更有意思的是：
**“把信息从调用链里抽出来，交给另一个隐形载体”的想法，并不属于 React，它其实是一种更底层的 JavaScript 思维方式。**

如果能在普通的 JavaScript 函数世界里，造出这样一个“虫洞”，会发生什么？

---

### 二、闭包里的小世界：实现一个同步版 Context

要在 JavaScript 里实现一个类似 React Context 的东西，实质上要解决两个问题：

1. 把值存在哪里，才能让“当前调用链里的所有函数”都拿得到？
2. 如何优雅地控制这个“当前”，避免不同调用互相污染？

答案就藏在两个特性里：**闭包**和**单个执行上下文中的串行事件循环**。

我们从一个 API 轮廓开始：

```ts
const ValueContext = createContext<number>();

ValueContext.Provider(42, () => {
  callback1();
  callback2();
});

function callback1() {
  const value = useContext(ValueContext);
  console.log(value); // 42
}
```

如果我们希望 `useContext(ValueContext)` 能够返回当前 Provider 传入的 `42`，需要一个“容器”来存这个值，并且这个容器不能是全局共享的，而是“这个 Context 实例专属的”。

闭包正是这样一种容器。

下面是一段**可直接运行**的 TypeScript 实现（只适用于同步调用链）：

```ts
const NO_VALUE_DEFAULT = Symbol('NO_VALUE_DEFAULT');
type NoValueDefault = typeof NO_VALUE_DEFAULT;
type ContextValue<T> = T | NoValueDefault;

interface Context<T> {
  Provider: (value: T, callback: () => void) => void;
  Consumer: () => T;
}

function createContext<T>(
  defaultValue: ContextValue<T> = NO_VALUE_DEFAULT,
): Context<T> {
  let contextValue: ContextValue<T> = defaultValue;

  const Provider = (value: T, callback: () => void) => {
    const previous = contextValue;
    contextValue = value;
    try {
      // 在这个上下文中执行同步回调
      callback();
    } finally {
      // 关键点：无论回调是否抛错，都要恢复旧值
      contextValue = previous;
    }
  };

  const Consumer = (): T => {
    if (contextValue === NO_VALUE_DEFAULT) {
      throw new TypeError(
        'You should only use useContext inside a Provider, or provide a default value!',
      );
    }
    return contextValue;
  };

  return { Provider, Consumer };
}

function useContext<T>(ctx: Context<T>): T {
  return ctx.Consumer();
}

// ====== 最小可运行示例 ======
const ValueContext = createContext<number>();

ValueContext.Provider(42, () => {
  console.log('inner', useContext(ValueContext)); // inner 42
});

try {
  console.log('outer', useContext(ValueContext));
} catch (e) {
  console.log('outer error:', (e as Error).message);
}
```

这段代码展示了几个关键点：

- `createContext` 调用一次，就生成一个独立的作用域，里面的 `contextValue` 对外不可见，却可以被 `Provider` 和 `Consumer` 持续访问。多次调用 `createContext`，就得到多个互不干扰的“隐形存储”。
- `Provider` 在进入回调前写入值，回调结束后恢复旧值。
- 使用 `try/finally` 确保即便回调抛错，语境也不会“泄漏”到后续调用中。
- 当 Context 没有默认值，又在 Provider 范围之外调用 `useContext` 时，会抛出明确错误，而不是静默地返回 `undefined`。

需要特别强调的是：
**这个实现只适用于同步代码。**
回调不要写成 `async () => {}`，也不要在里面 `await`，否则我们依赖的“调用栈连续性”会被打断，语境恢复的时机就和你想象的不一样了，这一点在后文会展开。

在一个单个 JavaScript 执行上下文（例如浏览器主线程或 Node.js 主线程）的世界里，事件循环是串行的，这在同步场景下给了我们一个隐形的保证：
当 `Provider` 正在执行它的同步回调时，不会有其他任务并发地改写 `contextValue`，我们就像在一条“看不见的河流”里传递信息：
值不再通过参数层层奔跑，而是安静地流淌在当前调用链的空气中，谁需要，就从空气里取一口。

---

### 三、多重语境并存：嵌套 Provider 与默认值

真实世界从不满足于一个简陋版本。
稍微往前走一步，就会遇到一个问题：

如果在一个 Provider 的回调里，再次调用同一个 Provider，会发生什么？

```ts
const ValueContext = createContext<number>();

ValueContext.Provider(42, () => {
  console.log(useContext(ValueContext)); // 42

  ValueContext.Provider(13, () => {
    console.log(useContext(ValueContext)); // 13
  });

  console.log(useContext(ValueContext)); // 42
});
```

我们希望：

- 最外层读到 `42`；
- 嵌套层读到 `13`；
- 从嵌套层返回后，又回到 `42`。

如果 `Provider` 只是简单地“写入一个值，然后执行回调”，`contextValue` 就会一直被最新的值覆盖，再也回不到旧值。上一层上下文的信息，就这样被抹平了。

前面的实现里，我们用了一种“栈”的思想：

```ts
const Provider = (value: T, callback: () => void) => {
  const previous = contextValue; // 记住旧值
  contextValue = value; // 写入新值
  try {
    callback(); // 在这个上下文中执行回调
  } finally {
    contextValue = previous; // 回到旧值
  }
};
```

这样一来，无论嵌套多少层 Provider，每一层都像是往“语境栈”里压入一个新帧，执行完自己的回调后再弹出，之前的语境就自然地复原。

接下来是默认值的问题。

在 React 里，如果你在定义 Context 时提供了一个默认值，即使没有 Provider 包裹，也能通过 `useContext` 读到这个默认值。我们也想要类似的能力，但又不希望“未设置”和“显式设置为 undefined”混在一起。

这里用一个独一无二的 `Symbol` 来标记“没有默认值”，就是为了：

- 当 Context 没有提供默认值，又在 Provider 范围之外调用 `useContext` 时，可以明确抛错，而不是静默返回 `undefined`；
- 如果你确实希望“无 Provider 也有值”，就传入一个默认值；而显式的 `undefined` 也不会被误认为是“未设置”；
- 在 TypeScript 里，通过 `Symbol` 做守卫后，`contextValue` 的类型可以安全收窄为 `T`，让类型系统和运行时行为相互印证。

到这里，一个可以嵌套、可以有默认值、带有严格边界的同步 Context 已经相当完整。
它为我们提供的不仅是一个工具，更是一种“如何在调用链之外管理语境”的能力。

---

### 四、当测试框架开始说话：Context 的隐形身影

抽离出一个思维模型之后，你会惊讶地发现：
很多你早已习惯的 API，其实都长成了 Context 的样子。

比如几乎所有主流 JavaScript 测试框架：Mocha、Jest、Bun、Vitest……它们都提供了非常类似的接口：

```ts
import { describe, it, beforeAll } from 'mocha';
import { expect } from 'chai';

// 或者
import { describe, it, beforeAll, expect } from '@jest/globals';
import { describe, it, beforeAll, expect } from 'bun:test';
import { describe, it, beforeAll, expect } from 'vitest';
```

当你写下：

```ts
describe('add', () => {
  it('basic', () => {
    expect(add(1, 1)).toBe(2);
  });
});
```

测试通过时，控制台也许会输出类似这样的信息：

```text
add > yeah~ basic
```

其中，“add” 来自外层的 `describe`，而 “basic” 来自内层的 `it`。这意味着：`it` 在执行的时候，能感知到外层 `describe` 提供的“当前描述”。

如果我们用最朴素的方式写出 `describe` 和 `it`，是这样的：

```ts
function describe(description: string, callback: () => void) {
  callback();
}

function it(text: string, callback: () => void) {
  try {
    callback();
    console.log('yeah~ ' + text);
  } catch {
    console.log('ohno! ' + text);
  }
}
```

这时，`it` 自然拿不到 `description`——它既没有参数，也没有从调用链向外窥探的能力。

而一旦把 Context 引入进来，局面立刻改观：

```ts
const DescribeContext = createContext<{ description: string }>();

function describe(description: string, callback: () => void) {
  DescribeContext.Provider({ description }, () => {
    callback();
  });
}

function it(text: string, callback: () => void) {
  const { description } = useContext(DescribeContext);

  try {
    callback();
    console.log(description + ' > yeah~ ' + text);
  } catch {
    console.log(description + ' > ohno! ' + text);
  }
}
```

现在，`it` 在执行时不再需要从参数里“拎起”上层信息，而是从当前的 `DescribeContext` 中直接读出最近一层 `describe` 的描述。这就是 Context 的典型用法：让“当前环境”的信息自动随调用栈传播。

如果想支持多层嵌套的描述链条，我们可以把 Context 中的值变成一条“描述栈”：

```ts
const DescribeStackContext = createContext<string[]>([]);

function describe(description: string, callback: () => void) {
  const parent = useContext(DescribeStackContext);
  DescribeStackContext.Provider([...parent, description], callback);
}

function it(text: string, callback: () => void) {
  const chain = useContext(DescribeStackContext);
  const fullName = [...chain, text].join(' > ');

  try {
    callback();
    console.log(fullName + ' ✅');
  } catch {
    console.log(fullName + ' ❌');
  }
}
```

这样，多层嵌套的 `describe` 会自然形成一个“语境栈”：
外层提供大背景，内层逐步细化，`it` 只需关心“当前语境链条是什么”。

重要的是：一旦你用 Context 的眼光去看这些 API，它们就从朴素的函数调用，变成了一种围绕“当前语境”组织代码的范式。

---

### 五、实战一：在 Node.js 中维护“请求上下文”

到目前为止，我们讨论的 Context 都停留在“同步调用栈”的世界里。
但在真实工程中，你很快会遇到这样一种需求：

> 在一条 HTTP 请求的整个生命周期中，我想随时拿到“当前请求 ID / 用户信息 / traceId”，哪怕中间经过了很多 `setTimeout`、数据库调用、远程接口、消息队列……

如果你尝试用前文的同步 Context 来实现：

```ts
const RequestContext = createContext<{ requestId: string }>();

http.createServer((req, res) => {
  const requestId = String(Date.now());

  RequestContext.Provider({ requestId }, () => {
    console.log('sync log:', useContext(RequestContext)); // ✅ 有值

    setTimeout(() => {
      // ❌ 这里已经不在原来的调用栈里了
      console.log('async log:', useContext(RequestContext));
    }, 10);
  });
});
```

你会发现：`setTimeout` 的回调里要么抛错，要么只能拿到默认值，而不是那次请求的 `requestId`。

原因在于：**事件循环把调用栈撕成了多个时间片**。
当 `Provider` 的同步回调一结束，我们的实现就通过 `finally` 恢复了 `contextValue`，接下来发生的任何异步任务，都已经“脱离了这个语境”。

在 Node.js 中，这个问题有一个现实可用的解决方案：`AsyncLocalStorage`。
下面是一段**可直接运行**的示例（Node.js ≥ 16）：

```js
const http = require('http');
const { AsyncLocalStorage } = require('node:async_hooks');

/**
 * @typedef {{ requestId: string }} RequestContext
 */

/** @type {AsyncLocalStorage<RequestContext>} */
const als = new AsyncLocalStorage();

function logWithContext(message) {
  const store = als.getStore();
  const prefix = store ? `[${store.requestId}]` : '[no-ctx]';
  console.log(prefix, message);
}

const server = http.createServer((req, res) => {
  const requestId = `${Date.now()}-${Math.random().toString(16).slice(2)}`;

  als.run({ requestId }, () => {
    logWithContext('incoming request');

    // 这里可以安全地做异步操作，语境会跟着异步链路传播
    setTimeout(() => {
      logWithContext('handling business logic...');
      res.end('ok\n');
    }, 50);
  });
});

server.listen(3000, () => {
  console.log('Server listening on http://localhost:3000');
});
```

你会看到，每一条日志都带上了同一个 `requestId`，说明“请求语境”在异步世界中被维护住了。

从思维模型上看：

- 我们在同步世界里用闭包和“语境栈”造出的 `createContext`，本质上是一种**同步上下文**；
- `AsyncLocalStorage` 则把类似的思想扩展到了异步世界：它追踪的是“当前异步链路”的语境，而不是单一调用栈。

在真实工程中，你可以这样划分：

- 练习、工具函数、小型脚本：可以用前文的同步 Context 练习“语境思维”；
- 生产级 Node 服务：优先使用 `AsyncLocalStorage` 或框架提供的异步上下文能力，不要用同步 Context 硬抗异步链路。

---

### 六、被事件循环打断的语境：为什么需要 AsyncContext

回到刚才的例子：

```ts
const ValueContext = createContext(2);

ValueContext.Provider(42, () => {
  console.log(useContext(ValueContext)); // 42

  setTimeout(() => {
    console.log(useContext(ValueContext)); // 2 (?!)
  }, 0);

  console.log(useContext(ValueContext)); // 42
});
```

在 `setTimeout` 外部，Context 的表现仍然符合预期：进入 Provider 读到 `42`，退出时恢复为默认值 `2`。
但在计时器回调里，`useContext` 却只能读到 `2`——仿佛那个曾经短暂存在过的 `42`，从未出现。

问题不是 `createContext` 的实现出了错，而是我们之前依赖的前提——**调用栈的连续性**——在异步世界中不再成立。

`Provider` 的设计建立在这样的假设之上：

> “我在进入回调之前写入值，在回调结束之后恢复值。整个回调执行期间，调用栈都挂在我下面。”

然而，一旦一个函数被挂入事件循环，它就不再沿着原来的调用栈往下走，而是等到未来某个时间点，被事件循环重新调度。在那个时刻，`Provider` 早已执行完毕，`contextValue` 恢复为默认值，原本那条“语境链路”也随之消失。

为了解决这个问题，社区已经探索出各种“异步上下文”方案：

- Angular 的 `zone.js`，通过 monkey-patch 异步 API 来追踪“当前 Zone”；
- Node.js 的 `AsyncLocalStorage`，提供了一种官方的异步上下文存储方式；
- Chrome DevTools 的 Async Tagging API，通过给异步任务打标签，帮助你在调试时复原逻辑链条。

更重要的是，JavaScript 语言本身也开始正视这个问题。
一个关于 **AsyncContext（异步上下文）** 的提案 `proposal-async-context` 已经被提交至 TC39，**截至 2024 年底，该提案处于 Stage 2 阶段**（后续状态请以官方文档为准）。

如果这个提案最终通过，JavaScript 将在语言层面，提供一种官方的方式，让“上下文”穿过异步鸿沟：
我们在同步世界里练习的所有 Context 思维，都将拥有一双新的翅膀，不再受限于单个调用栈，而是可以在事件循环的整个生命线上，追踪“当前语境”。

---

### 七、在调用栈之上搭一座“语境栈”

如果把这一切抽象成一个心智模型，可以叫它：**“语境栈”**。

- 传统意义上的调用栈关心的是“谁调用了谁”：函数 A 调用 B，B 调用 C，栈帧一层层压上去又弹下来。
- 语境栈关心的是“此刻我处在怎样的环境中”：当前用户是谁？当前测试用例是哪一个？当前模块使用的配置是什么？

在没有 Context 之前，我们常常把“语境”硬塞进调用栈：

- 要么通过参数一路传递，让函数签名充满噪音；
- 要么借助全局变量偷懒，让模块之间粘得太紧。

Context 给了第三条路：
**在调用栈之上，再搭一座独立的“语境栈”。**

- 每进入一个语境，就压入一帧；
- 每离开，就弹出一帧；
- 函数不再需要显式地声明“我依赖哪些外层信息”，而是依赖于“当前语境”的状态。

这并不是鼓励滥用隐式状态，而是提醒我们：

> 真正让系统变清晰的，往往不是“把所有信息都显式地写在参数里”，
> 而是有意识地划分：哪些是局部逻辑的输入，哪些是当前世界的背景。

在大型 React 应用中，Context 成为“全局但可分区”的状态载体；
在测试框架里，`describe` / `it` 把“当前正在描述哪个场景”变成一种语境；
在 Node.js 服务中，我们可以用 `AsyncLocalStorage` 之类的能力，把“当前请求”、“当前 traceId”变成一条穿越异步世界的语境链。

在通用 JavaScript 代码中，你也完全可以用自建的同步 Context，把“当前事务”“当前语言环境”等背景信息，从参数中抽离出来，变成一条看不见、但始终存在的河流。

---

### 八、写在最后：学会与“隐含信息”相处

软件系统之所以易碎，很大程度上是因为“隐含信息”太多——

- 那些没有写在函数签名里的前提；
- 那些只存在于开发者脑海中的假设；
- 那些被埋入框架或运行时的约定。

Context 并不能消灭隐含信息，它做的是另一件更细腻的事：
**把隐含信息收拢到一个可被管理的容器里，为它们划出清晰的边界和流向。**

在同步世界中，闭包和单个执行上下文的串行事件循环给了我们实现这种容器的基础；
在异步世界中，事件循环撕裂了调用栈，也逼迫我们去思考：如何在一个被打散的时间轴上，持续维护语境？从 `zone.js` 到 `AsyncLocalStorage`，再到 AsyncContext 的提案，这条路还在延展。

真正重要的，是你在日常写代码时，开始对自己保持一点警惕：

- 当我往函数里多加一个参数时，这个东西是不是其实更像“语境”？
- 当我习惯性地访问某个全局变量时，它是不是应该被装进某种 Context？
- 当我在异步回调里依赖某个外层状态时，我有没有清楚地知道，这个状态是如何一路传到这里的？

如果有一天，你在阅读一段陌生代码时，会下意识地问一句：

> “这段逻辑的语境是什么？”

那么，无论 JavaScript 有没有内建 AsyncContext，无论你用不用 React，你已经在用一种更成熟的方式看待代码：
不是把它们当作一堆函数的拼接，而是把它们看作在同一条语境河流上，顺流而下的一系列片段。
