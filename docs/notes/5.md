## 两台计算机的一出戏：用两阶段思维理解 React 为什么要“跑两次”

> 这是一篇在原文基础上，补齐工程细节、版本约束和代码示例后的重写版。

---

### 一、当你和过去的自己一起登台

想象这样一个场景：你站在台上演讲，灯光打在身上，台下几十上百双眼睛盯着你。你在当下即兴调整语气、停顿、眼神，甚至允许自己偶尔犯错、卡壳。这是“现在的你”。

但真正让这场演讲能够发生的，是几周前、几个月前，在某个完全不同的城市、不同的时间里，蹲在键盘前为这场演讲写大纲、改稿子的“过去的你”。那时你并不知道现场气氛会如何，只是反复推敲结构、比喻和例子。

这两个人——过去的你和现在的你——永远不会出现在同一个房间，却在共同完成同一件事：一场演讲。

它们之间有一个清晰的“时间切割”：

- 先有“剧本”：过去的你在安静的环境里打磨内容；
- 再有“表演”：现在的你在舞台上按剧本与现场互动。

剧本无法感知现场，却决定了故事的骨架；表演无法改写过去，却让故事真正与人相遇。

编剧与演员，作曲家与演奏者——以及，服务器与客户端，本质上都是这类关系。

一旦你用“剧本 + 表演 / 过去 + 现在”的视角去看，就会发现：很多我们以为是“两个程序在对话”的东西，其实更像是“一出被拆成两段执行的戏”。React 今天面对的许多问题，正是这个视角的自然延伸。

---

### 二、“React 跑两次”其实有两种含义

在进入两台计算机之前，先把一个常见的混淆说清楚：大家口中的“React 跑两次”至少包含两类现象：

1. **开发环境下 StrictMode 的双渲染**
   在 React 18+ 中，如果你在根组件使用了 `<React.StrictMode>`，开发模式下某些生命周期和渲染会被“刻意”调用两次，用来暴露不安全的副作用。这只发生在开发环境，不会影响线上性能。

2. **SSR + Hydration：服务器一次 + 客户端再一次**
   这是本文重点：同一套 React 组件既在服务器上跑一遍生成 HTML，又在客户端跑一遍，把事件监听和状态绑定到已有 DOM 上，这就是所谓的“水合（hydration）”。

本文主要讨论的，是第二种：**同一出戏在两台机器上分两次演完**。而服务器组件（React Server Components, 简称 RSC）是在这个基础上，进一步把“剧本部分”和“表演部分”拆得更细的机制。

---

### 三、从两个程序，到一出跨机器的戏：一只猫的故事

先从一个极普通的小例子开始：给猫起名字。

你做了一个网页，上面只有一个按钮：“揭示猫名（Reveal）”。点击按钮，就在页面中间显示一个随机猫名。

最原始的客户端版本，可能长这样（纯客户端 React，略去打包配置）：

```tsx | pure
// CatNameClient.tsx
import React, { useState } from 'react';

const CAT_NAMES = ['Mimi', 'Kuro', 'Snow', 'Tiger'];

export function CatNameClient() {
  const [name, setName] = useState<string | null>(null);

  function handleClick() {
    const index = Math.floor(Math.random() * CAT_NAMES.length);
    setName(CAT_NAMES[index]);
  }

  return (
    <div>
      <button onClick={handleClick}>Reveal</button>
      {name && <p>Cat name: {name}</p>}
    </div>
  );
}
```

一切都发生在浏览器里：数据在 bundle 中，随机逻辑也在浏览器中，点击按钮，瞬间有反馈。

直到你不想再硬编码。

你希望有一天，可以把猫名放进数据库，或某个文件，或者至少不要写死在客户端 bundle 里。于是，你做了一件几乎每个前端都做过的事：加一个 API。

```tsx | pure
// CatNameFetch.tsx - 纯客户端版本，通过 API 获取
import React, { useState } from 'react';

export function CatNameFetch() {
  const [name, setName] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  async function handleClick() {
    setLoading(true);
    try {
      const res = await fetch('/api/cat-names');
      const names: string[] = await res.json();
      const index = Math.floor(Math.random() * names.length);
      setName(names[index]);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div>
      <button onClick={handleClick} disabled={loading}>
        {loading ? 'Loading...' : 'Reveal'}
      </button>
      {name && <p>Cat name: {name}</p>}
    </div>
  );
}
```

- 网络好的时候，这和本地数组几乎一样；
- 一旦网慢，按钮从“瞬间响应”变成“点击后卡着等”；
- 如果加载页面后网络突然断了，你甚至连一个猫名都拿不到——明明 UI 已经渲染在眼前。

从客户端视角看，这似乎无解：**客户端没有数据，只能去请求；请求是异步的，只能等待。**

但如果你不再把“服务器”和“客户端”看成两段完全独立的程序，而是看成**同一个程序，在两台不同的计算机上分两步执行**，局面就松动了。

---

### 四、把状态“提升”到另一台计算机：SSR + 初始数据

在 React 里，“提升状态（lift state up）”是耳熟能详的模式：当多个组件需要共享同一份数据，你会把这份状态提升到更高层级，再通过 props 传下去。

现在，我们不把状态提升到父组件，而是**提升到父计算机**。

#### 4.1 SSR + `window.__INITIAL_DATA__` 的经典套路

在服务器上，你完全可以先把猫名列表读出来，再把它塞进返回的 HTML 中，让客户端一加载就拥有完整的数据。示意代码（Node.js + Express + React 18 SSR）：

```tsx | pure
// server.tsx (简化示意)
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { CatNameSSR } from './CatNameSSR';

const app = express();

const CAT_NAMES = ['Mimi', 'Kuro', 'Snow', 'Tiger'];

app.get('/', (_req, res) => {
  const initialData = { catNames: CAT_NAMES };

  const appHtml = renderToString(<CatNameSSR initialData={initialData} />);

  // 注意：生产中不要手写拼字符串，交给框架做转义
  const serialized = JSON.stringify(initialData).replace(/</g, '\\u003c');

  res.send(`
    <!DOCTYPE html>
    <html>
      <head><title>Cats</title></head>
      <body>
        <div id="root">${appHtml}</div>
        <script>
          window.__INITIAL_DATA__ = ${serialized};
        </script>
        <script src="/client.bundle.js"></script>
      </body>
    </html>
  `);
});

app.listen(3000);
```

客户端组件可以直接用这些数据，而不用再发一次请求：

```tsx | pure
// CatNameSSR.tsx
import React, { useState } from 'react';

type InitialData = {
  catNames: string[];
};

type Props = {
  initialData: InitialData;
};

export function CatNameSSR(props: Props) {
  const names =
    typeof window !== 'undefined' && (window as any).__INITIAL_DATA__
      ? (window as any).__INITIAL_DATA__.catNames
      : props.initialData.catNames;

  const [name, setName] = useState<string | null>(null);

  function handleClick() {
    const index = Math.floor(Math.random() * names.length);
    setName(names[index]);
  }

  return (
    <div>
      <button onClick={handleClick}>Reveal</button>
      {name && <p>Cat name: {name}</p>}
    </div>
  );
}
```

这样，**猫名数组只在服务器读取一次**，客户端拿到 HTML 时就已经“携带”了数据。按钮点击只在本地随机，不再有网络延迟。

#### 4.2 关于安全：不能随便往 HTML 里塞 JSON

上面的示例里有一行：

```ts
const serialized = JSON.stringify(initialData).replace(/</g, '\\u003c');
```

这不是多此一举，而是为了避免经典的 XSS 问题：

- 如果数据中包含用户输入，比如 `"</script><script>alert(1)</script>"`；
- 你直接 `JSON.stringify` 后拼进 `<script>`，浏览器会把 `</script>` 当成真正的标签结束符，从而“逃出”脚本字符串。

现实项目里：

- **不要自己手写这套转义逻辑**；
- 交给成熟框架（Next.js、Remix 等）或专门的序列化库处理；
- 文章用“JSON 门”的类比，是为了让你理解“只能传可序列化的数据”，而不是鼓励你在生产里手写拼字符串。

---

### 五、随机一次 vs 随机很多次：需求不要悄悄变了

到这里有一个容易被忽略的细节：**你的需求到底是什么？**

- 版本 A：“第一次点击 Reveal 时，给我一个随机猫名，之后就不变了。”
- 版本 B：“每次点击都要随机一个最新的猫名。”

之前的讲述里，如果你在服务器就随机出一个名字塞进 HTML，客户端按钮只是把这个已经选好的名字显示出来——这是**版本 A** 的需求。

而一开始的按钮大多是 **版本 B**：点击多次，每次都希望出现不同的名字。

对版本 B，一个更平衡的方案是：

- **在服务器上只做数据获取**：读出完整猫名数组；
- **在客户端做用户交互与随机**：每次点击从数组里随机。

这就是上面 SSR 示例实际做的事情：**把数组搬到客户端，而不是只搬一个结果值**。这样既避免每次点击都发请求，又保留了多次随机的能力。

---

### 六、“门”：只能传可序列化数据的窄通道

现在我们可以把这个模式抽象出来。

服务器和客户端之间，实际上有一扇非常窄的门：

- 门的两端是两台机器、两个运行时；
- 门只允许**可序列化的数据**通过——数字、字符串、布尔值、数组、普通对象；
- 门不允许直接通过函数、闭包、数据库连接、文件句柄、循环引用对象。

在上面的 `window.__INITIAL_DATA__` 例子中，我们手写了这样一扇门：

- 服务器端用 `JSON.stringify` 把对象变成字符串；
- 把字符串放到 HTML 里；
- 客户端再用 `JSON.parse` 还原。

在 React 服务器组件（RSC）里，这扇门被更“内建”地嵌入了组件模型：

- RSC 实际使用的是 React 自己定义的 **Flight 协议**，不是严格的 JSON，但**大体原则一样：**只能传可序列化的值；
- 你可以从服务器组件向客户端组件传 props，但这些 props 里面只能是“能过门的东西”。

为了讲清楚，我们下面继续用“JSON 门”的比喻，但请记住：**这是一个简化的心智模型，而不是底层实现细节。**

---

### 七、从模板到组件：RSC 到底帮你做了什么

仅仅靠字符串插值，我们已经可以实现“服务器上算好、客户端只表演”的模式。但手写模板很快会失控：

- 字符串里堆满 JS/HTML，语法高亮和类型支持都很差；
- 模块化和复用很难；
- 一旦逻辑复杂，文件极难维护。

React 服务器组件（RSC）试图回答的问题是：

> 有没有一种方式，既保留清晰的“物理边界”，又不牺牲现代组件生态（JSX、模块系统、类型检查）？

RSC 的答案是：

- 承认“服务器世界”和“客户端世界”是两套环境；
- 用组件来描述 UI 树；
- 用少数“带门的模块”连接这两套环境。

为了让这件事能运行在实际项目里，你通常需要：

- React 18+；
- 支持 RSC 的框架（目前主流是 Next.js App Router，部分框架处于实验阶段）；
- Node.js 18+ 或兼容的边缘运行时。

下面用一个 Next.js App Router 的例子，来看看“猫名按钮”在 RSC 下长什么样。

---

### 八、猫名按钮的 RSC 版本：服务端准备，客户端表演

#### 8.1 数据源：服务器世界

首先，假设你的数据在服务器上（可以是文件、数据库、远程 API），先写一个“只在服务器使用”的模块：

```ts
// lib/catNames.ts (运行在服务器环境)
export async function getCatNames(): Promise<string[]> {
  // 这里可以是真实的 DB 或远程 API
  // 示例里简单返回一个数组
  return ['Mimi', 'Kuro', 'Snow', 'Tiger'];
}
```

#### 8.2 服务器组件：拿到数据、搭好结构

在 Next.js `app/` 目录中的页面默认是**服务器组件**：

```tsx | pure
// app/page.tsx - 服务器组件
import { getCatNames } from '../lib/catNames';
import { RevealButton } from '../components/RevealButton';

export const dynamic = 'force-dynamic'; // 示例：确保每次请求都会运行（可按需配置）

export default async function Page() {
  const names = await getCatNames(); // 只在服务器运行

  return (
    <main>
      <h1>Cat Name Reveal</h1>
      <RevealButton names={names} />
    </main>
  );
}
```

这里发生了几件重要的事：

- `Page` 是服务器组件，只在服务器上运行；
- 它可以 `await getCatNames()`，直接访问服务器能力；
- 它把 `names` 作为 props 传给 `RevealButton`；
- `names` 通过 RSC 的传输协议被序列化后送往客户端。

#### 8.3 客户端组件：只负责交互和本地状态

`RevealButton` 是一个客户端组件，需要用 `'use client'` 显式标记：

```tsx | pure
// components/RevealButton.tsx - 客户端组件
'use client';

import { useState } from 'react';

type Props = {
  names: string[];
};

export function RevealButton({ names }: Props) {
  const [name, setName] = useState<string | null>(null);

  function handleClick() {
    const index = Math.floor(Math.random() * names.length);
    setName(names[index]);
  }

  return (
    <div>
      <button onClick={handleClick}>Reveal</button>
      {name && <p>Cat name: {name}</p>}
    </div>
  );
}
```

在这个 RSC 版本中：

- **数据获取（包括 IO 延迟）完全在服务器阶段完成；**
- 客户端拿到的只是一个已经准备好的 `string[]`；
- 每次点击只是本地随机，不需要再触网；
- 交互体验上接近“本地数组版本”，但数据的位置已经迁移到服务器。

#### 8.4 不只是“两层”，而是“服务器主干 + 多个客户端岛”

在上面的例子里，看起来像是“上面是服务器组件，下面是客户端组件”，好像只有两层。

但真实的 RSC 树更像：

- 一棵以服务器组件为主干的树；
- 在若干节点上长出**客户端子树（client islands）**；
- 每个 `'use client'` 组件都是一扇“门”，门内部分完全跑在浏览器，门外部分跑在服务器。

你可以在页面的多个部分插入独立的客户端组件，每个负责自己的交互区域，而不必把整个页面变成客户端组件。

---

### 九、性能与体验：什么时候该“提前算好”

把更多东西“搬到服务器”听起来很美好，但任何优化都是有代价的。

几个关键指标：

- **TTFB（首字节时间）**：服务器多久把第一个字节发出去；
- **FCP（首次内容绘制）**：用户多久看到第一屏内容；
- **TTI（可交互时间）**：多久可以正常点击、输入、滚动。

简单地说：

- 在服务器上提前算好数据（SSR / RSC），通常有利于**降低 FCP**（用户更快看到内容）；
- 但如果计算特别重或数据量巨大，可能会提升 **TTFB**，反而拖慢整体首屏；
- 客户端 JS 过大则会拖慢 **TTI**，RSC 尝试通过把数据和一部分逻辑留在服务器，减少发送到浏览器的 JS 体积。

可以粗略给出一些经验：

- **适合放到服务器的逻辑：**

  - 访问数据库、内部服务、文件系统；
  - 大量数据聚合和过滤（列表、报表的预处理）；
  - 与用户即时输入无关、但影响首屏内容的部分（例如推荐列表、初始筛选结果）。

- **适合放到客户端的逻辑：**
  - 依赖 DOM 或浏览器 API（事件、动画、滚动）；
  - 高频、低延迟的交互（输入法、拖拽、标记、即时过滤）；
  - 只和当前用户会话相关、不需要参与服务端数据聚合的状态。

RSC 的价值，不在于“万能地更快”，而在于让你有一个更清晰的工具，把这些决策变得**显式、可组合**。

---

### 十、两阶段思维的落地清单

当你设计一个 React 应用（尤其是在 Next.js 等支持 RSC 的框架里）时，可以用下面这份“小检查表”来决定代码放在哪一侧：

1. **这段逻辑依赖浏览器能力吗？**

   - 需要 DOM、事件、动画、`window`、`document`？
     → 放客户端组件，`'use client'`。

2. **这段逻辑只依赖数据源 / 业务服务吗？**

   - 只需要 DB / 内部 API / 配置文件？
     → 尽量放服务器组件或服务器函数。

3. **这段逻辑的输入频率如何？**

   - 用户每敲一个字都要触发？
     - 搜索建议：可以客户端先做本地过滤，在“停顿一小会儿之后”再发服务器请求；
   - 偶尔触发，比如提交表单、保存设置？
     - 交给服务器，甚至用 Server Actions 处理。

4. **数据量有多大，对客户端性能的影响如何？**
   - 大列表、复杂聚合：服务器预处理、分页、只送当前可见的片段；
   - 小数据、但需要频繁更新：倾向客户端管理状态。

用猫名按钮举几个变形例子：

- **搜索框**：

  - 服务器预先把热门搜索词 list 作为 props 下发；
  - 客户端在本地做模糊匹配，节省网络；
  - 用户停顿一段时间后再发服务器请求补充更准确结果。

- **表单提交**：

  - 初始表单配置（选项、默认值）在服务器生成，客户端只负责校验和提交；
  - 提交时调用服务器 Action 或 API 完成写入；
  - 成功后服务器重新渲染部分组件（在 RSC 下是常见模式）。

- **列表分页**：
  - 首屏列表由服务器渲染，减少白屏；
  - 用户滚动加载下一页时，可以由客户端调用服务器接口，按需追加。

---

### 十一、写给未来的自己：学会用两阶段看世界

回到一开始的比喻：过去写稿的你，和现在登台的你，之间隔着时间、空间，以及生活中所有无法预知的变量。你不能在写稿时完全预测现场，也不能在台上完全改写稿子。但正是这两者的配合，构成了一场真正完整的演讲。

在前端世界里，我们很久以来只盯着客户端这一幕：如何让交互顺滑、状态管理清晰、组件拆分合理。偶尔会抬头看看服务器，把它视作一个“提供数据的后端”，在 REST API 或 GraphQL 的层面上谈“契约”和“抽象”。

而“两台计算机的一出戏”这个视角提醒我们：这并不是两个互相喊话的独立程序，而是一个被物理世界硬生生切开的整体。

- 第一阶段的任务，是用服务器那台机器上更靠近数据、更稳定的环境，把能做的准备工作尽量做完；
- 第二阶段的任务，是用客户端那台机器上更靠近用户、更敏捷的环境，把这出戏真正演完。

React 的“跑两次”，本质上正是承认并利用了这个切割：

- 一方面，在 SSR + Hydration 下，同一棵组件树在**服务器**跑一遍生成初始 HTML，再在**客户端**跑一遍接管交互；
- 另一方面，在 RSC 模型中，组件本身就被分成“剧本部分”（服务器组件）和“表演部分”（客户端组件），用那道只能传可序列化数据的“门”连接起来。

从这个意义上说，服务器组件不只是一个“优化方案”，而是一种新的思维方式：

- 不再执着于“所有东西都在浏览器跑”；
- 不再满足于模糊的“服务端渲染 + 客户端水合”的口号；
- 而是认真对待那道无法绕开的物理边界，用组件与 props 的语言，在代码层面雕刻出一扇清晰的门。

也许真正值得我们带走的，不只是 API 的细节，而是这个更普适的心智模型：

- 在任何需要跨越时空、跨越系统的地方，都去寻找那两阶段的结构：
  过去的准备和现在的演出，服务器的第一幕和客户端的第二幕，编剧的剧本和演员的表演；
- 然后耐心地去找那道门：那条窄而牢固的通道，决定了什么可以跨越边界，什么必须留在原地。

当你开始用这样的眼光看待系统时，“React 跑两次”就不再是一句抱怨，而是一句描述现实物理的陈述：**同一出戏，在两台不同的机器上，分两次被演完。**

重要的不是它“跑了几次”，而是：

> 你是否真的理解了，这出戏究竟是如何被拆开，又如何在观众面前重新合上的。
