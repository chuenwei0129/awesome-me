---
group:
  title: javaScript
  order: 3
title: JavaScript 浮点数与 IEEE 754：精度丢失、安全整数和 Number API
toc: content
order: 3
---

## 一、从小数点到浮点数：为什么需要 IEEE 754

### 1. 小数点本质上是“对齐规则”

**小数点在数制中代表一种对齐方式**。

要直观比较 `1000` 和 `200` 的大小，我们可以把它们右对齐：

```text
1000
0200
```

从左到右比较，`1` 比 `0` 大，所以 `1000` 更大。

那如果是比较 `1000` 和 `200.01` 呢？需要先把小数点对齐：

```text
1000.00
0200.01
```

**小数点的位置在进制表示中至关重要，位置差一位，数值大小就差一个进制倍**（十进制就是十倍）。

在计算机中也是这样，只不过用的是二进制。在做加减、比较时，必须先“对齐小数点”，才能复用整数加法的逻辑。

处理小数点位置有两大类做法：

- **定点数（fixed-point）**：小数点位置预先约定好，不会变；
- **浮点数（floating-point）**：小数点位置可以随指数变化“浮动”。

---

### 2. 定点数：小数点写死的世界

**定点数，就是小数点永远在固定的位置上。**

比如我们约定一种 32 位无符号定点数，小数点永远在第 5 位二进制数后面：

- 整数部分：5 位
- 小数部分：27 位

它能表示的最大值是 `11111.111111111111111111111111111`（二进制）：

- 整数部分 `11111₂` 是 $2^5 - 1 = 31$
- 小数部分是 27 个 1，其值为 $1 - 2^{-27}$
- 最大值 = $31 + (1 - 2^{-27}) = \mathbf{32 - 2^{-27}}$，一个**非常接近但小于 32 的数**
- 最小非零值是 $2^{-27}$

**定点数可以看作是“小数点预设好位置”的数，整数可以视为小数点“永远在末尾”。**

优点：

- 实现简单，大部分运算和整数类似

缺点：

- **绝对精度是固定的**（这里是 $2^{-27}$）
- 动态范围很小：既想表示很大数又想表示非常小的数时，空间浪费严重

这就是为什么需要“让小数点会动”的浮点数。

---

### 3. 浮点数：把科学记数法搬进计算机

浮点数的核心思想就是“科学记数法”：

![20251117173008](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/awesome-me/20251117173008.png)

在计算机里：

- **尾数**（significand / fraction / mantissa）：有效数字部分
- **指数**（exponent）：决定整体的量级（小数点“往左/往右挪多少位”）
- **基数**：对二进制来说是 2

指数可以改变小数点的实际位置，使其“浮动”，因此叫浮点数。

在计算机科学中，浮点是一种对实数的近似表示方式，可以简单理解为：

> **浮点数 ≈ “科学计数法”在二进制上的实现 + 固定位宽 + 特殊编码（NaN / Infinity / Subnormal）+ 舍入规则。**

有了“定点 vs 浮点”的直觉之后，接下来我们先用 32 位浮点数（单精度）举一个完整的例子，看一眼“浮点数在内存中的真实模样”。

> JavaScript 实际上使用的是 64 位双精度浮点数（double），结构和单精度完全同构：只是指数位和尾数位更多。理解了 32 位的例子，再把字段位数替换一下，就能自然迁移到 JS 中的 Number。

---

## 二、IEEE 754 浮点数长什么样（以 32 位为例）

完整讲 IEEE 754 之前，先看一个具体例子：
**如何用 32 位浮点数存储 `20.25`**。

在内存或硬盘中，32 位浮点数占用 32 个二进制位：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-32e425cdb908c47586267e59228fcd22_1440w.png)

这 32 个二进制位从高到低（从 bit 31 到 bit 0），分成 3 部分：

- **sign**：符号位（1 bit）
- **biased exponent**：偏移指数位（8 bit）
- **fraction**：尾数位（23 bit）

---

### 步骤 1：把 20.25 转成二进制

把整数和小数部分分别处理：

**整数部分 20 转二进制：**

```text
20 / 2 = 10  ... 0
10 / 2 = 5   ... 0
5  / 2 = 2   ... 1
2  / 2 = 1   ... 0
1  / 2 = 0   ... 1
```

从下往上读：`10100`

**小数部分 0.25 转二进制：**

```text
0.25 * 2 = 0.5  ... 0
0.5  * 2 = 1    ... 1
```

从上往下读：`01`

**合并整数和小数部分：**

```text
20.25₁₀ = 10100.01₂
```

---

### 步骤 2：转成二进制“科学计数法”

把 `10100.01₂` 写成 `1.xxxx × 2ⁿ` 的形式：

$10100.01_2 = 1.010001_2 \times 2^4$

- 尾数部分（规范化后）：`1.010001₂`
- 指数：`4`

---

### 步骤 3：确定符号位

20.25 是正数，所以符号位 `sign = 0`。

---

### 步骤 4：计算指数位（带偏移）

IEEE 754 单精度（32 位）：

- 指数位宽：8 bit
- 指数偏移量（bias）：127

这里指数是 4：

- 实际存储的指数值 = 4 + 127 = 131
- 131 的二进制是 `10000011₂`

所以：

```text
biased exponent = 1000 0011
```

---

### 步骤 5：计算尾数位

尾数只存储**小数部分**，规范化后首位 `1` 不显式存储（隐含 1）。

- 规范化尾数：`1.010001`
- 去掉整数部分的 `1` → `010001`
- 填充 0 到 23 位：`01000100000000000000000`

---

**小结：组合成 32 位浮点数**

三部分如下：

- 符号位：`0`
- 指数位：`1000 0011`
- 尾数位：`0100 0100 0000 0000 0000 000`

合在一起：

```text
0 1000 0011 0100 0100 0000 0000 0000 000
```

你可以用这个在线工具验证：[浮点数转二进制工具](https://tooltt.com/floatconverter/)

---

### 反向推导一次

从 `0 1000 0011 0100 0100 0000 0000 0000 000` 还原成十进制：

1. 符号位为 `0` → 正数
2. 指数位 `1000 0011₂` = 131 → 实际指数 = 131 - 127 = 4
3. 尾数位存的是 `0100 0100 0000 0000 0000 000`
   - 加上隐含 `1` → `1.010001₂`
4. 所以值为：

   $1.010001 \times 2^4 = 10100.01_2 = 20.25_{10}$

到这里，你已经看到浮点数在内存中的真实样子。

---

**补充阅读：**

> - [从科学记数法到浮点数标准 IEEE 754](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)
> - [IEEE754 标准：浮点数在内存中的存储方式](https://zhuanlan.zhihu.com/p/343033661)

**JavaScript 使用的双精度浮点数结构：**

> - 总位数：64 bit
> - 1 位符号位 sign
> - 11 位指数位 exponent（偏移量 bias = 1023）
> - 52 位尾数位 fraction（加上隐含的最高位 1，总共 53 位有效二进制位）
>
> 这 53 位有效位正是"安全整数范围"和"约 15~17 位十进制有效数字"的根源，后文会展开。

---

## 三、“储物柜模型”：浮点数精度的本质

### 1. 故事从一个“储物柜”开始

想象有一台神奇的计算机，它的内存只有一个限制：**总共只能记住 100 个不同的数字**。我们用这 100 个“储物柜”来表示某个数值范围。

#### 场景一：表示 0 到 100 之间的数值

用同样 100 个储物柜表示 `[0, 100)`：

- 范围长度：100
- 储物柜数量：100
- 每格间隔：100 / 100 = **1**

可精确表示的数是：

```text
0, 1, 2, ..., 99
```

所有整数都可以完美表示，没有精度问题。

#### 场景二：表示 0 到 10 之间的数值

要表示 `[0, 10)`：

- 范围长度：10
- 储物柜数量：100
- 每个柜子之间的间隔：10 / 100 = **0.1**

可精确表示的数是：

```text
0.0, 0.1, 0.2, ..., 9.9
```

如果要存 `0.15` 呢？它正好在 `0.1` 和 `0.2` 的中间，没有对应储物柜，只能舍入到其中一个。

> **精度丢失的本质：** 真实值无法落在离散刻度上，只能被舍入到最近的刻度。

#### 场景三：表示 0 到 1000 之间的数值

用 100 个储物柜表示 `[0, 1000)`：

- 范围长度：1000
- 储物柜数量：100
- 每格间隔：1000 / 100 = **10**

可精确表示的数是：

```text
0, 10, 20, 30, ..., 990
```

想存 `25` 怎么办？也没有对应刻度，只能舍入到 `20` 或 `30`。这时连一些"小整数"都失真了。

> **当需要覆盖更大范围时，** 在储物柜数目有限的前提下，每格的"粒度"就不得不变粗，导致整数也可能无法精确表示。

这个简化模型就是浮点数在不同范围下精度变化的本质。

### 2. 小数精度：连续 vs 离散

数学是一门抽象的学科，而计算机会面临具体的实现。我们的浮点数标准就是在做这样一件事：**建立计算机中存储的一个零一序列到抽象数学中的一个数字的一对一的映射**。

而这里有一个无法解决的问题：

- **数学中任意小段连续的数轴中的小数是无限多的**；
- 这意味着要一对一映射，需要无限个互不相同的二进制序列。

极端一点，计算机甚至无法存储 1 到 2 之间的某一个小数，比如：

> 1.00000.....（此处省略一万亿个 0）.....00001

不过计算机却能存储 [0, 100) 之间的所有整数。因为整数是“离散”的，[0,100) 之间的整数只有 100 个。

计算机为了进行小数运算，不得不将小数也当成“离散”的值，一个一个的，就像整数那样：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-886f0c2a7559e2cd66ab4d4c917a7a95_1440w.png)

- 数学中的整数是一个一个的，绿色指针一次走一格
- 数学中的小数是连续的，绿色指针可以无极调节，想走到哪儿走到哪儿
- 计算机中存储的小数是一个一个的，绿色指针必须一次走一格，就像整数那样

这就引发了精度的问题，比如上图中，我们无法在计算机中存储 0.3，因为绿色指针只能一次走一格，要么在 0.234，要么就到了 0.468...

当然，我们也可以增加计算机存储小数的**精度**，或者说缩小点与点之间的间隔：

![20240321150005](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240321150005.png)

32 位浮点数会形成一个“表盘”，表盘上的蓝点逐渐稀疏。绿色指针只能指向某个蓝点，不能指向两个蓝点之间的位置。或者换句话说：**32 位浮点数只能保存蓝点对应的值**。

**如果你要保存的值不是蓝点对应的值，就会被自动舍入到离该数最近的蓝点对应的值**。

举例：

在 `0.5 ~ 1` 这个范围内，相邻可表示值的间隔是 `2^-24`，数值上大约是 `5.960464477539063e-8`（常近似为 `5.96046e-8`）：

![20240321151614](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240321151614.png)

也就是说：表盘上有一个蓝点是 `0.5`，即数学值 0.5 是可存储在计算机中的。

下一个蓝点应该是：

```text
当前蓝点 + 间隔
≈ 0.5 + 0.00000005960464477539063
≈ 0.5000000596046448
```

那，如果我们要保存 **0.50000006** 呢？这个值略大于下一个蓝点：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-6a03627668b34c78ff9452fe6df42ccb_1440w.png)

因为绿色指针必须指向蓝点，不能指向蓝点之间的位置，所以绿色指针会被“校准”到 **0.5000000596046...**，也就是说，我们要保存的 **0.50000006** 会被**舍入**为该蓝点对应的值。

事实上，每个 32 位浮点数容器中，存储的必然是一个蓝点值。

打开 IEEE754 的维基百科，可以看到其中标注着，单精度浮点数的精度是“**大约 7 位十进制数**”。这里的含义是：**能保证无歧义表示的十进制有效数字数量约为 7 位**，而不是“总共只能表示 7 位十进制数”。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-28e38af53fd59e0cfc058667e97bc4b0_1440w.png)

---

### 3. 大整数精度：为什么会有“安全整数”上限

> 引用自：[JavaScript 里最大的安全的整数为什么是 2 的 53 次方减一？](https://www.zhihu.com/question/29010688)
>
> **“安全”** 的意思是说能够 **one‑by‑one** 表示的整数，也就是说在某个范围内，_双精度数表示和整数是一对一的_，反过来说，**在这个范围以内，所有的整数都有唯一的浮点数表示，这叫做安全整数**。
>
> 而超过这个范围，会有两个或更多整数的双精度表示是相同的；反过来说，超过这个范围，有的整数是无法精确表示的，只能 `round` 到与它相近的浮点数表示，这种情况下叫做不安全整数。
>
> **注意事项**：在解析序列化的 JSON 时，超出此范围的整数值可能会被破坏。在工作中使用字符串类型代替，是一个可行的解决方案。

![20240321160618](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240321160618.png)

在双精度浮点（Number）里：

- 尾数是 52 位显式 + 1 位隐含 = 53 位有效二进制位；
- 在整数区域内，可以保证从 `-(2^53 - 1)` 到 `2^53 - 1` 之间的每一个整数都有唯一的浮点表示。

超过这个量级后，相邻可表示值的间隔（ULP）大于 1，导致**相邻整数无法都一一落在蓝点上**，于是就出现“不安全整数”。

小结一下“储物柜模型”给我们的两个重要认识：

1. 在固定的“指数区间”里，刻度间距（ULP）是固定的：
   - 区间越小，可以塞进去的刻度就越密；
   - 区间越大，每一格的间距就不得不变大。
2. 当区间足够小的时候，**整数之间可以逐个“占一个格子”**，所有整数都能被一一表示；
   当区间继续变大，最终会出现“**两个相邻整数落不到两个不同格子上**”的情况。

在 JavaScript 的 double 里，`[-(2^53 - 1), 2^53 - 1]` 恰好是这样一个区间：
在这个范围内，每一个整数都有唯一的储物柜（浮点表示）。
这就是“安全整数”概念的来源，下一节我们就把它具体映射到 JS 的 API 和典型坑上。

---

## 四、JavaScript 中的安全整数与典型坑

### 1. 安全整数：哪些整数可以“一对一”表示？

在 JS 中，有两个重要常量：

```js
Number.MAX_SAFE_INTEGER === 2 ** 53 - 1; // 9007199254740991
Number.MIN_SAFE_INTEGER === -(2 ** 53 - 1);
```

在这个闭区间内：

$[-(2^{53} - 1),\ 2^{53} - 1]$

> **每一个整数都有唯一的双精度浮点表示（one‑by‑one 映射）。**

也就是说，在这个范围内，整数和 Number 是“一一对应”的，叫做**安全整数**。

超过这个范围会发生什么？

- 会有不同整数“挤在同一个储物柜里”
- 有些整数无法精确表示，只能 round 到某个邻近的浮点数
- 结果就是：自增、自减、取模、JSON 解析等操作都可能出现不可预期行为

---

### 2. 无限循环的示例：`testPrecisionLoss`

```js
function testPrecisionLoss() {
  let num = 2 ** 53;
  while (true) {
    if (++num % 13 === 0) {
      return num;
    }
  }
}
```

先看一个现象：

```js
2 ** 53 === 2 ** 53 + 1; // true
```

在 double 中，当数值足够大时，相邻可表示值的距离（ULP）会大于 1。此时从数学上看 `num + 1` 是下一个整数，但这个整数落在了两个浮点刻度之间，舍入后仍然回到 `num` 自身，也就是：`++num` 不再改变值。

为什么上面的函数会无限循环？

- 当 `num` 达到某个巨大值时，`++num` 在双精度下**不再改变数值**（卡在某个蓝点上）
- 对 JS 引擎来说，`num` 已经“卡”在某个离散刻度上，自增到下一个整数在数轴上的距离太小，落不到下一个浮点刻度
- 所以 `++num` 后 `num` 实际不变，`% 13` 的结果永远一样 ⇒ 无限循环

这就是“大整数精度丢失”的直接后果。

---

### 3. JSON 解析时的大整数截断

```js
JSON.parse('{"a":180143985094813214124}');
// 实际结果：{ a: 180143985094813220000 }
```

这个数远远大于 `Number.MAX_SAFE_INTEGER`，
在解析为 JS Number 时：

- 被迫舍入到最近的可表示双精度数
- 导致尾部多位完全错误

> **注意：在解析/序列化 JSON 时，如果需要传输大整数，应该使用字符串或 BigInt。**

例如：

```json
{
  "id": "180143985094813214124"
}
```

在 JS 中：

```js
const obj = JSON.parse(jsonStr);
// obj.id 是字符串，需要时可用 BigInt：BigInt(obj.id)
```

---

## 五、JS Number 的数值边界、舍入规则与特殊值

在 JS 中，看起来是整数的 37 和写成 37.0 的小数本质上是同一个值，同一个类型。

- ECMAScript 规定：所有 `Number` 都是 **IEEE 754 双精度浮点数（64 位）**。
- 没有 `int`、`float` 这种类型区分，只有一个 `Number`。
- 只要小数部分为 0、且在安全范围内，就被当作“整数”对待。

如果你需要真正的“整数类型”（特别是大整数）：

- 使用 `BigInt`：`1n`、`2n`（注意 `typeof 1n === 'bigint'`，并不遵循 IEEE 754）；
- 或用字符串传递、存储，再按需转为 `BigInt`。

这一节把 JS 中与 IEEE 754 相关的核心性质集中说一下，方便在实战中查阅。

---

### 1. 与“范围”相关的常量

#### 1.1 最大有限值：`Number.MAX_VALUE`

```js
Number.MAX_VALUE; // 1.7976931348623157e+308
```

含义：

- **JS 中可表示的最大有限正数**
- 再大就会变成 `Infinity`：

```js
Number.MAX_VALUE * 2; // Infinity
```

可以类比为“浮点数的右边界”。

---

#### 1.2 最小正非零值：`Number.MIN_VALUE`

```js
Number.MIN_VALUE; // 5e-324
```

含义：

- “**大于 0 的最小正数**”，是一个非常接近 0 的正数
- 注意：它**不是**「最小负数」，也不是「最小整数」

```js
Number.MIN_VALUE > 0; // true
-Number.MIN_VALUE < 0; // true
Number.MIN_SAFE_INTEGER; // 最小安全整数，完全不同概念
```

在 IEEE 754 双精度中：

- 最小规格化正数是 `2^-1022 ≈ 2.225074e-308`
- `Number.MIN_VALUE` 对应的是 **最小正非零数**，是 **非规格数（subnormal）区的最小值** `2^-1074 ≈ 5e-324`
- 再小（绝对值更小）的结果会被舍入为 `0`

---

#### 1.3 安全整数范围：`MAX_SAFE_INTEGER` / `MIN_SAFE_INTEGER`

```js
Number.MAX_SAFE_INTEGER; // 9007199254740991 === 2 ** 53 - 1
Number.MIN_SAFE_INTEGER; // -9007199254740991 === -(2 ** 53 - 1)
```

含义：

- 在这个闭区间内，**每个整数都有唯一的双精度浮点表示：**
  - "整数 ↔ Number" 是一对一的
- 超出这个范围就会出现：
  - 不同整数被映射到同一个 Number
  - 自增、自减可能不再改变值
  - 取模、JSON 解析等操作结果异常

经验规则：

> 所有可能超过 `MAX_SAFE_INTEGER` 的整数字段，都不要直接用 Number 存。

---

### 2. 与“精度”相关的常量：`Number.EPSILON`

```js
Number.EPSILON; // 2.220446049250313e-16
```

含义（在 1 附近）：

- 1 和大于 1 的**下一个可表示双精度浮点数**之间的差值
- 即：`1 + Number.EPSILON !== 1` 但 `1 + Number.EPSILON / 2 === 1`

```js
1 + Number.EPSILON === 1; // false
1 + Number.EPSILON / 2 === 1; // true
```

它常被用来做“误差范围内比较”：

```js
function nearlyEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) <= epsilon;
}

nearlyEqual(0.1 + 0.2, 0.3); // true
0.1 + 0.2 === 0.3; // false
```

注意：

- `EPSILON` 是在 **1 附近** 的间隔大小；
- 数值越大，相邻可表示数的间隔（ULP）也越大
  → 这和前面讲的“指数决定区间、尾数线性填充”的储物柜模型完全一致：指数越大，同一区间能塞的刻度越少。

---

### 3. 浮点数的舍入规则：round to nearest, ties to even

JavaScript 的 Number 运算遵循 IEEE 754 默认舍入模式：

> **round to nearest, ties to even**
> 向最近的可表示值舍入；
> 如果刚好在两个值正中间（tie），选尾数最低位为偶数的那个。

#### 3.1 “最近”是什么意思？

浮点数的世界不是连续的，而是一条离散刻度尺。
在某个指数区间内，相邻的两个可表示值间有固定间隔（ULP）。

类比：

- 如果我们规定“十进制只保留 1 位小数”，刻度是：
  ```text
  ..., 1.1, 1.2, 1.3, 1.4, ...
  ```
  相邻刻度间隔是 0.1。

真实的 IEEE 754 是二进制世界：

- 刻度是类似 $(某个尾数) × 2^\text{指数}$ 的形式；
- 一旦指数固定，相邻两个尾数对应的间隔就是固定的 ULP。

“向最近的舍入”就是：

- 更靠近下面那一格 ⇒ 向下舍；
- 更靠近上面那一格 ⇒ 向上舍。

---

#### 3.2 什么是 tie（中点）？

还有一种尴尬情况：

> 真实结果刚好在两个可表示值的正中间。

这时上下距离一样远，就是 **tie**。

类比“只保留一位十进制小数”的世界：

- 刻度：1.2 和 1.3
- 中点：1.25
- 1.25 离 1.2 和 1.3 的距离都为 0.05 ⇒ tie

二进制世界也是类似，只不过表现为某位 bit 之后是 `1000...0` 这种“正好一半”的情况。

---

#### 3.3 ties to even：为什么要“选偶数”？

如果在 tie 时总是向上，会有系统性偏差（整体偏大）。

IEEE 754 的选择是：

> 当在中点上时，在上下两个候选值中，
> **选尾数最低有效位（LSB）为 0 的那个（对应偶数）。**

简化的二进制例子（为了说明规则，本例位宽是虚构的）：

- 假设只保留两位小数（二进制）：`xx.yy`
- 相邻刻度：`10.10₂` (2.5) 和 `10.11₂` (2.75)
- 中点：`10.101₂` (2.625)

原数正好是 `10.101₂`：

- 候选 1：`10.10₂`，最低位 bit = 0（偶数）
- 候选 2：`10.11₂`，最低位 bit = 1（奇数）
- ties to even ⇒ 选 `10.10₂`（2.5）

这么做的好处是：大量运算累积时，整体偏差倾向被削弱。

---

#### 3.4 现实体现：`(1.005).toFixed(2) === '1.00'`

```js
(1.2345).toFixed(2); // '1.23'
(1.2355).toFixed(2); // '1.24'
(1.005).toFixed(2); // '1.00'
```

很多人会以为 `toFixed` 舍入错了。实际上：

- 十进制字面量 `1.005` 并不能被 double 精确表示，存储的是一个略偏离 1.005 的值；
- 在“保留两位小数”的视角下，它更接近 `1.00` 而不是 `1.01`；
- 配合 round‑to‑nearest, ties‑to‑even，最终结果是 `'1.00'`。

需要强调的是：

> 这里说的 **"四舍五入"** 并不是日常意义上的"0.5 一律进位"，而是 **round to nearest, ties to even**。

另外需要记住：浮点运算在数学上不再完美遵循加法的交换律/结合律：

- `(a + b) + c` 可能不等于 `a + (b + c)`
- 在溢出或舍入边界上，`a + b` 与 `b + a` 的舍入结果也可能不同

这是由“有限精度 + 舍入规则”共同导致的。

---

### 4. 特殊值：非规格数、±0、±Infinity 和 NaN

IEEE 754 除了“普通”浮点数，还有一些特殊编码：

- **非规格数（Subnormal / Denormal）**
- **正零和负零：+0 和 -0**
- **正无穷和负无穷：+Infinity 和 -Infinity**
- **NaN（Not‑a‑Number）**

---

#### 4.1 非规格数（Subnormal）

当指数最小（全 0）、尾数非 0 时，就进入“非规格数”区：

- 用来表示**非常接近 0 的极小值**
- 这样可以避免从最小规格化数直接跳到 0 的“精度断崖”

它保证了浮点数在接近 0 的地方也有一段“渐进”的数值范围。
`Number.MIN_VALUE` 就是这一段中的最小正数。

---

#### 4.2 ±0：为什么有两个零？

在 IEEE 754 中：

- +0 和 -0 有不同的 bit 模式（符号位不同）
- 但在大部分比较里，`+0 === -0` 为 true

区别只在某些运算里暴露，比如：

```js
1 / 0; // Infinity
1 / -0; // -Infinity

Object.is(+0, -0); // false
```

---

#### 4.3 ±Infinity：溢出/除零的结果

当运算结果超出可表示范围，或除以 0 时，会得到 Infinity 或 -Infinity：

```js
1 / 0; // Infinity
-1 / 0; // -Infinity
Math.pow(2, 1024); // Infinity（溢出）
```

Infinity 本身仍然是一个合法的 Number，参与比较和运算有自己的规则。

> 在传统整数算术或数学教材中，“除以 0”是未定义的；
> 在遵循 IEEE 754 的浮点数运算里，`1 / 0` 得到 `+Infinity`，`1 / -0` 得到 `-Infinity`。

---

#### 4.4 NaN：不是一个合法数字结果

当运算结果根本“不像一个数”时，就会得到 NaN，例如：

```js
0 / 0; // NaN
Infinity - Infinity; // NaN
Math.sqrt(-1); // NaN
parseInt('abc', 10); // NaN
```

需要注意：

- NaN 在比特层面有很多种不同表示（**远不止 1 个**）
- 但 JS 层面看只有一个 `NaN` 常量
- NaN 不等于任何东西，包括自己：

```js
NaN === NaN; // false
Number.isNaN(NaN); // true
Number.isNaN('abc'); // false
isNaN('abc'); // true（全局 isNaN 会做隐式转换）
```

---

### 5. 和 Infinity / NaN 相关的 Number 常量

```js
Number.POSITIVE_INFINITY; // Infinity
Number.NEGATIVE_INFINITY; // -Infinity
Number.NaN; // NaN
```

它们分别是：

- 正无穷：`Number.POSITIVE_INFINITY`（等价于全局的 `Infinity`）
- 负无穷：`Number.NEGATIVE_INFINITY`
- 非数值结果：`Number.NaN`（等价于全局的 `NaN`）

你可以在代码中用这些常量来强调语义，例如：

```js
if (result === Number.POSITIVE_INFINITY) {
  // 溢出，或者除以 0 的结果
}

if (Number.isNaN(result)) {
  // 运算无意义或非法输入
}
```

---

## 六、附录：JavaScript 中 Number 相关 API 速查

前面讲的是 Number 的“底层特性”，这节集中说一说日常最常用、也最容易坑到人的几个 API：
**数字 → 字符串**（`toString` / `toFixed` / `toPrecision` 等），和**字符串 → Number**（`Number` / `parseInt` / `parseFloat`）。

> 如果你只想知道：怎么把 Number 和字符串互转，以及哪里会踩雷，可以把这一节当“速查表”来用。

---

### 1. 数字转字符串相关方法

#### 1.1 `Number.prototype.toString(radix)`

```js
(255).toString(); // '255'   默认 10 进制
(255).toString(16); // 'ff'    十六进制
(10).toString(2); // '1010'  二进制
(10).toString(8); // '12'    八进制
(10).toString(36); // 'a'     36 进制
```

要点：

- `radix` 取值范围是 `2 ~ 36`，不传时默认 10
- 非整数也可以转，不过小数部分只是把当前 double 表示“翻译”为字符串，会暴露浮点误差：

```js
(0.1).toString(); // '0.1'
(0.1 + 0.2).toString(); // '0.30000000000000004'
```

---

#### 1.2 `toFixed(digits)`：保留小数位数

```js
(1.2345).toFixed(2); // '1.23'
(1.2355).toFixed(2); // '1.24'
(1.005).toFixed(2); // '1.00'
```

特点：

- 以**字符串形式**返回，保留 `digits` 位小数
- 会进行四舍五入，但实质上遵循 IEEE 754 的 **round to nearest, ties to even**

**重要提醒：和浮点误差会叠加。**

```js
(1.005).toFixed(2); // '1.00'
Number((1.005).toFixed(2)); // 1
```

并不是 `toFixed` 算错，而是 `1.005` 存储本身不能精确表示，导致更靠近 `1.00`。

实战建议（尤其金额/计费场景）：

- 不要直接依赖 `toFixed` 做精度控制；
- 更稳妥的方案：
  - 全程用整数（分/厘等）运算，然后在显示时格式化；
  - 或使用十进制高精度库（如 `decimal.js` / `big.js`）。

比如金额统一用"分"存储：

```js
// 金额统一用「分」存储和计算
const price = 1999; // 19.99 元 -> 1999 分
const count = 3;
const totalInCents = price * count; // 整数乘法，安全可靠

// 展示时再格式化
function formatCNY(cents) {
  return (cents / 100).toFixed(2);
}

formatCNY(totalInCents); // '59.97'
```

---

#### 1.3 `toPrecision(precision)`：保留有效数字

```js
(123.456).toPrecision(3); // '123'
(123.456).toPrecision(4); // '123.5'
(0.00123456).toPrecision(3); // '0.00123'
(0.1).toPrecision(17); // '0.10000000000000001'
```

特点：

- 控制的是“**有效数字总数**”，而不是小数位数
- 返回值是字符串，有时会自动切换成科学计数法

容易误解的点：

- `(0.1).toPrecision(17)` 得到 `'0.10000000000000001'`，是把 double 内部真实值尽量精确打印出来的结果，**正是浮点误差的体现**。

---

#### 1.4 `toExponential(fractionDigits)`：科学计数法

```js
(123456).toExponential(); // '1.23456e+5'
(123456).toExponential(2); // '1.23e+5'
(0.0000123).toExponential(2); // '1.23e-5'
```

特点：

- 总是用科学计数法表示
- `fractionDigits`：小数部分保留的位数（即指数前的小数位）

主要用于：

- 展示非常大或非常小的数
- 调试浮点数时看它的量级和有效数字

---

### 2. 字符串转 Number 的方法

#### 2.1 `Number(value)`：整体尝试转换

```js
Number('123'); // 123
Number('123.45'); // 123.45
Number('  0010  '); // 10
Number('0b1010'); // 10  二进制字面量形式
Number(''); // 0
Number('abc'); // NaN
Number(null); // 0
Number(undefined); // NaN
```

特点：

- 尝试将**整个字符串**当作一个数来解析；无法解析则返回 `NaN`
- 会处理前后空白；中间不能有非数值字符

对比 `parseInt` / `parseFloat`：

- `Number('123abc')` → `NaN`
- `parseInt('123abc', 10)` → `123`（能解析就解析一段）

---

#### 2.2 `parseInt(string, radix)`：按进制解析整数

```js
parseInt('123', 10); // 123
parseInt('1010', 2); // 10
parseInt('0xFF', 16); // 255
parseInt('08', 10); // 8（显式按十进制）
parseInt('123.45', 10); // 123  小数部分被截断
parseInt('123abc', 10); // 123  遇到非数字字符就停
parseInt('abc', 10); // NaN  开头就不能解析 -> NaN
```

历史坑点（现代环境基本已修复，但习惯需保留）：

- 早期 JS 实现中，如果不传 radix 且字符串以 `0` 开头，可能被当作八进制：
  ```js
  parseInt('08'); // 老环境可能得到 0
  ```
- 为避免歧义，建议**总是显式传 radix**：

```js
parseInt('08', 10); // 强制按十进制 -> 8
```

---

#### 2.3 `parseFloat(string)`

```js
parseFloat('123.45'); // 123.45
parseFloat('  0.1  '); // 0.1
parseFloat('1.23abc'); // 1.23
parseFloat('abc1.23'); // NaN
parseFloat('Infinity'); // Infinity
```

特点：

- 和 `parseInt` 类似，但支持小数点、小数部分和指数（如 `1.23e3`）
- 也是“能解析的前缀就解析，遇到第一个非法字符就停”，否则 NaN

解析结果仍然是 double，依然会有浮点精度问题：

```js
parseFloat('0.1') + parseFloat('0.2') === 0.3; // false
```

---

### 3. 其它实用检测方法：isNaN / isFinite / isInteger / isSafeInteger

```js
Number.isNaN(value); // 严格判断是否为 NaN
Number.isFinite(value); // 判断是否为有限的 Number（排除 NaN/±Infinity）
Number.isInteger(value); // 判断是否为整数（在安全范围内）
Number.isSafeInteger(value); // 判断是否为“安全整数”
```

示例：

```js
Number.isNaN('abc'); // false
isNaN('abc'); // true（全局 isNaN 会先做 Number(...)）

Number.isFinite('123'); // false
isFinite('123'); // true（先转换为 123）

Number.isInteger(1.0); // true
Number.isInteger(1.0000001); // false

Number.isSafeInteger(2 ** 53 - 1); // true
Number.isSafeInteger(2 ** 53); // false
```

---

### 4. Number 常用方法速查表（小结）

| 分类         | 方法/写法                     | 作用概述                                          | 返回类型 | 典型坑点/备注                                                               |
| ------------ | ----------------------------- | ------------------------------------------------- | -------- | --------------------------------------------------------------------------- |
| 基本转换     | `Number(value)`               | 将整体 `value` 转成 Number，失败则为 `NaN`        | number   | 对字符串要求严格：`'123abc'` → `NaN`，和 `parseInt` 不同                    |
| 进制字符串   | `num.toString(radix)`         | 按指定进制（2–36）转成字符串                      | string   | 会暴露浮点误差：`(0.1+0.2).toString()` → `'0.30000000000000004'`            |
| 固定小数位   | `num.toFixed(digits)`         | 保留 `digits` 位小数并舍入（ties to even）        | string   | 受浮点误差影响，`(1.005).toFixed(2)` → `'1.00'`，不适合严肃金额运算         |
| 有效数字     | `num.toPrecision(precision)`  | 保留总共 `precision` 位有效数字                   | string   | 可能用科学计数法；高精度时会暴露内部浮点误差                                |
| 科学计数法   | `num.toExponential(digits)`   | 用科学计数法表示，保留 `digits` 位小数            | string   | 主要用于展示/调试非常大或非常小的数                                         |
| 解析整数     | `parseInt(str, radix)`        | 按 `radix` 解析前缀为整数，遇非法字符即停止       | number   | 必须传 radix，避免历史八进制坑；`parseInt('123abc',10)` → `123`             |
| 解析浮点数   | `parseFloat(str)`             | 解析前缀为浮点数，支持小数点和指数                | number   | `parseFloat('1.23abc')` → 1.23；解析结果仍是 double，有浮点精度问题         |
| NaN 检测     | `Number.isNaN(value)`         | 严格判断是否为 `NaN`                              | boolean  | 区分于全局 `isNaN`：`Number.isNaN('abc')` → false，而 `isNaN('abc')` → true |
| 有限数判断   | `Number.isFinite(value)`      | 判断是否为有限的 Number（非 `NaN`/±Infinity）     | boolean  | 不做隐式转换：`Number.isFinite('123')` → false                              |
| 整数判断     | `Number.isInteger(value)`     | 判断是否为整数（在安全范围内）                    | boolean  | `Number.isInteger(1.0)` → true；不是 BigInt 判断                            |
| 安全整数判断 | `Number.isSafeInteger(value)` | 判断是否为"安全整数"（在 ±(2^53−1) 范围内的整数） | boolean  | 用于防止大整数精度丢失                                                      |
