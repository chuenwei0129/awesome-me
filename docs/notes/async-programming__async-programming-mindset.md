---
group:
  title: browser
  order: 7
title: 异步世界观
toc: content
---

## 从十字路口开始：那盏“必须无限亮下去”的灯

想象一个城市的十字路口。

绿灯亮 10 秒，黄灯亮 2 秒，红灯亮 5 秒，然后再从绿灯重新开始，如此循环往复、永不停歇。
这是现实中司空见惯的场景，却也是前端世界里一个极其典型的异步问题。

如果你用 JavaScript 来实现它，很快就会遇到一个残酷的事实：
语言本身根本没有“同步等待 10 秒”的指令。你不能写出类似 `sleep(10000)` 这种**真正的同步阻塞调用**，因为：

- 一方面，JavaScript 规范压根就没有这样的同步 `sleep`；
- 另一方面，如果你用其他方式（比如死循环）“模拟”同步等待，结果就是主线程被阻塞：按钮点不了，动画动不了，用户直接关页走人。

换句话说，这个看似简单的红绿灯需求，本质上是在逼迫你回答一个问题：

> 在一个只能“异步等待”的世界里，如何优雅地描述那些和时间、事件打交道的业务逻辑？

所有的异步编程范式——回调（Callback）、Promise、async/await、Generator、异步生成器（Async Generator）……在这个看似幼稚的红绿灯问题面前，都原形毕露。
真正拉开程序员水平差距的，往往不是“会不会写”，而是“用哪种方式写”，以及“换需求时，哪种写法几乎不用重构”。

这一切的起点，就从那三个灰色的圆开始：绿、黄、红三个 `div`，通过不同的 `background-color` 表示灯的亮灭。UI 本身并不复杂，真正的难题在于——**如何让“时间”听你指挥**。

:::success{title=本节小结}

- JS 没有同步 `sleep`，只有异步等待。
- 阻塞主线程会直接“杀死”用户体验。
- 红绿灯是一个非常好的异步建模起点。
  :::

## 回调地狱：当时间被嵌套进一层层括号

最原始的做法，也是很多人一开始会写出来的，就是纯粹用回调函数和 `setTimeout` 把逻辑串起来。

绿灯亮起，等待 10 秒；
10 秒之后，黄灯亮起，再等待 2 秒；
再之后，红灯亮起，等待 5 秒；
最后，再回到绿灯，如此无限循环。

在代码层面，这意味着你会写出大致类似这样的结构（这里重点在结构，而不是具体 DOM 操作）：

```js
function green() {
  console.log('绿灯');
  // 这里点亮绿灯的 DOM 操作略去
}

function yellow() {
  console.log('黄灯');
}

function red() {
  console.log('红灯');
}

function go() {
  green();
  setTimeout(() => {
    yellow();
    setTimeout(() => {
      red();
      setTimeout(() => {
        go(); // 再次循环
      }, 5000); // 红灯 5 秒
    }, 2000); // 黄灯 2 秒
  }, 10000); // 绿灯 10 秒
}
```

逻辑上，这完全可行，运行效果也符合预期：
你在控制台输入一次 `go()`，红绿灯就会按设定节奏无限循环。

但问题是，这样的代码，会迅速演变成一种被戏称为 **Callback Hell（回调地狱）** 的形态。

当你的业务逻辑只有三步，嵌套三层，或许还能忍受。
一旦你开始加入更多条件分支、错误处理、并发请求，或需要把异步流程拆出来复用，嵌套就会像树根一样向下疯长，最终形成一段谁也不想再碰的“神秘代码”。

**回调地狱真正可怕的，并不仅仅是“丑”，而是它把逻辑的时间线撕碎，塞进一层又一层的回调里。**
你很难一眼读出“先做什么，再做什么”，而是在一堆函数嵌套里艰难地寻找那条隐形的时间轴。

在异步还是“唯一选择”而没有更好抽象的年代，我们别无他法，只能忍受。
但语言和工程实践不会永远停留在这种阶段——这就是 Promise 登场的时刻。

:::warning{title=容易踩的坑}

- 回调里再套回调，一开始“写着挺爽”，维护时会“哭着重写”。
- 回调把“时间顺序”碎片化，导致逻辑难以重构与复用。

:::

## Promise：当“等待”变成一种可以组合的值

要从回调地狱走出来，第一步就是：**把“将来会发生的结果”，从一段回调代码，提升为一种可以被传递、组合、返回的值**——这就是 Promise 的本质。

在红绿灯问题里，这个思路可以用一个 `sleep` 函数很好地体现出来：
`sleep` 不再只是“帮你设定一个定时器”，而是“返回一个 Promise，当时间到了就 `resolve`”。

```js
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
```

只要你在某处 `return sleep(1000)`，就等于定义了一个“一秒之后完成”的异步结果。

一旦有了 `sleep` 这种原语，我们的红绿灯就可以写成 Promise 链式的风格：

```js
function green() {
  console.log('绿灯');
}

function yellow() {
  console.log('黄灯');
}

function red() {
  console.log('红灯');
}

function go() {
  green();
  sleep(10000)
    .then(() => {
      yellow();
      return sleep(2000);
    })
    .then(() => {
      red();
      return sleep(5000);
    })
    .then(() => {
      go(); // 再次循环
    })
    .catch((err) => {
      console.error('红绿灯出错：', err);
    });
}
```

更关键的是，Promise 的 `then` 做了一件很重要的事：
它允许你在一个 `then` 中返回另一个 Promise，后面的 `then` 会自动等待前一个 Promise 完成，再继续执行。于是，原先那种层层嵌套的结构，被拉直成一条“链”。

这条链带来了几个微妙而重要的变化：

**第一，时间线重新变得可读。**
从上到下，每一个 `then` 都代表“前一个动作完成之后，再做下一步”，你一眼扫下去，就能看出整个流程如何推进。

**第二，异步开始可以被“组合”。**
现实世界里的异步往往不是“一件事做完再做一件”，而是“多个事情一起做”、“谁先回来用谁”、“等所有都准备好再往下走”。
Promise 在这点上提供了两个非常典型的工具：

- `Promise.all`：等待多个 Promise 全部完成，再继续；
- `Promise.race`：让多个 Promise“竞赛”，**谁先 settle（无论 resolve 还是 reject）就用谁的结果**。

在红绿灯这个简单的例子中，我们只是顺序地等待不同颜色的灯，在更复杂的业务里，你可以用它们来描述“并发请求”、“资源竞争”、“多个事件源之间的优先级”等逻辑。

**第三，控制逻辑开始与“等待的来源”解耦。**
此刻你等待的是 `sleep`（时间），但从概念上看，只要有一个函数“返回 Promise”，它就可以被塞进同一条链里。
换句话说，**你正在从“等待时间”升级为“等待任意异步事件”**。

然而，Promise 虽然缓解了回调地狱，却仍然有一个明显的痛点：
当链条变长、逻辑分支增多时，用 `then` 去组织流程依然显得生硬，尤其是你已经习惯了用“顺序、分支、循环”去表述同步逻辑的时候。

这时，就轮到 async/await 登场了。

:::info{title=本节关键记忆点}

- 把“未来结果”变成一个 **值（Promise）** 是质的飞跃。
- `sleep` 是理解异步抽象的最好玩具。
- `Promise.all` / `Promise.race` 让“等待”可以被组合。
  :::

## async/await：用同步的语法书写异步的命运

Promise 解决了“把异步当作值来组合”的问题，async/await 则进一步解决了“如何用人类习惯的方式来描述这些组合”的问题。

在语义上，async/await 并没有发明新的异步机制。
它做的，是提供一种语法糖：

- 只要一个函数被标记为 `async`，**这个函数就一定返回一个 Promise**；
- 在函数内部，你就可以写上 `await somePromise`，这行代码会“停在那里”，直到对应的 Promise 完成，再继续向下执行；
- 这种“停”，只发生在这个 `async` 函数内部，对其他任务和事件循环来说，它只是把控制权暂时“让了出去”。

这意味着，我们可以用最熟悉的结构——顺序执行、条件分支、循环结构——来描述本质上完全异步的流程。

回到红绿灯的问题。
有了 `sleep` 之后，你可以这样重写逻辑：

```js
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function setLight(color) {
  console.log('当前亮灯：', color);
  // 这里可以根据 color 操作 DOM
}

async function go() {
  while (true) {
    setLight('green');
    await sleep(10000);

    setLight('yellow');
    await sleep(2000);

    setLight('red');
    await sleep(5000);
  }
}
```

你在控制台调用一次 `go()`，就能看到灯按照设定节奏无限循环变化。
尽管代码里写着一个看似危险的 `while (true)`，它却不会卡死页面，因为循环体里的每一次迭代，都会在 `await` 时把执行权交还给运行时。

这里有一个非常重要的观念转折：

> 在异步世界里，`while (true)` 不再等于“死循环”，而是“一件会一直进行下去的事”。

秒针不停走动、聊天窗口不断轮询新消息、一个 UI 组件持续监听事件，这些都可以用“带有异步等待的无限循环”自然地表达出来。
只要循环体中每一次迭代都包含了真正的异步等待，`while (true)` 在逻辑层面就是合理的。

而更巧妙的地方在于：
因为我们把“等待时间”的能力封装在了 `sleep` 里，控制灯光顺序的 `go()` 函数，**完全不关心“是时间流逝触发下一步，还是别的什么”**。

这为后续的“切换控制模式”埋下了一个伏笔。

:::warning{title=重要但常被误解的一点}
`while (true)` **本身不危险**，危险的是：

- 在循环里没有任何真正的异步等待；
- 或者等待写错了，导致永远不会把控制权还给事件循环。
  :::

## 从自动到手动：当交警接过红绿灯的控制权

想象一下，城市堵车了，交警接到通知：

> “今天不要再用自动控制红绿灯了，我们要改成人工控制。只有当我按下按钮时，才允许灯切换到下一个状态。”

如果你的代码是回调地狱式的写法，时间和逻辑写死在一个个嵌套的 `setTimeout` 里，要改成这种“按键控制”的模式，往往意味着大改结构，甚至重写一遍。

但如果你已经用 async/await 把核心流程抽成了这样的一种形式：

- `while (true)` 中依次执行：
  - 点亮绿灯，然后“等待某个异步事件”；
  - 点亮黄灯，然后“等待某个异步事件”；
  - 点亮红灯，然后“等待某个异步事件”。

那么，所谓“切换模式”，其实就变成了——**把“等待时间”的函数，换成“等待按钮点击”的函数**。

这就是 `happen` 的思路：
它和 `sleep` 一样，返回一个 Promise，但触发 `resolve` 的不是 `setTimeout`，而是“用户点击了一个 `next` 按钮”。

```js
function happen(button) {
  return new Promise((resolve) => {
    const handler = () => {
      button.removeEventListener('click', handler);
      resolve(); // 一次点击，触发一次“继续”
    };
    button.addEventListener('click', handler);
  });
}

async function goManual(button) {
  while (true) {
    setLight('green');
    await happen(button);

    setLight('yellow');
    await happen(button);

    setLight('red');
    await happen(button);
  }
}
```

于是，原来的自动模式（时间驱动）变成了手动模式（用户行为驱动）：
每点一次按钮，灯就切换到下一个颜色。

而切换模式本身，根本不需要重写控制逻辑——`while (true)` 里的那段“先绿后黄再红”的流程，对应的业务意义没有任何变化，只是把“等待的来源”从 `sleep` 换成了 `happen`。

这就是 async/await 配合 Promise 带来的真正力量：

> 它让你可以用统一的语义表达“等待”，至于是等时间、等网络、等用户操作，还是等某个系统事件，只要能包一层 Promise，就可以被同样的业务逻辑消费。

换句话说，你不再被具体的“异步手段”绑死，而是站到了一个更高的抽象层次上，去操控那些“尚未发生但必将发生”的结果。

:::success{title=模式切换的精髓}

- 自动模式：`await sleep(...)`
- 手动模式：`await happen(...)`
- **控制逻辑不变，只是“等待源”替换了。**
  :::

## 早期的智慧：用 Generator 模拟未来的 async/await

有趣的是，async/await 并不是一开始就存在的。
在它问世之前，JavaScript 社区早就对“如何用同步风格写异步”有着强烈的渴望，于是出现了一种过渡性的技术：**用 Generator 来模拟 async/await 的效果**。

Generator 函数有两个关键特性：

- 声明时会在函数名之前加一个 `*`；
- 调用后不会一次性执行到底，而是返回一个迭代器（Iterator），每次调用 `next()`，才向前执行到下一个 `yield` 位置，并返回一个 `{ value, done }` 结构。

如果我们让一个 Generator 函数在逻辑的关键点上 `yield` 一个 Promise，这就为“用同步的写法写异步的流程”创造了可能。

```js
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function* task() {
  console.log('A');
  yield sleep(1000); // 等 1 秒
  console.log('B');
  yield sleep(1000);
  console.log('C');
}
```

然而光有 Generator 还不够，我们还需要一个“执行器”来帮我们推进迭代器，这就是 `run` 函数的角色：

```js
function run(genFn) {
  const it = genFn();

  function step(lastValue) {
    const { value, done } = it.next(lastValue);
    if (done) return;

    // 假设每次 yield 的都是 Promise
    Promise.resolve(value)
      .then((res) => {
        step(res);
      })
      .catch((err) => {
        // 把错误抛回 Generator
        if (typeof it.throw === 'function') {
          try {
            it.throw(err);
          } catch (e) {
            console.error('Generator 内未捕获的错误：', e);
          }
        } else {
          console.error('未处理的错误：', err);
        }
      });
  }

  step();
}

run(task);
```

这个执行器的思路，模仿的是一个曾经颇为著名的库——`co`。
它所做的一切，其实就是把“Generator + Promise”组合起来，模拟出“每一次 `yield` 一个 Promise，然后在它完成后继续向下执行”的语义，包括成功与失败两条分支。

从使用者的角度看，这与后来的 async/await 非常接近：
你写出来的仍然是类似同步的顺序代码，只不过背后依赖的，不是语言级的 `await`，而是一个“自动帮你 `next()` / `throw()` 的执行器。

在今天，这种写法已经不再被推荐使用，因为 async/await 已经从语法层面给出了更自然、更直接的解决方案。
但从历史视角去看，它是那个没有 async/await 的时代里，工程师们用 Generator 和 Promise 拼出来的一座临时桥梁，也是一种理解异步本质的极好素材。

理解了这一层，你就更容易明白：
只要一个函数会“返回 Promise”，无论它是 `sleep`、`happen`，还是别的什么，最终都可以被抽象为“一个异步步骤”——而无论你是用 Generator+执行器，还是用原生的 async/await，内在的思路是同一条线。

:::info{title=记住这个对照关系}

- 过去：`function*` + `yield Promise` + `run(genFn)`
- 现在：`async function` + `await Promise`
- 本质：**在“等待点”挂起，待 Promise 完成后继续。**
  :::

## 异步生成器：当时间本身变成一个“可遍历的序列”

在理解了普通的 Generator 之后，再往前一步，就会遇到一个更加有趣的概念：**异步生成器（Async Generator）**。

如果说普通 Generator 适合产出“同步可得”的序列，比如数组的每一项、树遍历的每一个节点；
那么异步生成器，则适合产出“需要等待”的序列，比如每隔一秒产生一个数字、随着时间推移不断产生新事件等。

有一个很典型的例子，是写一个“计数器”：

- 这个计数器函数会不断地产生递增的数字；
- 在每一次产生新数字之前，会 `await sleep(1000)`，也就是等待一秒。

```js
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function* counter() {
  let i = 0;
  while (true) {
    await sleep(1000);
    yield i++;
  }
}

async function main() {
  for await (const value of counter()) {
    console.log('每秒得到一个数字：', value);
    if (value >= 5) break; // 举例：拿到 5 次就停
  }
}

main();
```

当这个函数被声明为 `async function*`（带 `*` 的异步函数）时，它就成了一个异步生成器。
调用它时，你拿到的不再是“瞬时可遍历的结果集”，而是一个“随时间推移持续产出结果的异步序列”。

与之配套的，就是 `for await...of` 语法：
你可以写出一个异步函数，在其中用 `for await (const v of counter())` 这样的结构，去遍历这个“缓慢产生的”序列，每拿到一个值，就执行一段逻辑。

如果我们把视角再拉远一点，会发现这其实是另一幅图景：

- **Promise 更像是“一次性的异步”**：这个异步完成了就结束；
- **异步生成器更像是“一股流式的异步”**：会在较长的时间里不断产生新值。

之前我们处理的是“一段有限的流程：绿灯 → 黄灯 → 红灯 → 循环”，而异步生成器则适用于描述“一个可能无限延续的流：每秒一个计数、每次事件产生一个值”。

异步生成器和 `for await...of` 的搭配，提供了一个极其自然的方式，去描述这种持续的流动：
你不需要手动去管理“现在到了第几次”、“何时应该停止”，而是把这些逻辑封装在生成器内部，外部代码只关心“每来一个值，我要如何响应”。

当你把红绿灯、秒表、计数器这些例子连在一起看，就很容易发现：
**异步编程不再只是“拿一个数据回来”，而是在“描述一个随时间展开的过程”**。

:::success{title=什么时候该想到异步生成器？}

- 数据是“**源源不断**”的，而不是一次性返回：日志、行情、消息流……
- 你想要的，是“**随时来一个就处理一个**”，而不是等全部结束再处理。
  :::

## “无限循环”的另一层含义：和事件循环一起跳舞

在同步代码的世界里，`while (true)` 几乎是一个危险信号。
它往往意味着某段逻辑会毫无节制地占用 CPU，直到浏览器崩溃、程序被强制终止，是所有人都不愿看到的“死循环”。

但在异步代码里，特别是在有 `await`、有事件循环的环境中，`while (true)` 却变成了一个极为常见、甚至优雅的写法。

原因就在于：
只要循环体中存在真实的异步等待（比如 `await sleep(1000)`、`await happen()`），每一次迭代都会在 `await` 时把执行权让回给运行时，浏览器可以去处理其他事件、渲染 UI、响应用户操作，然后在合适的时机重新调度这段协程继续执行。

在这种模式下，“无限循环”不再意味着“永远霸占线程”，而是“永远参与事件循环的协作”。

这里顺带可以掀开一点事件循环的面纱（用一种工程师常用的口语化方式）：

- 像 `setTimeout`、DOM 事件回调，会排进“宏任务队列”（task queue）；
- Promise 的 `.then`、`async/await` 的续步，则依赖“微任务队列”（microtask queue）；
- 事件循环每轮都会先处理一个宏任务，在合适的时机冲掉当轮的所有微任务，再进入下一轮。

一个简单的观察小实验：

```js
console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(() => {
  console.log('promise then');
});

console.log('script end');

// 输出顺序：
// script start
// script end
// promise then
// setTimeout
```

正是这一套调度机制，保证了：

- 你的异步代码看起来“顺序执行”，但不会堵死主线程；
- UI 渲染、用户输入、网络回包，都有机会在不同轮次中被处理。

红绿灯是如此，表盘的秒针是如此，一个长时间运行的实时系统也是如此。
它们都在用自己的方式，与时间共存，与事件循环一起跳舞。

这一点，构成了异步编程的底层哲学：

> 真正优秀的异步代码，从来不是“抢占”时间，而是“配合”时间。

你不是试图把时间冻结在某一刻，而是承认时间会不断流逝、事件不断发生，于是设计出一段可以长期运行、持续响应、优雅退让的逻辑。

:::warning{title=常见误区}

- 把“异步无限循环”和“同步死循环”混为一谈；
- 在 `while (true)` 中漏写 `await`，导致出现真正的死循环。
  :::

## 学会与时间合作：重建你的异步心智模型

当我们把红绿灯、回调、Promise、async/await、Generator、异步生成器这些看似零散的概念串起来，就会发现它们背后有一条非常清晰的主线：

**第一步，是承认异步的不可逃避。**
JavaScript 没有同步的“睡眠”指令，浏览器只有一个主线程，任何直接的阻塞都会让整个界面失去响应。
于是，我们必须学会通过回调、定时器等方式，把“未来会发生的事情”放到某个时刻再执行。

**第二步，是把“未来的结果”抽象成一种值。**
回调地狱的问题，不只在于嵌套丑陋，更在于它把异步的逻辑紧紧绑死在结构里。
Promise 带来的最大转变，是让“一个将来会完成的操作”变成一个可以传递、组合、返回的实体，从而让异步逻辑可以被构造、重用和重组。

**第三步，是用人类最自然的语法描述异步流程。**
async/await 的出现，让我们可以用“先做 A，再等一会儿，再做 B”的方式写代码，而不需要反复切换心智模型。
在这个层面上，异步代码终于开始看起来像“可阅读的业务描述”，而不是“被异步机制撕碎的控制流”。

**第四步，是把等待的来源彻底抽象出来。**
当 `sleep` 和 `happen` 都被视为“返回 Promise 的函数”，控制红绿灯的逻辑就不再关心“时间驱动”还是“按钮驱动”。
这让系统在面对需求变化时，可以用极小的代价切换模式——比如从自动控制到人工干预。

**第五步，是承认有些流程本就不会结束。**
无论是用 `while (true)` 还是用异步生成器 + `for await...of`，我们都在承认一个事实：
现实中的很多业务，本来就是“无限进行”的——表盘永远在走，系统永远在监听，服务永远在响应。
异步编程真正强大的地方，就在于能自然地表达这种“与时间等长”的逻辑。

在这条主线之外，还有两个在工程实践中非常关键，但常被忽略的维度：

**维度一：错误处理与异常传播。**
从回调到 Promise 再到 async/await，错误处理的心智也在演化：

- 回调时代，我们习惯使用“error-first 回调”（`(err, data) => {}`）；
- Promise 时代，错误被抽象成 reject，通过 `.catch()` 统一处理；
- async/await 时代，我们终于可以用熟悉的 `try/catch` 在业务代码附近捕获错误。

这三者本质上是在回答同一个问题：
**“当等待失败时，这个失败如何优雅地向上传递？”**
理解这一点，有助于你在任何异步范式下设计清晰的错误传播路径。

**维度二：取消与中止异步操作。**
现实世界里，还有一种常见需求：**我不想再等了。**

- 网络请求超时，需要主动中止；
- 用户切换页面，之前的加载逻辑应该停掉；
- 一个长期运行的任务，需要一个“紧急刹车”。

现代浏览器提供了 `AbortController` / `AbortSignal` 这样的机制，让你可以在 Promise、`fetch` 等 API 中注入“取消信号”。
这相当于给“等待”多了一个维度：除了“成功”和“失败”，还多了“被人叫停”。

```js
const controller = new AbortController();

async function loadData() {
  try {
    const res = await fetch('/api/data', {
      signal: controller.signal,
    });
    const data = await res.json();
    console.log('数据：', data);
  } catch (err) {
    if (err.name === 'AbortError') {
      console.log('请求被取消');
    } else {
      console.error('请求失败：', err);
    }
  }
}

// 某个时刻不想等了：
controller.abort();
```

把错误处理和取消机制纳入你的异步心智模型，会让你在构建长期运行、复杂交互的系统时，拥有更稳固的基础。

:::info{title=一眼看懂的心智模型 Checklist}

- 我在等什么？（时间 / 网络 / 事件 / 状态）
- 这个等待能否包装成 Promise，或抽象成“异步步骤”？
- 逻辑能否写成一个清晰的 async 函数？
- 这是“有限流程”，还是“无限序列/流”？
- 错误如何传播？什么时候需要取消？
  :::

如果要用一句话来概括这一整套心智模型，那就是：

> 把“等待”当作一等公民，把“时间”视为合作对象，而不是敌人。

当你习惯这样去思考异步问题时，会发现许多曾经令人头疼的场景——复杂的流程控制、模式切换、无限运行的系统——不再显得混乱。
它们都可以被还原为：

- 我在等什么？
- 这个等待能否包装成 Promise，或抽象成“异步步骤”？
- 逻辑能否写成一个清晰的异步函数？
- 这个过程是“有限流程”，还是“无限序列/流”？
- 错误如何传播？什么时候需要取消？

而那盏在十字路口反复亮起的红绿灯，不过是这一整套世界观的一个温柔开端而已。

## 实践中的几个落地建议

最后，用几条更偏工程实践的建议，帮你把这套抽象真正用到日常开发里：

- **业务流程优先用 async/await 表达。**
  把复杂的接口编排、步骤控制写成一个个 `async` 函数，让代码长得像“故事”而不是“机械拼装的回调”。

- **统一抽象“等待原语”。**
  像 `sleep`、`happen` 这样的函数，可以抽在一个小工具库里：

  - 时间相关的等待（`delay`、`timeout`、`interval`）；
  - 事件相关的等待（点击、输入、特定消息）；
  - 状态相关的等待（某个条件成立）。
    业务代码只关心“等什么”，而不关心“怎么等”。

- **遇到“源源不断的东西”，先想想是不是流。**
  WebSocket 消息、日志流、滚动加载的内容、实时行情……
  这类场景往往更适合用异步生成器、事件流库，或者至少是“订阅 → 回调”的模式去建模，而不仅仅是“一次请求一个 Promise”。

- **尽早定义错误边界与取消策略。**
  写异步代码时，顺便想好：

  - 这段等待失败了怎么办？
  - 用户走了、页面关了、组件卸载了，要不要中止？
  - 哪一层负责兜底日志和提示？
    这些决定，会极大影响你之后的可维护性。

- **把“和时间打交道”的逻辑集中管理。**
  无论是轮询间隔、超时时间，还是节流/防抖的参数，尽量放在可配置、可复用的地方。
  这样，当“产品觉得 5 秒太慢，改成 3 秒”时，你不会被迫在项目里满世界搜 magic number。

当你逐渐习惯用这种方式组织代码，你会发现：
**异步不再是一个充满陷阱的“特殊领域”，而只是你和时间、事件合作的日常工作方式而已。**
