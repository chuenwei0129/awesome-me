# 从暂停/继续到调度建模

## 一、当“暂停一下”升级成一道工程题

先看一个常见得不能再常见的场景：

你有一长串异步任务，需要一个接一个地跑。

比如大文件分片上传，每一片都是一个独立的异步任务；
你希望它们**顺序执行**，又希望用户可以随时点击“暂停”，过一会儿再点“继续”，从中断的位置往后接着跑。

听上去只是“加一个暂停按钮”。
但当你真要写一个**可中断、可恢复**的任务序列执行器，很快会发现：

这其实是道很考基础功的工程题：

- 不靠冷门 API；
- 不靠花哨语法；
- 全程只有 Promise、状态变量、循环、`await` 和一点点控制流。

真正被考验的，是你对：

- **异步执行**
- **状态管理**
- **Promise 语义**
- 以及整个**流程**本身

的建模能力。

它的起点可以简单到只有这样一个函数签名：

```js
function processTasks(...tasks) {
  return {
    start,
    pause,
  };
}
```

它接收一串**无参、返回 Promise 的异步任务函数**，要求它们：

- 必须**严格顺序**执行：前一个结束，后一个才能开始；
- 支持“暂停”：只能在**任务与任务之间**暂停，单个任务具有“原子性”，执行中不可打断；
- 支持“继续”：再次调用 `start` 时，从上一次中断的任务下标接着往后执行；
- 有一个**总的 Promise**，代表这整段旅程的命运：要么全部成功，要么中途失败，要么停在暂停状态，等待下一次继续。

这是一个看似“小工具函数”的需求，背后却藏着一个关于“成熟工程能力”的分界线：

> 你到底是在“堆代码”，还是在“设计流程”。

---

## 二、从“全部跑完就行”到“排成一条时间线”

先把问题尽可能简化，看它最朴素的样子。

如果需求只有：“把这些异步函数都执行一遍并拿到结果”，那几乎不需要任何设计，一个 `Promise.all` 就够了：

```js
function runAll(...tasks) {
  return Promise.all(tasks.map((task) => task()));
}
```

每个任务是一个返回 Promise 的函数，`Promise.all` 帮你**并行**执行它们，全部结束后一次性给出结果数组。

但一旦题目加上一句“**必须顺序执行**”，事情立刻变味了。

“顺序执行”的意思是：

- 第二个任务的开始时间依赖于第一个任务的结束；
- 第三个依赖于第二个；
- ……

执行过程从“同时开跑”变成了一条严格线性的时间轴。

这时候，直觉告诉我们：用一个循环配合 `await` 就好了：

```js
async function runSequential(...tasks) {
  const results = [];
  for (const task of tasks) {
    results.push(await task());
  }
  return results;
}
```

逻辑非常直白：

- 每次 `await` 一个任务；
- 任务结束后再继续下一个；
- 最后返回所有结果。

到这里为止，题目仍然只是“会不会写 `for + await`”。
真正的难点，从“**加一个暂停**”开始。

---

## 三、暂停不是“强行打断”，而是“少走一步”

“暂停”这个词，自带一种“立刻停下”的直觉。但题目给了一个非常关键的前提：

> 每个任务具有原子性，执行过程中不可中断，只能在任务之间中断。

这句话实际上帮我们把难度从“暴力打断异步”拉回到“**管理好边界时机**”。

要做到这一点，你需要一个极其朴素的东西：**中断信号**，再加一个**进度刻度**。

```js
let isRunning = false; // 现在是否处于“应该继续往下跑”的态势
let currentIndex = 0; // 当前已经跑到第几个任务
```

- 调用 `start` 时，把 `isRunning` 置为 `true`，表示“允许继续向后执行”；
- 调用 `pause` 时，把 `isRunning` 置为 `false`，表示“发出暂停信号”。

关键不在 `pause` 做了什么，而在**谁、在什么时候去读取这个信号**。

既然“任务本身不可中断”，那么唯一合理的检查时机是：

> **每个任务执行完之后，在开始下一个任务之前，检查一次 `isRunning`。**

于是，“执行循环”大致长这样：

```js
async function runLoop() {
  while (isRunning && currentIndex < tasks.length) {
    const task = tasks[currentIndex];
    await task(); // 任务执行过程是原子的
    currentIndex += 1; // 向前推进一个刻度
    // 下一轮 while 会检查 isRunning
  }
}
```

这段极其朴素的代码，藏着几个重要的点。

### 1. 进度必须“活在外面”

如果 `currentIndex` 是 `runLoop` 的局部变量，那么每次调用 `start` 时，它都会从 0 开始，完全**丢掉上次的进度**。

只有把 `currentIndex` 提升到外层闭包变量，第二次、第三次 `start`，才能自然地**从断点接着往前跑**。

“暂停”这件事，本质上就是：

> 把“已经走到哪儿了”这个信息，放到一个**比函数调用更长寿命**的地方。

### 2. 暂停不是“立刻刹车”，而是“下一步停走”

当你在任务执行中途调用 `pause` 时，当前任务并不会立刻停下来；

- `isRunning` 变成 `false` 之后，
- 要等**当前任务执行完**，
- 循环在下一次检查条件时才会停下。

这就是“原子性”的工程翻译：

> 单个任务内部不可分割，只能在任务之间插入决策点。

---

## 四、谁来为“一整段旅程的命运”负责？

有了顺序执行 + 可暂停/继续，一个最基本的执行器已经成型了。

但还有一个经常被忽略的维度：

> `start` 返回的那个 Promise，究竟在表达什么？

如果不多想，很容易写成“每次调用 `start` 都 new 一个 Promise”。
但我们的真实需求是：

- 这个 Promise 代表的是**整串任务序列的最终命运**；
- 而不是“这一次 `start` 调用期间发生了什么”。

换句话说，它描述的是：

- 要么所有任务都执行成功，最终 `resolve` 出一个结果集合；
- 要么中途某个任务失败，整个序列提前宣告 `reject`；
- 要么目前还没跑完，且被暂停了，于是 Promise 对调用方来说一直是 pending，等待未来某一次 `start` 把后续任务跑完。

这意味着，我们需要一个**跨越多次 `start` 调用的“结果承诺”**：

```js
let resultPromise = null;
let resolveResult;
let rejectResult;
```

第一次调用 `start` 时：

- 如果 `resultPromise` 还不存在，就创建一个新的 Promise；
- 把 `resolve` / `reject` 存起来，作为整个序列的“命运控制器”。

后续每一次 `start`，都应该返回**同一个** `resultPromise`，而不是重新 new。

从调用方视角看：

- 我拿到的就是“这串任务最终会怎么样”的承诺；
- 中间暂停了几次、继续了几次，甚至内部 `runLoop` 跑了几轮，我不需要知道；
- 我只关心：这段历史，最后是成功、失败还是一直挂着。

### 成功、失败、暂停各自意味着什么？

- 某个任务失败了：

  - 代表整段旅程提前结束；
  - 应立刻调用 `rejectResult(error)`；
  - 之后再调用 `start`，都不应该重新执行任务，而是返回这个已经失败的 `resultPromise`。

- 所有任务都执行完成：

  - 代表旅程圆满收尾；
  - 应在最后一个任务完成后调用 `resolveResult(allResults)`；
  - 之后的 `start` 也只返回这个已经完成的 Promise，不再重复执行。

- 中途被“暂停”：
  - 此时不能 `resolve`，也不能 `reject`，因为还有任务没跑完；
  - `resultPromise` 必须保持 pending 状态，静静等待下一次 `start` 把剩余任务跑完。

这里有一个容易被忽略但很重要的澄清：

> 从调用方角度看，`resultPromise` 似乎是“长时间挂起”的；
> 但执行器内部，可能经历了多次 `start` / `pause`，甚至多轮 `runLoop` 调度。
>
> 调用方看到的是一个“持续 pending 的承诺”，
> 内部则把这段时间切割成一个个“冲刺窗口”。

### 拆开“单次冲刺”和“整段生命”

把这个抽象再推高一点，可以概括为：

- **`runLoop`**：一次“冲刺阶段”

  - 在当前 `isRunning === true` 的窗口内，尽量往前推进任务；
  - 直到被暂停、任务耗尽，或遇到错误。

- **`resultPromise`**：整段“任务序列的生命”
  - 它不关心中间有多少次冲刺；
  - 只关心：整个生命最终是**成功**还是**失败**。

这个视角转换，很大程度上决定了你如何设计 API 和内部结构：

> Promise 承诺的不是“这一次函数调用发生什么”，
> 而是“这一串任务，最终会怎样收场”。

---

## 五、实现落地：再加上防重入和边界处理

到目前为止，我们有了：

- 顺序执行；
- 暂停 / 继续；
- 跨多次 `start` 的总结果 Promise。

但在真实工程里，还有几个“边角问题”必须考虑清楚：

1. **并发调用 `start` 怎么办？**

   - UI 抖两下、多点几次按钮很常见；
   - 如果不防重入，很容易出现“多个 `runLoop` 同时推进同一条进度线”的乱局。

2. **一些边界情况：**

   - 还没开始就 `pause`；
   - 已经全部完成后再 `start`；
   - 已经失败了还 `start` / `pause`。

3. **错误策略：**
   - 当前我们选择“某个任务失败，整条链立即失败并停止”；
   - 你也可以设计“继续执行后续任务，但汇总所有错误”的变体，这时候 `result` 结构就要改。

下面是一个**参考实现骨架**（只演示思路，不是唯一写法）：

```js
function processTasks(...tasks) {
  let isRunning = false; // 是否处于“应当向前推进”的态势
  let isLooping = false; // 是否已有 runLoop 在执行（防重入）
  let currentIndex = 0; // 进度：已经完成到第几个任务
  let resultPromise = null; // 整段任务的命运承诺
  let resolveResult;
  let rejectResult;
  const results = []; // 已完成任务的结果

  async function runLoop() {
    // 防止多个 runLoop 并发推进同一条进度线
    if (isLooping) return;
    isLooping = true;

    try {
      // 只要“允许执行”且还有任务，就继续往前推进
      while (isRunning && currentIndex < tasks.length) {
        const task = tasks[currentIndex];
        const res = await task(); // 单个任务原子执行
        results.push(res);
        currentIndex += 1;
      }

      // 退出循环有三种可能：
      // 1. isRunning 被置为 false（暂停） -> 不改变 resultPromise 状态
      // 2. currentIndex 跑到 tasks.length（全部完成） -> resolve
      // 3. 抛异常（在 catch 中处理） -> reject

      if (currentIndex >= tasks.length && resultPromise) {
        resolveResult(results);
      }
    } catch (err) {
      if (resultPromise) {
        rejectResult(err);
      }
    } finally {
      isLooping = false;
    }
  }

  function start() {
    // 第一次 start：创建整段旅程的 Promise
    if (!resultPromise) {
      resultPromise = new Promise((resolve, reject) => {
        resolveResult = resolve;
        rejectResult = reject;
      });
    }

    // 如果已经执行完成或失败，直接返回既有的命运
    // （resultPromise 此时已经 settled）
    if (currentIndex >= tasks.length) {
      return resultPromise;
    }

    // 如果尚未完成，则设为“允许执行”，并拉起一次 runLoop
    isRunning = true;
    runLoop();
    return resultPromise;
  }

  function pause() {
    // 暂停只是改变态势，不会打断当前正在执行的任务
    isRunning = false;
  }

  return { start, pause };
}
```

这段代码把前面说的几个关键点都落地了：

- **状态**

  - `isRunning`：现在是否应该继续往前执行；
  - `isLooping`：是否已经有一个 `runLoop` 在推进（防止同时跑多个）；
  - `currentIndex`：当前进度刻度；
  - `results`：已完成任务的结果集合。

- **进度**

  - 每完成一个任务，`currentIndex += 1`；
  - 暂停只是让刻度“暂时不往前走”，不会回滚。

- **结果**
  - `resultPromise` 贯穿整个生命周期；
  - 成功：最后一个任务完成时 `resolveResult(results)`；
  - 失败：某个任务抛出异常时 `rejectResult(error)`；
  - 暂停：不动 `resultPromise`，保持 pending。

你当然可以在此基础上继续演化：

- 增加一个 `cancel()`，用于“彻底终止且不再允许继续”；
- 把 `results` 换成 `{ success: [], failed: [] }` 结构，支持“不中断但收集错误”的策略；
- 在 `start` 中检查 `resultPromise` 是否已 rejected / resolved，决定是否允许“重置一条新旅程”等等。

这些都建立在同一个骨架上，只是策略的差异。

---

## 六、“状态 / 进度 / 结果”：一个可迁移的调度模型

走完整个推演，可以看到，这道题表面上是在写一个“可暂停任务执行器”，其实是在帮你搭一个很通用的心智模型：

> 凡是涉及任务调度的系统，至少要想清楚三件事：
> **状态（State）**、**进度（Progress）**、**结果（Result）**。

### 1. 状态：系统现在处于什么姿态？

在这个执行器里，至少有这几种状态信息：

- 是否处于“应当继续向前执行”的态势（`isRunning`）；
- 是否有执行循环正在推进（`isLooping`）；
- 执行到了哪一个任务（`currentIndex`）；
- 整个任务序列是否已经完成 / 失败（由 `resultPromise` 是否已 settled 间接体现）。

如果这些状态不被明确建模，“暂停 / 继续 / 终止 / 重复执行”等行为就会变成零散的 `if` 和标记，最后连你自己都看不明白。

### 2. 进度：已经走了多少，还剩多少？

`currentIndex` 看上去只是一个整数，但它本质上是这套系统的**时间刻度**：

- 暂停时，刻度停住；
- 继续时，从当前刻度继续向前推进；
- 一旦刻度走到数组末尾，就代表“旅程结束”。

现实里，很多看似复杂的需求，其实都可以抽象成一条这样的刻度线：

- 大文件分片上传；
- 后台批量任务处理；
- 断点续传的数据同步；
- 分阶段执行的迁移脚本……

它们的共通点是：**有状态的进度条**。

你要做的事情，往往可以描述成：

> 给这条进度线定义一个刻度（第几片 / 第几步 / 第几条记录），
> 然后让所有操作围绕这条刻度线展开。

### 3. 结果：谁来给整段旅程一个交代？

这里的 `resultPromise` 就是那个“总结果表达者”：

- 它不关心中间跑了多少次 `runLoop`；
- 也不关心用户点了几次暂停 / 继续；
- 只关心：整条任务链最终是**成功**还是**失败**。

在别的系统里，它可能是：

- 数据库里一条任务记录的终态字段；
- 任务队列里的“完成 / 失败 / 超时”状态；
- UI 上某个最终提示（“该文件上传成功/失败”）。

但抽象是一致的：

> 把“局部执行细节”和“全局结果语义”，在结构上拆开。

一旦你形成了这个三要素模型，再遇到任何带中断、恢复、重试、回滚的复杂流程，都可以先问自己三句话：

1. **我有哪些状态？**
   - running / paused / finished / failed / cancelling / …
2. **我的进度长什么样？**
   - 第几个任务、哪个阶段、哪条分支、哪个版本……
3. **谁在表达“整段旅程的结果”？**
   - Promise、数据库状态、日志、UI 状态、事件总线……

这三点清楚了，代码通常不需要任何“黑魔法”，用最基础的语法就能把逻辑翻译出来。

---

## 七、连回前端：分片上传只是一个例子

回到我们最开始的前端场景——大文件分片上传：

- **状态**

  - `isRunning`：用户当前是否点击了“上传/继续”；
  - `isLooping`：是否已有一个上传循环正在执行；
  - UI 还可以有一个 `uiStatus`：idle / uploading / paused / done / error。

- **进度**

  - `currentIndex`：当前准备上传第几个分片；
  - 可以映射到一个进度条：`(currentIndex / totalChunks) * 100%`。

- **结果**
  - `resultPromise`：这整个“文件上传任务”最终是成功还是失败；
  - 同时可以落到后端任务记录 / 前端本地缓存 / 日志等。

你现在不再只是“让按钮能点”、“让接口能调用”，而是在用：

- 一个**进度线**；
- 一组极简的**状态变量**；
- 一个贯穿始终的**结果承诺**；

把一个“看上去很业务”的需求，变成一个**可移植的调度模型**。

当你再遇到：

- 多步骤的导入 / 导出流程；
- 带断点续传的同步任务；
- 分阶段执行的重构 / 迁移脚本；
- 任意“可暂停、可恢复”的长任务……

这套“状态 / 进度 / 结果 + 一条进度线 + 一个总 Promise（或等价物）”的抽象，都可以直接拿出来复用。

从这个角度看，这道题考察的从来不是：

> “你会不会写一个 for + await？”

而是：

> “你能不能把一堆异步细节，先看成一条可管理的进度线，
> 再把 ‘暂停 / 继续 / 成功 / 失败’ 这些行为，
> 统一收束在一个清晰的调度模型里？”
