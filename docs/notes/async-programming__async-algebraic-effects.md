# 从代数效应到 React Suspense

---

## 当异步开始“传染”，纯函数世界崩塌了

很多人第一次学异步编程，只觉得它麻烦：`callback` 套 `callback`，后来变成 `Promise`、`async/await`，语法好看了一些，但本质仍然是——**一旦某个地方出现了异步，整条调用链都不得不跟着一起异步**。

想象这么一段再普通不过的代码：`main` 调 `m3`，`m3` 调 `m2`，`m2` 调 `m1`，`m1` 最终去调一个远程请求 `fetchUser`。在最开始，它们可能都是干净的、确定的、可预测的“纯逻辑函数”。

但只要最底层的 `fetchUser` 变成了异步，事情立刻失控：

- `fetchUser` 是 `async` 的，所以 `m1` 也不得不变 `async`；
- `m2` 也变成 `async`，`m3` 也变成 `async`；
- 最后 `main` 也必须 `await` 整条链。

这就是 **“异步的传染性”**：一颗不老实的细胞，就可以让整条血脉都带上异步的标签。

从严格的函数式编程角度看，“异步”本身更精确的说法是“**一种效应（effect）**”——它未必一定伴随读写外部状态，但至少会改变函数的“类型”：从 `T -> U` 变成了 `T -> Promise<U>`。在 FP 语境里，这种类型上的变化也被视为一种“污染”。

对一般业务来说，这似乎没什么问题，只是多写几个 `async/await` 而已。但在追求可推理性和可组合性的函数式世界里，这很难被忽视：

- 本来上层可以当作普通函数来组合使用；
- 结果为了照顾最底层的一个网络请求，上面一整条链都得挂上 `Promise`；
- 很多本可以“同步思考”的逻辑，都被迫迁移到“异步思维模式”里。

于是，问题变成了一个看似矛盾的命题：

- 一方面，网络请求本质上就是要花时间的，你不可能真的把它“变成同步”，更不可能让浏览器傻等到卡死；
- 另一方面，我们又想在**代码结构层面**，尽可能让上层函数看起来像是“没有异步”、没有 `await`、没有回调，让它们保持“像数学函数那样干净”的形态。

**如何在不阻塞、不改动原有调用者的前提下，把异步的“传染性”截断？**

这一切的关键，在于一个非常反常识的想法：

> 既然我暂时拿不到结果，那我就先“失败”，
> 等拿到结果之后，再重新来过。

---

## 先失败一次：用“报错”夺回时间控制权

要消除异步的传染性，就必须找到那个“毒源”——也就是发起网络请求的函数，比如 `fetchUser` 或浏览器内置的 `fetch`。

问题的根源其实很简单：

- 这个函数内部要等待网络返回，它自己变成了异步；
- 一旦它变成 `async` / 返回 `Promise`，上层所有调用者都不得不跟着等待；
- 异步的“效应”顺着调用栈层层向上传播。

那如果它 **“不等”** 呢？

想象我们粗暴地改写一下这类函数：当 `fetchUser` 被调用时，它不再乖乖地 `await` 网络回应，而是干两件事：

1. 正常发起网络请求，但完全不等待结果；
2. 立刻抛出一个值（通常是一个 `Promise`），让当前整条调用链终止执行。

> 注意：这里的“抛出”不一定要是 `Error`，在 JavaScript 里你可以直接 `throw promise`，React Suspense 就是这么干的。关键不在于“是不是错误”，而在于外层能否通过 `try/catch` 识别出：“这是一个表示异步未完成的信号”。

从时间线上看，这是非常微妙的一幕。

- 第一次执行时，`main` 调用 `m3` / `m2` / `m1`，最终调用到我们改造后的 `fetchUser`；
- `fetchUser` 发出真实的网络请求，然后马上抛出一个 `Promise`；
- `Promise` 像炸弹一样沿着调用栈向外扩散，直到最外层控制代码把它接住，整个调用流程在这里断掉，看起来就像是“失败了一次”。

但不要忘记：**虽然同步调用栈已经结束，网络线程还活得好好的。**

那次真实发出的请求仍在外面飞行，一旦远程响应到达，它会在异步回调中“悄悄地”把结果存进某个缓存里——比如：

- 缓存状态：是还在等待，还是已经成功，还是失败；
- 缓存值：成功时的返回数据，或者失败时的错误信息。

于是，世界被切分成了两个时间片：

1. 第一个时间片里，同步调用链快速执行，到 `fetchUser` 的那一刻立即 `throw`，看起来像是一条失败的路径；
2. 第二个时间片里，网络请求慢慢完成，把结果写入缓存，这一切发生在调用链之外。

真正的魔法出现在第三个动作：**一旦请求完成，我们在外层控制逻辑中，再次“重新调用”原来的入口函数 `main`。**

- 这一次，代码仍然从头执行一遍；
- `main` 再调 `m3` / `m2` / `m1`，最终再次来到 `fetchUser`；
- 然而，此时 `fetchUser` 发现缓存里已经有了结果，就不再发请求、不再等待、不再抛出 Promise，而是直接、同步地把缓存里的结果返回给调用者。

就这样，同样的入口函数 `main` 被执行了两次：

- 第一次，以一个“抛出 Promise”结束，为的是给异步请求“留出时间”；
- 第二次，以一个成功返回结束，因为结果已经预先在缓存里等着了。

在这两次执行过程中，对调用方来说，它看到的是两段**完全同步**的流程——没有 `await`，没有回调，`m1` / `m2` / `m3` / `main` 都可以用最天然的、接近纯函数式的写法表达业务逻辑，但异步网络请求的那段等待，却被隔离到了“外部世界”。

异步还在那里，只是它不再沿着调用栈层层传染，而是被锁在一个小小的“效应隔离区”里。

---

## 缓存与重试：把副作用关进“代数牢笼”

要让刚才那套机制真正可靠运转，需要一个略微精致的封装。

### 1. 劫持“毒源”：包装真实的副作用函数

第一步，是把那个真正发网络请求的原始函数保存起来。比如对浏览器的 `window.fetch`：

- 先把原始的 `window.fetch` 取出来，留一份干净的引用；
- 再用一个新的函数覆盖掉同名的 `fetch`，对外暴露的就只剩这个经过“魔改”的版本。

> 这里说“新的同步函数”，是从**调用栈的角度**：
>
> - 要么同步返回缓存结果；
> - 要么同步 `throw promise`；
>   真正的网络 IO 仍然由原始 `fetch` 以异步方式完成，没有变成真正的“同步请求”。

### 2. 定义缓存状态机：pending / fulfilled / rejected

仅仅缓存“上一次成功结果”是不够的，因为请求未必每次都成功。更稳妥的做法，是缓存一个**状态对象**，比如：

- `status`：`pending` / `fulfilled` / `rejected`
- `value`：成功时是结果数据，失败时是错误对象，pending 时是 Promise 自身

一个简化版伪代码大概长这样（为便于理解，略去 key 设计、并发等细节）：

```js
const cache = new Map();

function wrappedFetch(key, realFetch) {
  const entry = cache.get(key);

  if (!entry) {
    // 第一次：发起真实请求，立即标记为 pending，然后 throw promise
    const promise = realFetch().then(
      (data) => cache.set(key, { status: 'fulfilled', value: data }),
      (err) => cache.set(key, { status: 'rejected', value: err }),
    );
    cache.set(key, { status: 'pending', value: promise });
    throw promise; // 故意抛出 Promise，让外层去等
  }

  if (entry.status === 'pending') {
    // 还在路上：继续抛，让外层仍然等这个 Promise
    throw entry.value;
  }

  if (entry.status === 'rejected') {
    // 真实失败：这时是“真正的错误”
    throw entry.value;
  }

  // fulfilled：同步返回结果
  return entry.value;
}
```

有了这个状态机，改造后的 `fetch` 可以走出三条不同路径：

- `fulfilled`：缓存里已有成功数据 → 同步返回；
- `rejected`：缓存里是失败信息 → 同步抛出真正错误；
- `pending` 或暂无缓存：第一次调用 → 发出请求并 `throw promise`。

### 3. “效应运行时”：run(main) 的角色

第三步，是在一个“执行环境”里包装入口函数。可以写一个类似 `run(main)` 的工具函数：

1. 在 `run` 内部，把全局环境里需要劫持的那些副作用函数（比如 `fetch`）替换成我们上面设计的“抛 Promise + 缓存”的变体；
2. 然后尝试执行入口函数 `main`，外面用 `try/catch` 包裹起来，随时准备接住那颗被故意抛出的 `Promise`；
3. 如果执行过程中没有任何 `throw` 发生，那么说明所有需要的异步结果都已经事先准备好了，代码可以一次性顺利执行到尾；
4. 如果捕获到了一个或多个 `Promise`，就说明至少有一处异步结果尚未就绪：
   - 简单实现：每次只处理第一个 `Promise`，等它完成后再 `run(main)` 一次，反复直到不再有 Promise 抛出；
   - 更工程一点的实现：收集本轮执行中抛出的所有 Promise，用 `Promise.all` 等待全部完成，再重试一次 `main`。

循环结束之后，无论成功还是失败，`run` 最后都会把全局环境中的 `fetch` 等函数还原成最初的版本，避免这套“代数效应”机制溢出到其他代码。

### 4. 一个非常关键的前提：可重入、可重放

注意，这种“多次执行”模型有一个非常重要的前提：

> **入口函数 `main` 以及整条调用链中的逻辑，必须“基本纯”和“可重放”。**

也就是说：

- 它们不能在执行过程中做“一次性副作用”，例如实际扣库存、扣余额、发支付指令、写不可逆日志等；
- 因为一旦这样做，每次重试 `main` 都可能重复执行这些操作，后果很严重（比如重复扣款）。

这也是为什么 React 一再强调：**render 必须是纯函数**——因为 React 的渲染过程天生是可以被打断、重试、甚至回滚的。如果在 render 中做副作用，重试机制就会把这些副作用放大成灾难。

**总结一下这一层：**

- 这个模型非常适合用在“渲染函数 / 读取数据 / 纯计算”这种可重放的逻辑上；
- 对于“不可重复执行”的副作用，应该单独放到另一个层级（例如 React 的 `useEffect`、服务端的事务 / 工作队列等）。

到这里，我们已经把副作用关进了一个“小牢笼”：
真实请求在牢笼里；上层的纯函数世界每次看到的，要么是同步结果，要么是同步的“请你去等一下”的信号。

---

## 当 React 也学会“故意抛错”：Suspense 的幕后戏法

如果只停留在抽象的思维实验层面，这套技巧多少还有些“概念工程”的味道。真正让它显得鲜活的，是当你意识到：

> 这种思路已经在现代主流前端框架中大量落地，
> 而你日常写业务时，很可能就在受益于它。

最典型的例子，就是 React 里的 `Suspense` 机制。

看一下一个很常见的用法：在根组件里包一个 `Suspense` 边界，里面渲染两个子组件，比如 `UserView` 和 `TodoView`。每个子组件内部都要从远程获取数据，但 React 提供了一种看起来非常魔幻的写法——在组件内部完全没有显式的异步逻辑：

```jsx ｜ pure
function UserView() {
  const user = userResource.read();
  return <div>{user.name}</div>;
}
```

`userResource.read()` 明明是在读一份尚未就绪的远程数据，但函数里看不到 `async`，看不到 `await`，也看不到回调。它看起来就像在读一块已经存在的内存。

真正的秘密就在于：当数据还没准备好时，`read()` 并不会返回，而是 **“故意抛出一个 Promise”**。

这和我们前面为 `fetch` 设计的行为如出一辙：

1. 第一次渲染组件树时，React 会按顺序执行每一个函数组件；
2. 执行到 `UserView` 的时候，`userResource.read()` 发现还没有缓存到数据，于是发起真实的网络请求，然后直接 `throw promise`；
3. 这个 `Promise` 被 React 的 `Suspense` 边界捕获，React 意识到：“哦，这不是普通异常，这是一个表示‘还在加载中’的信号。”

于是，在这一次渲染尝试中，React 放弃继续往下构建整棵树，而是根据 `Suspense` 的配置，渲染一个“正在加载”的占位界面。与此同时，网络请求在后台缓缓进行，直到某个时刻成功或失败。

当那个 `Promise` 最终完成时，React 的调度器会再一次触发整个组件树的渲染流程。第二次执行 `UserView`，`userResource.read()` 发现缓存状态已经变成 `fulfilled`，自然可以同步返回真实数据。于是这一回，渲染可以完整走完，用户看到了真正的界面。

你会发现，这与我们一开始举的那个**两次执行**的示意图高度类似：

- 第一次执行，以“抛出 Promise 的错误”结束，换来一段等待时间；
- 第二次执行，以“所有异步数据已经就绪”的状态完成，让组件函数在表面上保持同步。

唯一的差别是：

- 在我们手写的示例里，整套逻辑由开发者自行写 `run(main)` 来控制；
- 在 React 里，这一切被封装进了框架的渲染引擎，由 `Suspense` 帮你捕获、调度和重试。

你只需要按照“**纯函数组件**”的样子写业务代码，其余的交给运行时。

> 工程上的小现实：
>
> - React 官方目前推荐的数据获取方案大多仍基于 hooks（如 `useEffect`）；
> - Suspense for data fetching 在真实项目里通常依赖特定的数据层（如 Relay、React Query 的实验特性等）；
> - 但“组件通过抛 Promise 把异步交给运行时”已经是一个被广泛接受的底层模型。

理解这一点时，很多人第一次会有一种“原来 React 是这样动的”的恍然大悟：

> 原来那个风评极高的 `Suspense`，本质上是一种“代数效应”在 UI 渲染领域的具体实践——组件函数通过抛出一个 Promise，把异步这一副作用交给外层的 React 运行时来处理，而自己始终维持一种“纯粹”的函数表达。

---

## “双阶段求值”模型：如何在自己的代码里隔离副作用

把这些线索串起来，会出现一个非常清晰的思维模型，可以叫它——**双阶段求值模型**。

### 1. 第一阶段：发现缺失（主动“失败”）

第一阶段，是“发现缺失”的阶段：

- 函数在执行过程中，一旦发现自己需要某个外部世界的异步结果——例如网络请求、磁盘读写、复杂计算——却暂时拿不到；
- 就立刻中断正常流程，抛出一个带有语义的信号（在我们的例子里是一个 Promise，或者封装了 Promise 的对象）；
- 这个信号告诉外层运行时：“我现在还不具备完成运算的条件，请帮我把条件准备好。”

此时的“失败”是一种**策略性撤退**，而不是“意料之外的异常”。

### 2. 第二阶段：条件满足后的重试（成功“同步”）

第二阶段，是“条件满足后的重试”阶段：

- 运行时接住这个信号之后，不会简单地把它当成错误，而是根据它包含的信息，组织实际的副作用操作；
  - 比如发出网络请求；
  - 订阅回调；
  - 写入缓存；
- 等到这些操作完成，运行时再重新触发同一个函数或同一段计算逻辑，让它在“条件已经具备”的新世界里，从头再走一遍。

如果沿用代数效应（Algebraic Effects）的术语，那么：

- 函数抛出的东西可以看作是一个“效应值”；
- 它不是简单的错误，而是一种对外部世界的请求；
- 运行时捕获并处理这些效应，把具体的副作用行为封装起来，再把纯粹的计算逻辑重跑一次，就完成了副作用与纯函数的分离。

### 3. 这个模型的几个关键特征

这个模型有几个非常重要的、值得刻意记住的特点：

**（1）把“失败”当作控制流工具**

第一次执行时的“失败”其实是一种策略性中断，它不是 Bug，而是一种设计好的机制：

- 通过故意失败，把**时间维度**的问题（等待异步）；
- 转化为**结构维度**的问题（多执行一次）。

**（2）强迫你设计清晰的“边界层”**

所有副作用都应该集中在一个可控的壳里：

- 无论是一个 `run` 函数；
- 一个框架的调度器；
- 还是某个中间件容器。

这个边界层负责：

- 捕获效应；
- 等待异步完成；
- 决定何时重试。

边界内部的业务逻辑，则尽量保持纯净、确定可推理。

**（3）让“缓存”变成一等公民**

缓存不再只是一个藏在角落里的性能优化，而是参与控制流设计的核心部分：

- 你用状态（pending/fulfilled/rejected）加上值，来表达一个异步请求在时间轴上的位置；
- 用一致的读取逻辑（例如 `read()` 或封装后的 `wrappedFetch`）来隐藏背后的复杂性；
- 最终让调用者感觉自己只是在读一份普通数据，而不是操控一个异步任务。

**（4）它和类型系统天然兼容**

从 TypeScript / 类型层面看，这种模式有一个很实在的好处：

- 如果把异步效应推到边界，很多函数签名就可以保持 `T -> U`；
- 而不是层层变成 `T -> Promise<U>`；
- 对应到 TS 中，函数组合和推导都会变得更简单，代码更容易“像数学式子一样”组合。

在实践层面，这种思路远不止适用于 HTTP 请求。任何需要把副作用从业务逻辑中剥离出来的场景——例如统一的错误上报、埋点、权限检查、跨模块数据依赖——都可以从中受益。

只要你愿意把“先失败一次、等待条件、再重试”的模式内化成一种工具，你就多了一种从容解决复杂问题的武器。

---
