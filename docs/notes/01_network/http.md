---
title: HTTP 篇
order: 5
toc: content
group:
  title: 基础知识
---

## HTTP 是什么？

HTTP，即 HyperText Transfer Protocol (超文本传输协议)，是互联网上使用最广泛的协议之一，专门设计用于在网络中传输超文本数据。要充分理解 HTTP 的工作原理和重要性，我们可以将其分为三个基本组成部分：超文本、传输和协议。

1. **超文本：超越传统文本的界限**

   超文本不仅仅局限于文字。它是一种包含音频、视频、图片和文件的综合体，最独特的特征在于它包含超链接。这些超链接允许用户点击链接跳转到其他页面，正是这些链接构建了互联网的基础架构。通过超链接，互联网成为了一个相互连接的网状结构，使得信息的获取变得前所未有的便捷。

2. **传输：数据的双向流动**

   传输过程涉及至少两个参与方，通常被称为请求方和响应方。在这个过程中，超文本数据被封装成二进制数据包，根据 HTTP 协议的规范在网络中传输。值得注意的是，传输过程不仅限于两个参与者，也允许数据通过中转或接力的方式进行传递，只要所有参与者遵循相同的协议规范。

   ![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-1.jpg)

3. **协议：规则与约定的体系**

   HTTP 协议是一套预定义的规则和标准，用于指导数据如何在网络中传输。就像日常生活中的各种协议一样，HTTP 协议定义了数据传输的格式和过程，确保信息能够正确、高效地在参与者之间传递。

通过这些组成部分，我们可以得出 HTTP 的定义：**HTTP 是一种协议，专门用于在计算机世界里的两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。**

至于说 “HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议”，这种说法虽然描述了 HTTP 的一种常见用途，但并不全面。**HTTP 同样适用于服务器之间的数据传输**，因此，将其定义为 “在两点之间传输超文本数据的协议” 更为准确。

## HTTP 的核心特性

HTTP 协议，作为互联网通信的基石，随着技术的发展已经演化出了多个版本，包括 HTTP/1.1、HTTP/2.0、以及 HTTP/3.0。每个版本都有其独特的特性和改进点，以适应不断变化的网络需求。我们首先聚焦于 HTTP/1.1 版本的核心特性，并将在后续的讨论中探索更高版本的特性。

1. **简单**：HTTP 协议的设计以简洁为核心，采用了易于理解的 `header + body` 的报文结构。头部信息遵循键值对的形式，使得协议的学习和使用门槛大大降低。

2. **灵活与可扩展**：HTTP 协议的灵活性主要体现在两个方面。首先，在 HTTP/1.0 中引入的 HTTP 标头 (header) 让协议扩展变得非常容易。只要服务端客户端之间对新标头的语义经过简单协商，新功能就可以被加入进来。其次，由于 HTTP 协议工作在应用层，它可以适应下层协议的变化。例如，虽然 HTTP/1.1 和 HTTP/2.0 主要基于 TCP 协议，HTTP/3.0 则采用了 UDP 协议，显示出其对底层传输技术的适应性。

3. **无状态**：HTTP 是一个无状态的协议，意味着每次请求之间是相互独立的，不需要保留之前的任何状态信息。这简化了交互模式，但同时也促生了如 Cookie 等技术来跨请求保存状态。

4. **明文传输**：HTTP 的明文传输带来的问题是无法防止中间人截获、盗取和篡改信息，从你的路由器、运营商到对方服务器，中间每一步都是明文。这里面可下手的地方太多了。

## [HTTP 是一个无状态的协议。这句话里的无状态是什么意思？](https://www.zhihu.com/question/23202402/answer/527748675)

### 理解有状态协议

在网络通信中，许多协议设计为 “有状态”，这意味着通信过程中的每一步都依赖于之前的状态。以 SMTP 协议为例，其通信开始于 “HELO” 命令进行握手，随后可能进行身份验证 (AUTH)，然后传输邮件数据，最终通过 “QUIT” 命令结束会话。**这种设计要求通信双方在整个会话中持续跟踪状态，因为不同状态下可接受的命令不同，且之前的命令可能影响后续操作。**

### HTTP 的无状态设计

与此不同，**HTTP 协议被设计为无状态，每个请求独立，包含处理该请求所需的全部信息**。这意味着请求之间相互独立，一个请求的失败不会影响到后续请求的处理。虽然 HTTP 协议本身具有复杂性，但其无状态设计是为了简化交互和实现。

### 无状态设计的优势

HTTP 的无状态特性并非不利，反而提供了显著优势。例如，将会话状态与连接解绑，使用如 Cookies 这样的元数据维护会话，可以在连接断开后保持会话状态。**对于有状态协议来说，如果将会话状态与连接绑定在一起，那么如果连接意外断开，整个会话就会丢失，重新连接之后一般需要从头开始**。此外，无状态设计简化了中间件的实现，因为中间件不需要理解通信的具体内容，只需正确转发请求即可，这对于负载均衡等功能尤为重要。

### 无状态设计的挑战

然而，无状态协议也有其挑战。**每个请求必须携带所有必要信息，导致请求可能包含大量重复的元数据，增加了消息的复杂性和传输负担**。此外，频繁传输相同的元数据 (如 Host、Authentication) 可能降低效率。

### HTTP 的进阶特性与状态管理

HTTP 协议通过引入如 `Expect: 100-Continue` 机制优化数据传输，允许客户端在发送大量数据前确认服务器的接受意愿，这**虽然引入了轻量级的状态交互，但不改变 HTTP 的无状态本质**。进一步地，HTTP/2 通过多路复用和流的概念改进性能，**引入了传输层面的状态管理，但这并不影响 HTTP 处理请求和响应的无状态特性**，仍旨在提高数据传输效率而非维护应用状态。

## HTTP 报文

HTTP/1.1 以及更早的 HTTP 协议报文都是语义可读的。在 HTTP/2 中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文标头的压缩以及多路复用。即使只有原始 HTTP 报文的一部分以 HTTP/2 发送出来，每条报文的语义依旧不变，客户端会重组原始 HTTP/1.1 请求。因此用 HTTP/1.1 格式来理解 HTTP/2 报文仍旧有效。

有两种 HTTP 报文的类型，**请求**与**响应**，每种都有其特定的格式。

HTTP 报文本身是由多个部分组成的，主要分为三大部分：起始行 (Start line)、头部字段 (Headers) 和消息正文 (Body)。

### 起始行 (Start Line)

- **请求报文的起始行**包含了方法 (如 GET、POST)、请求的资源 URI (Uniform Resource Identifier) 和 HTTP 版本。例如：`GET /index.html HTTP/1.1`。
- **响应报文的起始行**包含了 HTTP 版本、状态码 (如 200、404) 和状态消息 (如 OK、Not Found)。例如：`HTTP/1.1 200 OK`。

### 头部字段 (Headers)

头部字段用于传送关于请求或响应的元信息，以及客户端和服务器之间的其他信息。头部字段是键值对的形式，例如 `Content-Type: text/html` 表示资源是 HTML 文档。头部字段有很多种，包括但不限于：

- `Content-Length`：消息正文的长度。
- `Content-Type`：消息正文的 MIME 类型。
- `Host`：指明了请求将要发送到的服务器主机名和端口号。如果没有包含端口号，会自动使用被请求服务的默认端口 (比如 HTTPS URL 使用 443 端口，HTTP URL 使用 80 端口)。
- `User-Agent`：发起请求的客户端信息。
- `Accept`：客户端能处理的媒体类型。
- `Cookie`：服务器之前发送的 Cookie。
- `Cache-Control`：缓存控制指令。

### 消息正文 (Body)

消息正文包含了发送的数据。不是所有的 HTTP 报文都有正文部分，例如 GET 请求通常没有正文，而 POST 请求的正文通常包含了用户提交的表单数据。正文的类型和长度由起始行和头部字段共同决定。

### 报文结构示例

#### 请求报文示例

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-7.jpg)

```sh
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Connection: keep-alive
```

#### 响应报文示例

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-8.jpg)

```sh
HTTP/1.1 200 OK
Date: Mon, 23 May 2022 22:38:34 GMT
Server: Apache/2.4.1 (Unix)
Last-Modified: Wed, 12 April 2022 01:23:45 GMT
Content-Type: text/html
Content-Length: 1234

<html>
<head>
    <title>An Example Page</title>
</head>
<body>
    <p>Hello World, this is a very simple HTML document.</p>
</body>
</html>
```

## HTTP 资源标识

HTTP 请求的内容通称为 “资源”。”资源 “这一概念非常宽泛，它可以是一份文档，一张图片，或所有其他你能够想到的格式。每个资源都由一个 ([URI](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web#%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E8%AF%AD%E6%B3%95_uri)) 来进行标识。

一般情况下，资源的名称和位置由同一个 URL (统一资源定位符，它是 URI 的一种) 来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。

> [对 Web 开发者至关重要的 MIME 类型](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types#%E5%AF%B9_web_%E5%BC%80%E5%8F%91%E8%80%85%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81%E7%9A%84_mime_%E7%B1%BB%E5%9E%8B)

- **application/octet-stream**：这是二进制文件的默认值。由于这意味着未知的二进制文件，浏览器一般不会自动执行或询问执行。浏览器将这些文件视为 Content-Disposition 标头被设置为 attachment 一样 (意味着消息体应该被下载到本地；大多数浏览器会呈现一个 “保存为” 的对话框，将 filename 的值预填为下载后的文件名，假如它存在的话)，并弹出 “另存为” 对话框。

- **text/plain**：这是文本文件的默认值。即使它其实意味着未知的文本文件，但浏览器认为是可以直接展示的。

  > 备注：`text/plain` 并不意味 “任何种类的文本数据”。如果浏览器期待的是某种特定的文本数据，很可能不会将其视为匹配。具体来说，如果从声明 CSS 文件的 `<link>` 元素中下载了一个 `text/plain` 文件，那么如果提供的是 `text/plain` 类型，就不会将其识别为有效的 CSS 文件。CSS MIME 类型需要使用 `text/css`。

## GET 和 POST

### GET 和 POST 有什么区别？

根据 RFC 规范，**GET 的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符，而且**浏览器会对 URL 的长度有限制** (HTTP 协议本身对 URL 长度并没有做任何规定)。

根据 RFC 规范，**POST 的语义是根据请求负荷 (报文 body) 对指定的资源做出处理**，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。

### GET 和 POST 方法都是安全和幂等的吗？

先说明下安全和幂等的概念：

- **安全**指的是请求不会修改服务器上的资源。
- **幂等**指的是执行相同操作多次与执行一次的效果相同。

如果从 RFC 规范定义的语义来看：

**GET 请求既安全又幂等**，因为它不修改资源且结果一致。**而 POST 请求既不安全也不幂等**，因为它可能会修改服务器上的资源，并且相同的请求可能会创建多个资源实例。

所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上 (彻底避免浏览器发请求)，也可以做到代理上 (如 nginx)，而且在浏览器中 GET 请求可以保存为书签。

注意，上面是从 RFC 规范定义的语义来分析的。

但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：

- 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
- 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

### POST 是否比 GET 安全？

当我们讨论 “安全性”——特别是指信息泄露的风险时，POST 要比 GET 安全一点点，注意，是一点点。。。

GET 请求通过 URL 传输数据，而 POST 请求则将数据存储在 HTTP 请求的 body 部分。这种差异并不意味着 POST 绝对比 GET 更安全，因为无论是 GET 还是 POST，HTTP 协议传输的内容均为明文。在浏览器地址栏虽然看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。

两种方法都以明文形式传送数据，但存在一个微妙的区别：GET 请求的 URL 可能会被存储在浏览器历史记录和 Web 服务器日志中。相比之下，POST 请求的数据在发送后不会留存这样的痕迹。

所以如果你把关键数据放在 GET 里面，被人偷窥了浏览器，或者 WEB 服务器被入侵日志被人倒去了，基本泄露可能性 100%。而 POST 来说，日志没有记录，只要数据库服务器不被入侵，基本还是安全的。当然如果被抓了包，这一切都没有什么卵用，所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。

### GET 请求可以带 body 吗？

RFC 规范并没有规定 GET 请求不能带 body 的。**理论上，任何请求都可以带 body 的**。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。

另外，URL 中的查询参数也不是 GET 所独有的，**POST 请求的 URL 中也可以有参数的**。

### GET 相对 POST 的优势是什么？

最大的优势是，GET 的 URL 可以人肉手输啊。。。本质上面，GET 的所有信息都在 URL，所以很方便的记录下来重复使用。

### 拓展阅读

> [公司规定所有接口都用 post 请求，这是为什么？](https://www.zhihu.com/question/336797348/answer/2189330351)

## HTTP 状态码

**状态码分类：**

- **1xx 类状态码**属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
- **2xx 类状态码**表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
- **3xx 类状态码**表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
- **4xx 类状态码**表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。
- **5xx 类状态码**表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。

**常见状态码详解：**

- “200 OK” 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- “204 No Content” 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- “206 Partial Content” 是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
- “301 Moved Permanently” 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- “302 Moved Permanently” 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
- “304 Not Modified” 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。
- “400 Bad Request” 表示客户端请求的报文有错误，但只是个笼统的错误。
- “403 Forbidden” 表示服务器禁止访问资源，并不是客户端的请求出错。
- “404 Not Found” 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
- “500 Internal Server Error” 与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- “501 Not Implemented” 表示客户端请求的功能还不支持，类似 “即将开业，敬请期待” 的意思。
- “502 Bad Gateway” 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- “503 Service Unavailable” 表示服务器当前很忙，暂时无法响应服务器，类似 “网络服务正忙，请稍后重试” 的意思。

**拓展阅读：**

> [为什么那么多公司做前后端分离项目后端响应的 HTTP 状态一律 200？](https://www.zhihu.com/question/513865370/answer/2344277817)

## HTTP 缓存管理

对于资源来说，由于有些挺长时间内都不会更新，所以没必要每次请求都向 server 发起网络请求，如果第一次请求后能保存在本地，下次请求直接在本地取，那无疑会快得多，对服务器的压力也会减少。

HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存。

### 强制缓存

**强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。**

与强缓存相关的 `header` 字段有两个：

- Cache-Control，是一个相对时间。
- Expires，是一个绝对时间。

> ⚠️ 如果 Cache-Control 存在，则 Expires 失效。

<!-- 理解成闹钟 -->

**⏰ Expires**：这是 http 1.0 时的规范；它的值为一个绝对时间的 GMT 格式的时间字符串，如 `Mon, 10 Jun 2015 21:31:12 GMT`，如果发送请求的时间在 Expires 之前，那么本地缓存始终有效，否则就会发送请求到服务器去获取资源。可以理解成闹钟。

<!-- 理解成租房合同，max-age 指租房期限 -->

另一个请求头为 `Cache-Control`。**这个缓存指令是单向的**，也就是说请求中设置的指令，不一定包含在响应中，请求中如果没有传 `Cache-Control`，`server` 也可以返回 `Cache-Control`。可以理解成租房合同，max-age 指租房期限。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-10.jpg)

**如图示：客户端发起请求后，服务器返回 `Cache-Control：max-age=30`，代表资源在客户端可以缓存 30 秒，30 秒内客户端的请求可以直接从缓存获取，超过 30 秒后需要向服务器发起网络请求。**

`max-age` 是 HTTP 缓存控制最常用的属性，**表示资源存储的最长时间**，需要注意的是，时间的计算起点是响应报文的创建时刻 (即 `Date` 字段，也就是**离开服务器的时刻**)，超过后客户端需要重新发起请求。

除此之外，Cache-Control 其它属性值如下：

- `no-cache`：**缓存但重新验证**，服务器端会验证请求中所描述的缓存是否过期，若未过期 (注：实际就是返回 304)，则缓存才使用本地缓存副本。
- `no-store`：**不允许缓存**，比如秒杀页面这样变化非常频繁的页面就不适合缓存。
- `must-revalidate`：一旦资源过期 (比如已经超过 `max-age`)，在成功向原始服务器验证之前，不能使用缓存。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-11.jpg)

`Cache-Control` 只能刷新数据，但不能很好地利用缓存，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版，存在一定的性能稳定，所以 HTTP 又引入了条件缓存 (协商缓存)。

### 协商缓存

**协商缓存，顾名思义需要和服务器进行一次协商**。浏览器第一次请求时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。

再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端比较成功，可以使用缓存数据。

判断请求主要靠下面两组 HTTP Header：

- `Last-Modified`：一个 `Response Header`，服务器在响应请求时，告诉浏览器资源的最后修改时间。
- `if-Modified-Since`：一个 `Request Header`，再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。

服务器会通过收到的 `If-Modified-Since` 和资源的最后修改时间进行比对，判断是否使用缓存。

- `Etag`：一个 `Response Header`，服务器返回的资源的唯一标示
- `If-None-Match`：一个 `Request Header`，再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。

服务器会通过收到的 `If-None-Match` 和资源的唯一标识进行对比，判断是否使用缓存。

**详细解释：**

- `if-Modified-Since`：指的是文件最后修改时间，服务器只在所请求的资源**在给定的日期时间之后对内容进行过修改的情况下**才会将资源返回，如果请求的资源从那时起未经修改，那么**返回一个不带有消息主体的 `304` 响应**，需要第一次请求提供 `Last-modified`，只能精确到一秒，第二次请求就可以在 `if-Modified-Since` 首部带上此值了。

- `If-None-Match`：条件请求首部，对于 GET 和 HEAD 请求方法来说，当且仅当服务器上没有任何资源的 `ETag` 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 `200`，

> ETag 是实体标签 (Entity Tag) 的缩写，是资源的唯一标识，主要解决修改时间无法准确区分文件变化的问题，比如文件在一秒内修改了多次，由于修改时间是秒级的，用 `if-Modified-Since` 就会误认为资源没有变化，而每次文件修改了都会修改 `ETag`，也就是说 `ETag` 可以精确识别资源的变动，所以如果对资源变化很敏感觉的话，应该用 `If-None-Match`
>
> 注：ETag 有强，弱之分，强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有 “W/” 标记，只要求资源在语义上没啥变化，比如加了几个空格等等。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-12.jpg)

需要注意的是不管是 `if-Modified-Since` 还是 `If-None-Match`，**这两者只会在资源过期 (即存活时间超 max-age) 后才会触发**。

## HTTP/1.1、HTTP/2、HTTP/3 演变

### HTTP/1.1

#### 短连接和长连接

首先我们知道双方要建立可靠连接要经过 TCP 的三次握手，然后才能开始传输 HTTP 的报文，报文传输之后要经过四次挥手断开连接。

HTTP 最早期的模型和 HTTP/1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。

HTTP/1.1 对此进行了改进，每次报文发送后不立即关闭，可复用，长连接由于减少了大量无意义的三次握手，四次挥手，效率大大提升了！

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-13.jpg)

我们可以在请求头里明确要求使用长连接，指定 `Connection: keep-alive` 即可，**在 HTTP/1.1 就算不指定也是默认开启的**。

> 如果服务器支持长连接，不管客户端是否显式要求长连接，它都会在返回头里带上 `Connection: keep-alive`，这样接下来双方就会使用长连接来收发报文，客户端如果想显式关闭关闭，只需要指定 `Connection: Close` 头字段即可。

#### 对头阻塞

长连接让传输效率大大提升，但新的问题又来了，当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是 “队头阻塞”，好比上班的路上塞车。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-14.jpg)

#### 性能瓶颈

- 请求 / 响应头部 (Header) 未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

#### HTTP 流水线

> **注意!!!**
>
> 今天，所有遵循 HTTP/1.1 标准的代理和服务器都应该支持流水线，虽然实际情况中还是有很多限制：一个很重要的原因是，目前没有现代浏览器默认启用这个特性。

HTTP/1.1 采用了长连接的方式，这使得 HTTP 流水线传输成为了可能。

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**

举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，HTTP 流水线则是允许浏览器同时发出 A 请求和 B 请求，如下图：

![20240416174953](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240416174953.png)

但是**服务器必须按照接收请求的顺序发送对这些请求的响应**。

如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为 “队头堵塞”。

所以，**HTTP/1.1 流水线解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

#### 域名分片

> 备注：除非你有紧急而迫切的需求，不要使用这一过时的技术；而是升级到 HTTP/2。在 HTTP/2 里，做域名分片就没必要了：HTTP/2 的连接可以很好的处理并发的无优先级的请求。域名分片甚至会影响性能。大多数 HTTP/2 的实现还会使用一种称作连接聚合的技术去尝试合并被分片的域名。

域名分片 (Domain Sharding) 是一种提高网站性能的技术，主要用于优化资源的加载时间。这种技术涉及将网站的资源分散到多个子域名上，以便并行下载资源，从而减少页面加载时间。域名分片的核心思想是绕过浏览器对于单一域名下并行下载资源数量的限制。

##### 背景

早期的 HTTP/1.1 协议和浏览器对于同一域名下的并发连接数有限制，通常为每个域名 6-8 个连接。这意味着，如果一个页面有大量的资源 (如图片、CSS 文件、JavaScript 文件等) 需要从同一个域名下载，浏览器会分批次进行，导致页面加载时间增加。

##### 实施方式

- **子域名创建**：网站管理员会创建多个子域名 (如 img1.example.com、img2.example.com)。
- **资源分配**：将页面上的资源 (如图片、样式表、脚本等) 分散存储到这些子域名上。
- **并行下载**：当用户访问网站时，浏览器可以同时从这些不同的子域名下载资源，因为每个子域名都被视为独立的来源。

##### 优点

- **提高页面加载速度**：通过并行下载更多资源，减少页面的加载时间。
- **提升用户体验**：网页加载速度是用户体验的重要组成部分，快速的加载速度可以显著提升用户满意度。

##### 缺点

- **DNS 解析开销**：每个新的子域名都需要进行 DNS 解析，这可能会带来额外的时间开销。
- **可能影响缓存**：由于资源分散在不同的子域名上，可能会影响浏览器缓存的有效性。
- **复杂性增加**：管理多个子域名增加了网站维护的复杂性。

### HTTP/2

#### 头部压缩

HTTP/1.1 考虑了 `body` 的压缩，但没有考虑 `header` 的压缩，经常出现传了头部上百，上千字节，但 `Body` 却只有几十字节的情况，浪费了带宽。

HTTP/2 不仅压缩头 (Header)，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-18.jpg)

#### 二进制帧

**HTTP/1.1 是纯文本形式，而 2.0 是完全的二进制形式**，它把 TCP 协议的部分特性挪到了应用层，把原来的 `Header + Body` 消息打散为了数个小版的二进制 “帧” (Frame)，“HEADERS” 帧存放头数据、“DATA” 帧存放实体数据。

#### 并发传输

知道了 HTTP/2 的帧结构后，我们再来看看它是如何实现并发传输的。

HTTP/2 定义了 “流” (stream) 的的概念，它是二进制帧的双向传输序列，同一个消息往返的数据帧 (header 帧和 data 帧) 会分配一个唯一的流 ID，**这样我们就能区分每一个请求**。在这个虚拟的流里，数据帧按先后次序传输，到达应答方后，将这些数据帧按它们的先后顺序组装起来，最后解析 HTTP/1.1 的请求头和实体。

**在同一时间，请求方可以在流里发请求，应答方也可以也流里发响应，对比 HTTP/1.1 一个连接一次只能处理一次请求-应答，吞吐量大大提升。**

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-23.jpg)

所有的流都是在同一个 TCP 连接中流动的，这也是 HTTP/2 经典的**多路复用**，另外由于每个流都是独立的，所以谁先处理好请求，谁就可以先将响应通过连接发送给对方，也就解决了队头阻塞的问题。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/http-19.jpg)

HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求，所以 HTTP/2 依然存在着队头阻塞。

HTTP/2 还可以对每个 Stream 设置不同优先级，帧头中的 “标志位” 可以设置优先级，比如客户端访问 HTML/CSS 和图片资源时，希望服务器先传递 HTML/CSS，再传图片，那么就可以通过设置 Stream 的优先级来实现，以此提高用户体验。

#### 服务器推送

> [从 Chrome 中移除 HTTP/2 服务器推送](https://developer.chrome.com/blog/removing-push?hl=zh-cn)

HTTP/2 还在一定程度上改善了传统的 “请求 - 应答” 工作模式，服务端不再是被动地响应，可以主动向客户端发送消息。

比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返。

![20240417063321](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240417063321.png)

在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。

在 Nginx 中，如果你希望客户端访问 `/test.html` 时，服务器直接推送 `/test.css`，那么可以这么配置：

```sh
location /test.html {
  http2_push /test.css;
}
```

### HTTP/3

> [QUIC 是如何解决 TCP 性能瓶颈的？](https://mp.weixin.qq.com/s/6SIA_YZSEu1K2yJDhB56Kw)

HTTP/2 引入了头部压缩、二进制编码、多路复用和服务器推送等技术，显著提高了相比于 HTTP/1.1 的性能。然而，HTTP/2 仍然依赖于 TCP 协议，继承了 TCP 的一些固有弱点。

UDP 协议虽然简单且不保证数据包的可靠到达、顺序或依赖性，但它不需要建立连接，因此在理论上具有更低的延迟。

HTTP/3 并不是简单地将传输层协议从 TCP 切换到 UDP，而是在 UDP 之上实现了 QUIC 协议。**QUIC 集成了 TCP 的连接管理、拥塞控制和流量控制等特性，同时加入了 TLS 加密和 HTTP/2 的多路复用能力**，这些设计使得 QUIC 既保持了 UDP 的低延迟特性，又不失传输的可靠性。

QUIC 协议的引入，确实面临了一些挑战。**由于它是基于 UDP 的，而很多现有网络设备对 UDP 的支持不如 TCP，甚至可能将 UDP 数据包直接丢弃，这对 QUIC 的稳定性和普及构成了挑战。**

尽管 HTTP/3 的普及进度缓慢，但它代表了网络通信技术的一大步进。它尝试解决了长久以来困扰 TCP 性能的问题，并且提供了一种更加高效、可靠的网络传输方式。未来，随着网络设备和协议的不断更新和优化，HTTP/3 有潜力改变现有的网络通信格局。

## [既然有 HTTP 协议，为什么还要有 RPC？](https://www.zhihu.com/question/41609070)

TCP 是有三个特点，面向连接、可靠、基于字节流。

字节流可以理解为一个双向的通道里流淌的数据，这个数据其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。纯裸 TCP 收发的这些 01 串之间是没有任何边界的，你根本不知道到哪个地方才算一条完整消息。

![20240417071140](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240417071140.png)

正因为这个没有任何边界的特点，导致接收方难以判定一条消息的起始和结束，这就是所谓的 “粘包问题”。

**纯裸 TCP 是不能直接拿来用的，为了解决这一问题，必须在 TCP 之上定义一些自定义规则来区分消息的边界。这导致了各种应用层协议的产生，其中 HTTP 和各类 RPC 协议就是这样的例子。**

HTTP 协议主要被应用于浏览器/服务器 (B/S) 架构中，而 RPC (远程过程调用) 协议更多地服务于客户端/服务器 (C/S) 架构。尽管历史上这两者被清晰地区分开，但随着技术的发展，B/S 和 C/S 架构正在逐渐融合。在这种背景下，软件往往需要同时支持多种终端，因此对外部交互主要采用 HTTP 协议，而内部微服务间的通信则更倾向于使用 RPC 协议。

值得注意的是，RPC 技术在时间线上比 HTTP 更早出现，并且在性能方面，它通常优于当下主流的 HTTP/1.1 协议。因此，尽管 HTTP/2.0 对 HTTP/1.1 进行了显著的性能优化，甚至在某些方面超越了许多 RPC 协议，但其较晚的出现时间意味着 RPC 在很多公司的内部通信中仍占据着不可替代的地位。

## [HTTPS](https://xiaolincoding.com/network/2_http/http_interview.html#https-%E8%A7%A3%E5%86%B3%E4%BA%86-http-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98)

HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 `80`，HTTPS 是 `443`。

> [破玩意 —— 用 HTTPS 传纸条](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247497199&idx=1&sn=d4cdcfe5449f62f1a32feb7336da8d3f&chksm=c2c58f42f5b20654107f77cc84aafd73963a48bac37834aeab43ecc7747b2989459e2373b25e&scene=178&cur_album_id=1703494881072955395#rd)

**对称加解锁**：单钥匙锁，解锁需要钥匙，同时上锁也需要钥匙。

![](<https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/640%20(1).gif>)

**非对称加解锁**：双钥匙锁，用钥匙 A 加锁，必须用钥匙 B 才能解锁。反过来用钥匙 B 加锁，必须用钥匙 A 才能解锁。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/640.gif)

**签名和加密的区别：**

- **公钥加密，私钥解密，这个叫加密**，是为了保证内容安全，因为私钥只有自己知道，是为了保证这个信息不被中间人解开。
- **私钥加密，公钥解密，这个叫签名**，是为了防止内容被篡改，因为公钥所有人都知道，所有人都能看到这个信息做验证。

> [西方机构吊销了俄罗斯的 HTTPS 证书有什么影响吗？](https://www.zhihu.com/question/523817733/answer/2440936723)

A 和 B 通信，A 收到由证书认证机构 C 颁发的 B 的证书后认定自己确实是在和 B 通信，而不是和 D 冒充的 B 通信，这是证书的作用。

打个比方，你作为普通用户在淘宝上经过淘宝官方认证的苹果官方旗舰店买 iPhone，你相信这家店是真的苹果官方旗舰店，这是因为你相信淘宝的认证。要是哪天淘宝和华强北串通，华强北在淘宝上也开一家叫 “苹果官方旗舰店” 的店而且得到淘宝官方认证，你就有可能在 “官方旗舰店” 买到假 iPhone。

> HTTPS 真的完全安全吗？

HTTPS 协议被设计为安全的网络传输协议，到目前为止，它本身并未被发现有明显漏洞。然而，当你听说有人成功执行了所谓的 “中间人攻击”，这通常是因为攻击者利用了客户端的弱点，如用户忽略安全警告继续访问不安全的网站，或者用户的设备被安装了伪造的根证书。这些情况并不表明 HTTPS 本身不安全。

> 为何抓包工具能够截获 HTTPS 加密的数据？

抓包工具之所以能够解密 HTTPS 流量，其实是通过一种与中间人攻击相似的机制。要成功截取并解密 HTTPS 数据，中间人 (或抓包工具) 需要满足两个条件：

1. 作为客户端，与真实的服务器建立连接。这一步通常不会遇到障碍，因为服务器不会去验证客户端的身份。
2. 作为服务器，与真实的客户端建立连接。在这一步，中间人需要获得客户端的信任，这意味着中间人必须拥有对应域名的私钥。

获取这个私钥的方法有几种：

- 直接从网站的服务器获取；
- 从证书颁发机构 (CA) 获取域名的签发私钥；
- 自行签发一个证书，并确保它被客户端浏览器信任。

显然，抓包工具通常采用第三种方法来模拟中间人的身份。

在使用抓包工具进行 HTTPS 流量截取时，用户需要在其设备上安装工具提供的根证书。这个过程实际上是在创建一个由抓包工具扮演的认证中心 (CA)。当客户端使用中间人签发的证书与之通信时，由于该证书被导入为受信任的根证书，浏览器自然会认为该证书是有效的。
