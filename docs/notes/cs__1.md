# 用费曼学习法讲清楚：图灵完备、动态与静态、类型系统

## 一、图灵完备：一门语言“能不能干所有活”的底线

### 1. 用外行人的话说：图灵完备 = 全能厨师

想象你在找一个厨师，你问的问题不是“他炒菜好不好吃”，而是更基础——

> 这位厨师，理论上能不能做出世界上任何一道菜？
> 只要给他足够的食材、时间和锅碗瓢盆。

如果答案是“可以”，那我们叫他“烹饪完备”。

图灵完备就是一样的意思：

> 图灵完备的语言 = 理论上能描述并计算**所有可计算的问题**的语言。

注意两句话：

- 是“理论上”，不考虑时间够不够、内存够不够。
- 是“所有**可计算**的问题”，有些数学问题本来就不可计算（比如停机问题），任何语言都做不了。

### 2. 严肃一点的说法

在计算机理论里，图灵完备有多种等价的表述，其中一种比较经典的是：

> 如果一门语言能模拟一台图灵机（Turing Machine），那么它就是图灵完备的。

图灵机是图灵这位“计算机界老祖宗”为了研究“什么是可计算”而提出的一个数学模型。你可以简单理解为：“最抽象但功能完整的一台理论计算机”。

### 3. 怎么实现图灵完备？两大流派

历史上，计算机语言基本上来自两个数学体系：

- 图灵机（Turing Machine）：偏“命令式”
- λ 演算（Lambda Calculus）：偏“函数式 / 声明式”

对应到编程语言，大致有两条道路通往图灵完备。

#### 路线 A：图灵机流派——goto / if + while

数学家证明过：

> 只要你有：
>
> - `goto` 跳转语句
>   或者
> - `if` 分支 + `while` 循环
>
> 再配合基本的读写和存储数据，你就可以实现图灵完备。

也就是说，绝大多数命令式语言（C、C++、Java、JavaScript、Python 等）其实在底层都是这个套路：

- 用条件语句（`if`）做“不同情况走不同路”
- 用循环（`while` / `for`）做“重复很多次直到满足条件”

就已经足够表达一切可计算的问题了。

#### 路线 B：λ 演算流派——递归

另一派来自丘奇（Church）的 λ 演算（Lambda Calculus）。

你可以把 λ 演算理解成：

> 一种只用“函数”和“替换”来计算一切的数学体系。

这里最关键的能力是：**递归**。

- 函数可以调用自己
- 通过不断“自我调用 + 逐步逼近终止条件”来完成循环

很多函数式语言（比如早期的 Lisp、Haskell 等）就是走的这条路：
它们不一定一开始就强调 `while` 这种循环结构，而是用递归来实现所有重复逻辑。

#### 实际语言：两条路都要

现代语言基本上很现实：

- 既支持 `if` + `while` 那套命令式写法
- 又支持函数递归，甚至函数式特性

所以你会看到：
同一个问题，你既可以用循环解，也可以用递归解，两者在“图灵完备能力”上是等价的，只是写法风格不同。

---

## 二、动态 vs 静态：到底在“谁的电脑上、什么时候”发生？

很多初学者会被这些词搞乱：

- 动态语言
- 静态语言
- 动态类型
- 静态类型

先别急着区分它们，先把**“动态 / 静态”这对词本身的含义**搞明白。

### 1. 用外行人的话说：看清两件事

你只需要问两个问题：

1. 这件事情发生在**谁的电脑上**？
   - 程序员的电脑？还是用户的电脑（或者线上服务器）？
2. 它发生在**什么时候**？
   - 写代码 / 编译的时候？
   - 还是程序真正跑起来的时候？

有一个很好记的对应：

- 静态（static） → 开发阶段、编译时、程序员这边
- 动态（dynamic） → 运行阶段、运行时（runtime）、用户/服务器那边

### 2. 静态：发生在“开发时”的事情

“静态”最典型的例子就是：

- 静态类型检查（static type checking）
  在你写代码、或编译这一步，编译器就帮你检查类型是否合理。

比如 C++、Java 这样的语言：

- 代码没编译过，你的程序就根本跑不起来
- 编译器会在这一步告诉你类型错误：
  比如“把字符串当成数字加一”之类的

这里的关键点是：

> 静态信息 = 只在编译/开发阶段存在，生成的机器码里不一定保留这些信息。

很多传统编译型语言（C/C++）在最终生成的机器码里，几乎不保留类型信息。

### 3. 动态：发生在“运行时”的事情

动态对应的是 runtime，比如：

- JavaScript 引擎在浏览器里执行你的代码
- Python 解释器在服务器上跑你的脚本
- Java 程序在 JVM 里运行

这里发生的事，比如：

- 动态类型检查（运行时才知道“这个变量当前是 string 还是 number”）
- 动态加载模块
- 动态反射、根据字符串名字去调用某个类或方法

你可以简单记：

> 静态 = 写代码 / 编译时，在程序员电脑上发生
> 动态 = 程序跑起来时，在用户/服务器的环境里发生

这套理解会在下一节讲“类型系统”时继续用到。

---

## 三、类型系统：语言给“数据贴标签”的规则

类型系统很大，可以单独开一门课。这里用费曼法，只抓住几个关键问题：

1. 动态类型 vs 静态类型
2. 强类型 vs 弱类型
3. 子类型、函数类型、复合类型
4. 泛型、协变、逆变（只讲直观例子）

### 1. 动态类型 vs 静态类型：类型信息在哪儿存在？

先把刚才讲的“动态 / 静态”的直觉搬过来：
问自己一句话：

> 这个语言的“类型信息”，主要保存在**谁的电脑上**？

#### 动态类型系统

特点：

- 类型信息在**运行时**仍然存在，可以被程序读取和操作
- 甚至可以在运行时根据情况改变变量绑定的值类型

典型例子：

- JavaScript
- Python
- Ruby

在 JavaScript 里你可以做：

```js
let x = 1; // 现在 x 是 number
x = 'hello'; // 现在 x 变成 string
typeof x; // 在运行时得到 'string'
```

类型信息就“活在”用户的机器上，运行时可以随时查看，所以叫动态类型系统。

#### 静态类型系统

特点：

- 类型信息主要用于**编译时检查**
- 编译完成后，生成的机器码里类型信息大多被“擦掉”了

典型例子：

- C / C++
- 传统的编译时 Java（但 Java 有一定程度的运行时类型信息，后面单独说）

C++ 编译成机器码之后，CPU 根本就不知道“这里原来是一个叫 `Person` 的类”，只知道这是几块连续的内存而已。

#### “半动态半静态”：比如 Java

Java 比较特殊：

- 编译时：有静态类型检查，IDE、编译器都非常依赖这些信息
- 运行时：通过“反射”（reflection），你还能获取一部分类型信息

比如：

```java
Class<?> clazz = obj.getClass();
System.out.println(clazz.getName());
```

所以可以粗略地说：

- Java 的类型系统：**以静态为主，附带一定动态能力**

### 2. 强类型 vs 弱类型：语言会不会“偷偷帮你转类型”

这对概念经常和“动态 / 静态”混在一起，但其实它们说的是另一件事：

> 强 / 弱类型只是讨论：
> **类型转换**是严格、显式的，还是宽松、自动的？

#### 强类型语言

特点：

- 不会“默认”帮你做隐式、危险的类型转换
- 类型不匹配一般直接报错

典型例子（直观上）：Java、C#、大多数静态语言，以及很多动态语言（比如 Python）在某些方面也很强。

比如在 Java 里：

```java
int x = "123";   // 直接编译报错，你必须自己显式转换
```

#### 弱类型语言

特点：

- 为了“方便”，会自动帮你做各种隐式类型转换
- 经常导致一些看起来“很诡异”的行为

典型代表：JavaScript。

比如：

```js
1 + '2'; // 结果是 "12"，number 被转换成 string

'0' == 0; // true，因为 "0" 被转换成 number 再比较
'' == 0; // true，因为 "" 也被转换成 0
false == 0; // true，因为 false 也被转换成 0
```

尤其是 `==` 这个“双等号”，因为会触发复杂的隐式转换，被认为是 JavaScript 中设计比较失败的部分。

> 小结一句：
>
> - 强类型：不帮你乱转，错就是错
> - 弱类型：帮你自动转，方便但容易埋坑

注意：
“强类型 / 弱类型”和“静态 / 动态”是两个维度，**不要混为一谈**。
比如：

- Python：动态 + 相对强类型
- JavaScript：动态 + 相对弱类型
- Java：静态 + 相对强类型

### 3. 复合类型、函数类型、子类型

类型系统不仅有“int / string / bool”这种简单类型，还有更复杂的结构。

#### 复合类型（Composite Types）

你可以把多个字段组合在一起，形成一个更复杂的类型：

- C 里的 `struct`
- Java / C# / TypeScript 里的 `class` 或 `interface`
- JavaScript 里对象类型（在 TypeScript 中体现得更明显）

例如：

```ts
type User = {
  name: string;
  age: number;
};
```

这里 `User` 就是一个复合类型，它要求：

- `name` 必须是 `string`
- `age` 必须是 `number`

#### 函数类型（Function Types）

在很多语言里，函数本身也有类型，这个类型通常由“参数类型列表 + 返回值类型”组成。

写成一个抽象形式就是：

```text
(T1, T2, ...) -> T3
```

比如在 TypeScript 里：

```ts
type Fn = (x: number, y: string) => boolean;
```

这个函数类型就表示：接收一个 number 和一个 string，返回一个 boolean。

#### 子类型（Subtyping）

你可以把“类型”看成一个集合：

- 类型 `Animal`：所有动物
- 类型 `Dog`：所有狗，是动物的子集

那么在面向对象语言里，子类通常就是子类型：

- `Dog` 是 `Animal` 的子类型
- 在“需要 Animal 的地方”，你通常可以传一个 `Dog` 进去（这叫**里氏替换原则**）

例子：

```java
Animal a = new Dog();   // 可以
```

这就是“能用父类型的地方，可以用子类型”这个默认行为。

### 4. 泛型 + 协变 + 逆变：只用直观类比理解

泛型是这样一件事情：

> 不仅“值”可以做参数，“类型”也可以当成参数传给代码结构（类 / 函数）。

#### 泛型：类型也能当参数

例子（以数组为例）：

```ts
Array<number>; // 一个“装 number 的数组”
Array<string>; // 一个“装 string 的数组”
```

这里 `Array` 是一个“泛型结构”，可以接受一个类型参数 `T`，变成 `Array<T>`。

- 泛型类：`List<T>`、`Map<K, V>`
- 泛型函数：`function identity<T>(x: T): T { return x }`

#### 协变（Covariance）：子更具体 → 也能用

用直观点的例子解释协变：

假设：

- `Parent` 是父类型
- `Child` 是子类型（`Child` extends `Parent`）

再假设我们有一个“数组”这个泛型结构：

```text
Array<Parent>
Array<Child>
```

如果在这个语言中：

> 凡是能用 `Array<Parent>` 的地方，都能用 `Array<Child>` 替代

那就说明这个泛型在这个类型参数上是“协变”的。

直觉上：
`Child` 有 `Parent` 的所有能力，所以**读**的时候没问题——你本来只打算把它当动物看，现在给你一群狗，你当然也能看懂。

#### 逆变（Contravariance）：参数反过来

再看一个函数的例子。假设有这样的函数类型：

```text
Function<Child>   // 接受 Child 作为参数的函数
Function<Parent>  // 接受 Parent 作为参数的函数
```

如果某个地方“期望得到一个能接受 Child 的函数”，
但你传进去一个“能接受 Parent 的函数”，能不能呢？

- 直觉：
  一个能处理“所有动物”的函数，当然也能处理“狗”啊，狗也是动物。

于是：

> 你可以用 `Function<Parent>` 替代 `Function<Child>`。
> 这个方向是“逆”的，就叫逆变。

一句话总结：

- 协变：**结果类型**方向一致——子可以替父（越具体越没问题）
- 逆变：**参数类型**方向相反——父可以替子（越宽泛越安全）

不同语言对协变、逆变有不同的设计，这里只要先形成直觉就够了。

---

## 四、把这些概念串起来：当你写 JavaScript / TypeScript 时……

回头看一眼实际工作中常见的语言：

- JavaScript：

  - 动态类型系统（类型信息在运行时存在，可以 `typeof`）
  - 弱类型（大量隐式转换：`1 + "2"`、`==` 等）
  - 图灵完备：靠 `if` + `while` + 函数递归等实现

- TypeScript：

  - 静态类型系统（类型只在编译时存在，运行时会被擦除）
  - 类型系统支持：
    - 复合类型（对象类型）
    - 函数类型
    - 子类型（接口扩展、类继承）
    - 泛型（`Array<T>`、`Promise<T>` 等）
    - 协变 / 逆变等复杂规则（很多隐藏在类型推导里）

- Java：
  - 静态类型为主 + 运行时反射（“半动态半静态”）
  - 相对强类型
  - 同样图灵完备（`if` / `while` / 递归都有）

你会发现：

> 图灵完备 → 关心“这门语言能不能理论上解决所有可计算问题”
> 动 / 静态 → 关心“事情在谁的电脑上、什么时候发生”
> 类型系统 → 关心“数据贴什么标签、能把错扼杀在多早”

把这三块分清楚，你看语言特性的时候就不会被各种术语绕晕了。

---
