---
group:
  title: browser
  order: 7
title: DOM 的性能真相
toc: content
order: 1
---

## 一个你以为熟悉、其实陌生的世界

如果你写过一段时间前端，肯定听过两句似乎毫无争议的"常识"：

> **"DOM 操作很慢。"**
>
> **"少操作 DOM，多在 JavaScript 里算完再一次性更新。"**

这些建议被反复转述，几乎变成了前端世界里的"空气"，人人都在呼吸，却很少有人停下来认真追问一句：**慢，究竟慢在什么地方？** 为什么明明写的都是 JavaScript，换个 API 调用，性能就能差一个数量级？

更有趣的是，很多人对浏览器中的两个老熟人——`window` 和 `document`——其实也并不真的理解。有人会问：`window` 是 DOM 吗？为什么 MDN 上把这些统称为 **Web API**（浏览器提供的 Web 编程接口），而不是 DOM API？`document` 是文档根节点那还好理解，可 `window` 到底站在什么位置上？

要真正看清这一切，我们需要暂时离开"语法"的舒适区，转向一个更底层的视角：**浏览器是如何把 JavaScript 引擎、DOM（Document Object Model，文档对象模型）、渲染引擎整合在一起的？** 当我们敲下 `div.innerHTML = 'hi'` 这样一行代码时，背后到底发生了什么？

理解这些，你就不再只是"记住了某些性能建议"，而是能从原理上判断：什么是值得优化的，什么只是传言。

---

## window 不属于 DOM，却统治着 DOM

要理解 `window` 的位置，得先把几个概念分开来。

**ECMAScript** 是 JavaScript 语言本身的标准，它规定了语法、类型系统、内置对象（例如 `Object`、`Array`、`Function` 等），但它并不关心"浏览器"、"页面"、"标签页"这些东西。换句话说，如果只有 ECMAScript 标准，你只能写纯计算逻辑，完全无法访问页面上的按钮、输入框，更别说打开一个新窗口。

真正把 JavaScript 和"浏览器世界"连接起来的，是**宿主环境提供的 API**。在浏览器中，这些 API 被整体称为 **Web API**（浏览器提供的 Web 编程接口），其中包括我们熟悉的 DOM、BOM（Browser Object Model，浏览器对象模型）、定时器、网络请求等。它们不是语言的一部分，而是"运行时给你加的能力"。

在这套能力体系里，`window` 占据着一个非常特别的位置。`window` 代表当前脚本运行的那个"浏览上下文"：可以理解为一个浏览器窗口中的一个标签页。它是一个全局对象，你在浏览器控制台里随便敲一个未声明的变量，很可能最终都会落到 `window` 上去存取。这就是为什么我们常说"`window` 是浏览器里的全局对象"。

但 `window` 并不是 DOM 节点，它不是页面上的某个元素，而是整个"浏览页"这一环境本身。一个现代浏览器里，每个标签页都有自己独立的 `window` 对象，同一个物理窗口里的多个标签页，也不会共享 `window`。有些方法（比如 `window.resizeTo`、`window.resizeBy`）看似是 `window` 的方法，实际上操控的是整个浏览器窗口的外壳，而不是页面中的某个 DOM 元素。这进一步说明了：**`window` 的身份，更像是"宿主容器"，而不是 DOM 树里的成员。**

那 `document` 呢？`document` 属于 DOM，它是当前文档的根节点，是整棵 DOM 树的入口。在 `window` 这栋大楼里，`document` 像是"图纸的第一页"，所有具体的元素、节点、文本句柄，都在这张图纸所描述的那棵树上。

于是，一个更准确的图景浮现出来：

> **浏览器提供了一个名为 `window` 的全局环境对象，内部挂载着各种 Web API，其中有一大块叫做 DOM，而 DOM 的根就是 `document`。**

我们会频繁用到 `window` 和 `document`，但它们并不是同一层次的概念：前者是"外壳"，后者是"文档结构本身"。

当你分清这一点，关于"`window` 到底是不是 DOM"这种困惑，就不再重要了。更重要的是：你知道自己在跟哪个层级打交道。

---

## DOM 对象：既是普通对象，又是特殊对象

厘清了 window 的位置，下一步就该问：那 DOM 自身究竟是什么？

**DOM（Document Object Model，文档对象模型）** 的本质，是浏览器给文档建立的一套对象模型。一份 HTML 文档被解析后，不再只是字符串，而是一棵由节点（Node）组成的树；每一个标签、文本、注释，都被映射为一个 DOM 对象。

这些 DOM 对象，在 JavaScript 世界里，**就是对象**。

为了理解这一点，我们来看一个具体的例子：一个 `<input>` 元素。在 JavaScript 中，它会对应到一个 `HTMLInputElement` 对象。这个对象并不是凭空长出来的，而是沿着一条继承链一路叠加能力：

```js
// 查看 DOM 对象的原型链
const input = document.createElement('input');
console.log(input.constructor.name); // HTMLInputElement
console.log(input instanceof HTMLElement); // true
console.log(input instanceof Element); // true
console.log(input instanceof Node); // true
console.log(input instanceof EventTarget); // true
console.log(input instanceof Object); // true
```

这条继承链说明了一个朴素而重要的事实：

> **DOM 对象没有什么神秘之处，本质上就是 Object 的子类。**

当你通过 `document.querySelector('input')` 拿到一个元素时，你得到的是一个特殊的 JavaScript 对象。它之所以"特殊"，不是因为它超脱于 JavaScript 语言，而是在于：**它内部的属性和方法会被浏览器引擎映射到底层的 DOM 引擎和真实的文档结构上。**

这就引出了另一个常被忽略的细节：

当你给 DOM 对象随手挂一个非 API 属性，比如：

```js
const input = document.querySelector('input');
input._cache = { touched: true };
```

访问这个 `_cache` 属性的速度，会像操作普通对象那样快，还是像走 DOM API 那样慢？

理论上，浏览器通常会在 JavaScript 引擎这边为 DOM 节点创建一个"包装对象"，非标准属性就挂在这个包装对象上，不需要进入 DOM 引擎，因此在性能上更接近普通对象的访问。但不同引擎可能有不同实现，历史上甚至有 IE 那样的坑——DOM 对象和 JS 对象之间的引用没处理好，导致严重的内存泄漏。

所以，经验上更稳妥的做法是：

> **不要把 DOM 元素当作一个随便往上塞数据的大号 Map 用。**

缓存数据可以放在单独的 JavaScript 数据结构里，比如用 `Map` 以元素为键存储，或者直接在状态管理层维护，DOM 只承担界面投影的角色。

这里有一个有趣的对比，有助于你理解"普通对象"的边界：

```js
// 典型的 JavaScript 对象，继承自 Object
let obj = {};
console.log(obj.toString); // ƒ toString() { [native code] }

// 真正"干净"的对象：没有原型链上的默认方法
let pure = Object.create(null);
console.log(pure.toString); // undefined

// DOM 对象：既是对象，又连接着浏览器引擎
let div = document.createElement('div');
console.log(div.toString); // ƒ toString() { [native code] }
console.log(div.nodeType); // 1 - 这是 DOM 特有的属性
```

把这两个和 DOM 对象放在一起看，你就会发现：DOM 对象在类型系统上确实是"对象"，但它背后连着的是浏览器的 DOM 引擎和真实页面结构，而不只是单纯的一块内存。这也为后面要讲的性能问题埋下了伏笔。

---

## 一次跨世界的调用：DOM 为什么"天生就慢"

回到那个老问题：为什么大家都说"操作 DOM 很耗性能"？

要回答这个问题，需要把视野从对象本身拉回到运行时。现代浏览器里，至少有两块重量级的组件共享着同一条主线程：**JavaScript 引擎**和 **DOM/渲染引擎**。前者负责执行你写的代码，后者负责维护文档结构、计算布局、绘制像素。

当你在 JavaScript 里调用一个 DOM API，例如读取某个元素的尺寸，或者修改它的样式，其实是在做一件"跨世界"的事情。大致的过程可以想象成这样：

```js
// 表面上看只是一行简单的 JavaScript
const width = element.offsetWidth;

// 背后发生的事情：
// 1. JavaScript 引擎暂停当前执行
// 2. 将调用转换为 DOM 引擎能理解的指令
// 3. DOM/渲染引擎处理请求（可能需要重新计算布局）
// 4. 将结果转换回 JavaScript 表示形式
// 5. JavaScript 引擎恢复执行
```

这一整套过程，就像一次本地的"远程过程调用"（RPC）。你虽然只写了一行 JavaScript，但背后是两个子系统之间的配合：序列化、上下文切换、调度、反序列化。单次调用看起来微不足道，一旦频繁发生，就会迅速积累成显著的性能成本。

更麻烦的是，很多 DOM API 的"读"操作，并不是随时都握有最新值。要返回一个精确的尺寸、位置或布局信息，浏览器往往需要先把"可能过期"的布局重算一遍，这就是我们常说的 **reflow（回流，重新计算布局）**。如果这个重新计算涉及到样式、结构变化，还可能触发 **repaint（重绘）**，把更新后的界面重新画到屏幕上。

```js
// 糟糕的写法：强制同步布局（强制重排）
function resizeParagraphs() {
  for (let i = 0; i < paragraphs.length; i++) {
    // 每次循环都读取 offsetHeight，触发重排
    paragraphs[i].style.height = paragraphs[i].offsetHeight + 10 + 'px';
  }
}

// 改进的写法：先读取，再批量修改
function resizeParagraphsBetter() {
  // 一次性读取所有需要的信息
  const heights = paragraphs.map((p) => p.offsetHeight);

  // 批量应用修改
  paragraphs.forEach((p, i) => {
    p.style.height = heights[i] + 10 + 'px';
  });
}
```

于是，一个看似无害的属性读取，很可能隐含着一波连锁反应：重新计算布局、调整节点位置、重画部分页面，全部发生在你以为是"简单 GET 操作"的那一行代码之后。如果你在一个循环里反复读取这些会触发布局刷新的属性，或在短时间内交替读写导致浏览器无法批量优化，就等于在主线程上一次次拉响"紧急重排"的警报。

所有这些消耗，最后汇集到一个结果上：DOM 引擎在主线程上占用时间过长，JavaScript 事件处理被推迟，用户的点击、滚动感觉不到响应，界面开始"卡"。

所以，性能问题的根源不在于你到底有没有用 jQuery，也不在于你是否启用了某个虚拟 DOM 框架，而在于这一条底层事实：

> **对 DOM 的每一次访问，都是一次跨子系统、潜在伴随布局重算的昂贵调用。你在 JavaScript 与 DOM 之间"往返的次数"，远比你选择哪个库更重要。**

---

## "界面差分"思维：把 DOM 当作远程服务

既然昂贵的是"调用次数"，自然的策略就是：减少不必要的 DOM 调用，把逻辑尽可能留在 JavaScript 这边算完，只把必要的"最终更新"一次性推给 DOM。

这正是现代前端框架背后共同遵循的一条底层思路：在 JavaScript 中缓存必要的数据，计算界面更新时的状态变化，只提交最终需要应用到页面上的差集。

在虚拟 DOM（Virtual DOM）方案中，框架会用 JavaScript 对象结构去描述界面状态。你每次"重渲染"组件，实际上是生成一棵新的虚拟 DOM 树，然后拿它与上一棵虚拟 DOM 树进行 diff，算出这次更新真正需要落到真实 DOM 上的那一小撮变更。最终，框架只把这小部分变更翻译成真实的 DOM 操作，发送给浏览器执行。前面那段"跨世界调用"的代价，尽量被压缩到最少的几次。

有的框架则选择从数据层面做差分，而不是从 DOM 结构做差分。它们把界面看作状态的投影，先在 JavaScript 里比较新旧状态的差异，然后根据差异推导出具体需要更新哪些 DOM 节点、哪些属性。逻辑不同，但精神相同：不把 DOM 当作计算场，而是当作"结果的接收者"。

如果你愿意采用一个更形象的比喻，可以把真实 DOM 想象成一个远程服务，而 JavaScript 是本地程序。对这个远程服务的每一次调用，既有网络般的开销（上下文切换），又可能触发服务器端的重计算（布局与重绘）。在这种情况下，比较聪明的做法从来不是"在远程服务上写业务逻辑"，而是"在本地把所有东西算好，最后只发一封包含必要更新的指令过去"。

这就是**"界面差分"思维**的核心：

> **把页面理解成状态函数的输出，把 DOM 操作视为最终、必要、且应尽量稀少的副作用。**

---

## 驯服边界：写前端的真正功夫

当你从这个角度回望一开始的那些问题——`window` 究竟是不是 DOM、DOM 对象算不算 JavaScript 对象、为什么操作 DOM 会慢——你会发现，它们其实都指向同一个主题：**边界**。

`window` 是浏览器世界的边界，它把一整个运行时的能力暴露给你，但它本身又站在 DOM 之上，统摄着标签页这一更高层级的概念；`document` 是文档世界的边界，从它出发你才能触及那棵代表页面结构的树；DOM 对象既是 JavaScript 对象，又承载着浏览器内部引擎的状态，是语言和宿主之间的一道接口边界；而性能问题，则是在 JavaScript 引擎与 DOM/渲染引擎这条边界线上不断往返时产生的摩擦和损耗。

写前端，表面上是在写组件、写样式、写交互；本质上则是在与这些边界打交道：什么时候把逻辑留在 JavaScript 里算完，什么时候把结果交给 DOM；哪些状态应该只存在于内存，哪些才值得同步到界面；何处适合精细操作节点，何处又应该退一步，用"整体重算 + 差分更新"的方式来换取简洁和性能。

也许真正值得问自己的问题，不再是"DOM 操作到底慢不慢"，而是：

> **"我是不是在滥用一条本来就昂贵的边界？"**
>
> **"我能不能把更多的复杂度收拢在 JavaScript 自己的世界里，只把最小的一部分交给浏览器去绘制？"**

当你开始用这种方式审视自己的代码时，你就不再只是一个 API 使用者，而是在主动设计 JavaScript 世界与浏览器世界之间的契约。界限清晰，调用克制，副作用可控——这或许才是前端工程师真正的专业感所在。

至于那一句被说烂了的忠告——"少操作 DOM"——在你理解了它背后的边界故事之后，就不再只是一个模糊的经验法则，而成为一种可以在每个具体场景中被推理、被验证、被精确应用的思维工具。
