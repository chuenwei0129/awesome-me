---
group:
  title: html
  order: 0
title: 理解补码的一切
toc: content
---

# 当计算机学会绕圈走路：补码的真正理由

---

## 问题从哪里来？

如果你第一次接触二进制负数，大概会有三连问：

- 负数怎么用 0/1 表示？
- 为什么 8 bit 的有符号整数范围是 `-128 ~ 127`？
- 教材说"补码是为了方便运算"，但"方便"在哪里？

再往后写 JavaScript 时，会发现：

- JS 的 `Number` 是浮点数，却又说"位运算按补码 32 位整数算"
- 还有什么 `Int8Array`、`BigInt &`、`>>>` 之类的奇怪东西

这一切的核心，其实就是一件事：
**计算机想用"同一套硬件"完成"加法 + 符号 + 截断"。**

要做到这件事，它学会了一种思路：**在一个"绕圈"的世界里走路**。补码就是把"绕圈走路"用二进制写出来而已。

---

## 从数轴到"绕圈走路"

先从直觉出发，不急着看公式。

### 1. 数学上的直觉：无穷数轴

在数学课上，我们习惯这样想数：

- 有一条无限长的数轴
- 左边负无穷，右边正无穷
- 加法就是在这条轴上前后移动

但计算机会立刻举手：**"抱歉，我只能存有限多个状态。"**

### 2. 现实中的限制：只有有限个刻度

举个极端例子：
假设硬件只能保存"3 bit 二进制"，那么它的所有可能状态是：

- `000`、`001`、`010`、`011`、`100`、`101`、`110`、`111`
- 一共 `2^3 = 8` 个状态

问题来了：**这 8 个状态要怎么对应整数？**

- 如果都用来表示非负数：`0 ~ 7`
- 如果想放进负数：总共也就只能容纳 8 个不同的整数

不管怎么设计，世界都变成了"**只有 8 个刻度的世界**"。

### 3. 把数轴绕成一个圈：模运算

既然只有 8 个刻度，不妨把它想象成一个"8 格的圆环"：

- 0 → 1 → 2 → 3 → 4 → 5 → 6 → 7 → 然后再回 0
- 类似时钟：12 点再加 1 小时变 1 点

这个世界里，加法的本质是：

> 一直加，但每超出 8，就把"圈数"扔掉，只看停在哪个刻度。
> 这就是"模 8"（`mod 8`）。

比如：

- `5 + 5 = 10`，在模 8 的世界里：
  - 10 ÷ 8 余 2 → 对应"刻度 2"
- 所以 `5 + 5 ≡ 2 (mod 8)`

:::info{title="核心概念"}
这个"绕圈走路"的概念就是**模运算**，也是所有补码的真正底层直觉。
:::

---

## 无符号整数：先把圈上的刻度标上号

当我们只想表示非负整数时，最自然的做法：

- 3 bit，无符号表示：
  - `000` → 0
  - `001` → 1
  - ...
  - `111` → 7

这就是我们熟悉的 **无符号整数（unsigned）**：

- 3 bit 范围：`0 ~ 7`
- 8 bit 范围：`0 ~ 255`
- 一般 n bit 范围：`0 ~ 2^n - 1`

在这一步里，没有负数，也没有补码，只有"**从 0 开始往上数**"。

---

## 负数怎么来？从"绕圈走反方向"到补码

问题来了：**负数怎么表示？**

如果还是在这条"8 格圆环"上，我们可以这样想：

> **正方向走是加，反方向走就是减。**
> 所以"`-1`"就是"往回走一格"，"`-2`"就是往回走两格。

在"模 8"的世界中：

- `-1` 等价于 "从 0 开始往正方向多走 7 格"：
  - `-1 ≡ 7 (mod 8)`
- `-2 ≡ 6 (mod 8)`
- 一般地，对 n bit：
  - `-x ≡ 2^n - x (mod 2^n)`

于是，我们悄悄做了一个决定：

> **用刻度 `2^n - x` 来表示整数 `-x`。**

:::success{title="补码的核心定义"}
这就是补码的核心定义：

- 在 8 bit 下，`-1` 的补码是：`2^8 - 1 = 255` → `1111 1111`
- `-2` 的补码：`2^8 - 2 = 254` → `1111 1110`
- `-128` 的补码：`2^8 - 128 = 128` → `1000 0000`
  :::

再看一眼最重要的那个例子：`-1`：

- `+1`：`0000 0001`
- `-1` = `2^8 - 1 = 255`：`1111 1111`

于是有了我们熟悉也常被机械记忆的一句话：

> 负数的补码 = "全 1 减原码"再加 1
> 数学上其实就是："`2^n - x`"。

---

## 为什么 8 bit 范围是 -128 ~ 127？

现在我们来算一算，8 bit 有符号整数的范围到底是多少。

### 1. 先数一数：一共 256 个刻度

- 8 bit → `2^8 = 256` 种比特模式
- 不管怎么设计，都只能映射到 256 个不同的整数

补码的目标是：在这 256 个整数里，挑一个**连续的区间**来用。

### 2. 0 只能有一个表示

我们希望：

- `0` 只有一个编码
- 不能像"原码/反码"那样出现 `+0`、`-0` 两套表示

于是自然的分配方式是：

- 把 `0` 放在某个位置
- 向右是正数
- 向左是负数
- 左右合起来刚好用满 256 个点

### 3. 算一下正负各能有多少个

设范围是从 `-A` 到 `+B`，要求：

- 整个区间长度为：`A + B + 1`（中间还有个 0）
- 而所有编码一共只有 256 个：
  - `A + B + 1 = 256`

我们还希望"对称"一点，让正数多接近负数，于是很自然地选：

- `A = 128`
- `B = 127`
- 于是范围：`[-128, 127]`

你会发现：

- 负数多一个：`-128` 没有对应的 `+128`
- 因为 0 要占一个名额，**"多出来"的负数刚好吃掉了 `+128` 的位置。**

### 4. 从位权角度再看一眼

在 8 bit 补码里，可以直接给每一位一个权重：

- `b7 b6 b5 b4 b3 b2 b1 b0` 表示的值是：
  `value = -b7 * 128 + b6*64 + ... + b1*2 + b0*1`

于是：

- `0111 1111`：最高位是 0 → 没有 `-128`
  - `64 + 32 + 16 + 8 + 4 + 2 + 1 = 127`
- `1000 0000`：只有最高位是 1 →
  - `-128`

最低就是 `-128`，最高就是 `127`，完美契合。

---

## 为什么一定要用补码？它到底"方便"在哪？

我们看看如果不用补码，会发生什么。

### 1. 原码：加法要特殊照顾负数

原码的想法是最直觉的：
"符号位" + "绝对值"。

- `+5` → `0 0101`
- `-5` → `1 0101`（符号位为 1 表示负数）

:::error{title="原码的问题"}
**加法不能直接拿硬件做**。

- `+5 + (-5)`：
  - 符号位相异，需要比较绝对值，执行减法
  - 然后再给结果符号
- 这需要额外的控制逻辑，硬件更复杂
  :::

### 2. 反码：多一个 `-0`，加法仍需特殊处理

反码试图优化一点：

- 正数不变
- 负数 = 除符号位不变，其余位按位取反

问题：

- 还是有 `+0` 和 `-0` 两套表示
- 加法仍然有边界情况要特殊处理

### 3. 补码：让"负数"="绕圈走反方向"

补码的高明之处在于：

- 所有整数（包括负数）都被嵌入在模 `2^n` 的一个连续区间
- 加法在硬件里只需要做"模 `2^n` 加法"
- 不需要为负数写单独的加法单元

比如在 8 bit 下：

- `5 + (-3)`：

  把 `-3` 换成补码：

  - `3` → `0000 0011`
  - `-3` → `1111 1101`（= `256 - 3 = 253`）

  然后直接做无符号加法：

  - `0000 0101`（5）
  - `+ 1111 1101`（-3 的补码）
    = `0000 0010`（2）

:::success{title="补码的精妙之处"}
没有任何"看符号"的特殊分支，硬件就是一个统一的"加法器"。
:::

**总结一下补码的好处：**

- 零只有一种表示
- 加法/减法统一为一套"模 `2^n` 加法"
- 溢出自然变成"绕圈走一圈"：非常适合硬件实现
- 比较大小也简单明了（最高位就是符号）

所以："**补码是为了方便硬件做加减运算**"这句教材话，其实背后的数学是：

> 把有符号整数嵌入到模 `2^n` 的一个连续区间里，让所有运算都变成"在圆环上走路"。

---

## 在 JavaScript 里，补码长什么样？

JS 里有两个比较容易误解的点：

- 默认的 `Number` 是浮点数，不是整数
- 但位运算符、某些 API，又都在跟"32 位补码整数"打交道

### 1. 普通算术：`Number` 是 64 位浮点，不谈补码

在 JS 里：

- `1 + (-2)`、`0.1 + 0.2` 等普通算术
- 都是按 IEEE 754 的 64 位浮点数来做运算
- 概念上可以理解为数学上的实数运算，不需要考虑补码

这也是为什么会有 `0.1 + 0.2 !== 0.3` 的经典浮点精度问题。

### 2. 位运算：强制把 `Number` 映射成 32 位整数

以下运算符是"位运算专用区"：

- `&`、`|`、`^`、`~`
- `<<`、`>>`、`>>>`

规范里的定义（简化版）：

- 对 `& | ^ ~ << >>`：
  - 先对操作数执行 `ToInt32` → 得到有符号 32 位整数
  - 等价于对 `2^32` 取模，再按补码解释
- 对 `>>>`：
  - 使用 `ToUint32` → 无符号 32 位整数

:::info{title="JavaScript 位运算本质"}
**JS 的位运算本质上就是在"32 位补码整数"的圆环上操作。**
:::

例子：

```js
-1 &
  0xff(
    // 255

    -1,
  )
    .toString(2)(
      // "-1"
      -1 >>> 0,
    )
    .toString(2); // "11111111111111111111111111111111"
```

解释：

- `-1` 的 `ToInt32` → 补码 `0xFFFFFFFF`
- `-1 >>> 0` 把它当 32 位无符号数看 → `4294967295`
  - 二进制就是 32 个 1

移位也完全是补码语义：

- `>>`：算术右移 → 保留符号位（左侧补符号位）
- `>>>`：逻辑右移 → 左侧补 0，总是当无符号看

### 3. TypedArray：显式有符号补码整数

在 TypedArray 里，有几种明确以补码解释内存的类型：

- `Int8Array`、`Int16Array`、`Int32Array`

它们的行为跟我们前面讲的"补码世界"完全一致：

```js
const buf = new ArrayBuffer(1);
const i8 = new Int8Array(buf);
const u8 = new Uint8Array(buf);

u8[0] = 0xff;
i8[0]; // -1
u8[0]; // 255
```

同一字节 `0xff`：

- 作为 `Int8` 看 → `-1`（补码）
- 作为 `Uint8` 看 → `255`（无符号）

### 4. BigInt 的位运算：无限位补码模型

`BigInt` 是 JS 里的"任意精度整数"。

规范定义它的位运算（`& | ^ ~ << >>`）时，用的是一个数学模型：

> 假设存在一个"无限长的补码比特串"，
> `BigInt` 的值就是那串比特上的某个状态。

所以你会看到熟悉的补码味道：

```js
-1n & 0xffn; // 255n
```

尽管在实现里并不存在"真·无限位"，但语义上是按"无限位补码"定义的。

### 5. 位运算在 JS 里要不要"避免"？

:::warning{title="关于性能的明智建议"}
**不是"应该避免位运算"，而是"要避免误用位运算"**。
:::

更准确的态度是：

- 确实在比特层面处理数据时（掩码、标志位、协议解析、TypedArray）完全应该用位运算。
- 但不要为了所谓"性能优化"，刻意把原本清晰的算术、逻辑改写成各种 `|0`、`>> 0` 的技巧。

关于性能：

- 现代 JS 引擎对普通算术和位运算都有很强的 JIT 优化
- 位运算并不天然比 `+ - * /` 更快
- 更重要的是：位运算会**截断到 32 位并引入补码语义**，对大数或精度敏感代码可能直接算错
- 是否有性能收益，必须用实际 profiler 测出来，而不是靠经验法则

至于 V8 里的 SMI（Small Integer）之类的实现细节，只适合作为背景知识：

- 不同引擎实现不同
- 同一引擎不同版本也可能改
- 不应该在业务代码里写死"为了 SMI 优化，所以 xxx"这类逻辑

---

## 把一切串起来：补码的"真正理由"

回到标题：**"当计算机学会绕圈走路：补码的真正理由"**。

我们现在可以把核心逻辑浓缩成几条：

- 计算机世界只有有限个状态 → 把数轴绕成一个"模 `2^n`"的圆环
- 无符号整数，就是从 0 开始在这个圆环上往前标号
- 补码的关键选择是：

  > 在这 `2^n` 个刻度里，
  > 选一个连续区间 `[-2^{n-1}, 2^{n-1}-1]`
  > 把负数 `-x` 映射到刻度 `2^n - x`

- 这样一来：

  - 0 只有一种表示
  - 正负整数都嵌入在模 `2^n` 的世界里
  - 加/减/溢出都变成"在圆环上走路"
  - 硬件实现可以只写一套"模 `2^n` 加法器"

- 在 JavaScript 中：

  - 普通 `Number` 是 64 位浮点，不用考虑补码
  - 但位运算、`Int*Array`、`BigInt` 的位运算，全都在不同"位宽的补码世界"里绕圈：
    - `Number` 位运算：32 位补码模 `2^32`
    - `Int8/16/32Array`：对应 8/16/32 位补码
    - `BigInt` 位运算：无限位补码模型

:::success{title="最终结论"}
所以，比起死记硬背"符号位取反加一"，补码更本质的理解是：

**这是在一个模 `2^n` 的圆环上，
用一种统一、自然的方式，把正数和负数放到一起，
让硬件可以用同一套加法规则处理所有整数。**

:::

如果你先把"绕圈走路"这件事想清楚，再看补码、JS 位运算、整数溢出，都会变得自然很多。
