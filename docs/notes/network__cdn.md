## 一、先用“买西瓜”讲明白 RTT 和延迟

想象一下，你住在郊区，最近的水果店在城中心：

- 骑小电驴去买西瓜要 1 小时；
- 买完再回来又要 1 小时。

这两小时，就是网络里常说的「往返时间」：

> **RTT（Round-Trip Time）= 请求从你到服务器，再从服务器回到你所花的总时间**

现实互联网里，服务器可能在“十万八千里”之外：
中间要经过很多运营商、很多路由节点，任何一处拥塞、丢包，都会让你感受到：

- 网页转圈很久才出来；
- 视频要转一会儿才开始播放；
- 接口响应“卡”在那儿。

**用户体验标准很现实：**

- 2 秒内打开：还行；
- 3–5 秒：开始不耐烦；
- 超过 5 秒：很多人直接关掉页面。

而且要注意：**加载一个页面不是只消耗一个 RTT**。

- DNS 查询：可能 1 个 RTT；
- TCP + TLS 握手：可能 1–3 个 RTT；
- 请求 HTML、JS、CSS、图片：每一类都消耗 RTT（HTTP/2/3 可以复用连接，但 RTT 仍然存在）。

整体体验是多个 RTT 的叠加 + 浏览器解析/渲染时间。

那怎么解决“买西瓜太远”的问题？
线下的做法很简单：**多开分店，开到靠近用户的地方**。

CDN 做的，就是把这套逻辑搬到互联网世界。

---

## 二、CDN 到底是什么？

CDN 全称是 **Content Delivery Network**，中文叫「内容分发网络」。

一句话总结：

> **CDN 就是一张在全球铺开的“加速分店网”，把网站内容尽量放到离用户最近的机器上，让访问更快、更稳定、更安全。**

几个核心概念：

- **源站（Origin）**
  你的真实服务器，比如 Node.js / Java / PHP 应用服务器，或者对象存储（OSS、S3）。

- **边缘节点 / PoP（Point of Presence）**
  CDN 在各个城市、各个国家部署的机房，离用户物理距离和网络距离都更近。

- **RTT 降低**
  用户访问的是就近的 CDN 边缘节点，而不是远在异国他乡的源站，从而大幅减少每次请求的往返时间。

---

## 三、CDN 是怎么工作的？

用浏览器输入 URL 的过程来串一下完整链路：

1. **用户输入域名**
   例如：`https://www.example.com`

2. **DNS 解析**

   - 你把静态资源子域名（比如 `static.example.com`）的 DNS 记录 **CNAME 到某家 CDN 提供的域名**；
   - 用户侧的 DNS 解析流程（本地缓存 → 运营商 DNS → 权威 DNS）最后得到一个 **CDN 的 IP 地址**。

   > 不同 CDN 的实现不太一样：
   >
   > - 有的使用 **Anycast 任播**：同一个 IP 在多个节点同时广播，由 BGP 协议把流量就近路由；
   > - 有的使用 **DNS 负载均衡**：不同地区解析到不同 IP，再由运营商路由。

3. **请求到达 CDN 边缘节点**

   - 根据路由协议和 CDN 的调度策略，请求会被送到“就近且健康”的边缘节点上。

4. **CDN 判断是否命中缓存**

   - **命中缓存（HIT）**：边缘节点本地已有一份缓存副本，直接从本地磁盘或内存把资源返回（非常快）。
   - **未命中缓存（MISS）**：边缘节点向你的源站发起请求，拿到响应后：
     - 按源站返回的 HTTP 头决定是否缓存、缓存多久；
     - 再把响应返回给用户。

5. **后续用户访问**
   - 同一个资源在缓存有效期内，再来请求就直接命中 CDN，**不会再打到源站**。

从工程角度概括：

> **CDN = 智能缓存 + 近距离节点 + 优化过的网络传输 + 一定的安全与运维能力**

---

## 四、静态内容：前端的主战场

### 1. 什么算“静态内容”？

在工程实践里，“静态内容”通常指：

- 对所有用户几乎相同；
- 不需要每次请求都重新生成；
- 可以较长时间保持不变。

典型例子：

- 打包后的 JS / CSS 文件；
- 图片、视频封面、字体文件；
- 静态 HTML 页面（博客、文档、营销页等）。

### 2. 强缓存策略：文件名 hash + 长缓存

工程上最常用的套路：

1. **构建工具生成带内容哈希的文件名**

   - Webpack：`app.[contenthash].js`
   - Vite/Rollup：`assets/index.[hash].js`
   - 这样一旦内容变化，文件名就变，旧版本缓存不会影响新版本。

2. **为这些文件设置长期强缓存头**
   源站或 CDN 响应头示例：

```http
Cache-Control: public, max-age=31536000, immutable
```

含义：

- `public`：CDN 和浏览器都可以缓存；
- `max-age=31536000`：缓存 1 年（单位秒）；
- `immutable`：告诉浏览器“这个资源内容不会变”，避免重复校验。

> 注意：**不要对入口 HTML 也用这种头**，否则用户可能一年看不到新版本 HTML。

### 3. 入口 HTML 的缓存策略

入口 HTML 一般需要 **可控更新**，典型做法：

```http
Cache-Control: no-cache
ETag: "some-version-id"
```

或：

```http
Cache-Control: public, max-age=60
ETag: "some-version-id"
```

含义：

- `no-cache`：每次用缓存前要向服务器验证（配合 `ETag`）；
- 或者短 `max-age`：例如 60 秒，用户最多看到 1 分钟前的 HTML。

综合来说：

- **静态资源（JS/CSS/图片）**：文件名带 hash + 长缓存；
- **入口 HTML**：短缓存或只做协商缓存，方便频繁发版。

---

## 五、动态内容：不是“不能缓存”，而是“不能乱缓存”

### 1. 动态内容的特点

动态内容通常与：

- 当前用户身份（例如 token / cookie）；
- 请求参数（如页码、筛选条件）；
- 业务状态（时间、库存、推荐算法）；

强相关，典型例子：

- 用户个人中心数据；
- 订单列表、购物车、消息通知；
- 搜索结果、推荐列表；
- 实时计数（播放量、点赞数）。

这些内容**不能简单用“长期、无区分、所有人共享的一份缓存”来处理**。

### 2. CDN 对动态内容能做什么？

1. **网络路径优化**
   即使数据不能共享缓存，CDN 仍然可以通过：

   - 跨运营商的优质专线；
   - 与用户之间的长连接复用；
   - HTTP/2 / HTTP/3（多路复用、头压缩）；

   来降低延迟、提高吞吐。

   > 兼容性层面：支持 HTTP/3 的浏览器会优先用 HTTP/3，不支持的会自动回退到 HTTP/2/1.1，前端无需手动区分。

2. **边缘计算 / 边缘函数（Edge Functions / Workers）**
   现代 CDN（如 Cloudflare Workers、Vercel Edge Functions 等）允许你在边缘节点跑 JS/TS 代码，比如：

   - 简单鉴权与重定向（如未登录重定向到登录页）；
   - A/B 测试分流；
   - HTML 片段组合（公共头尾缓存在边缘，中间内容动态组装）；
   - 对某些公共数据做短期缓存（例如首页热门视频列表缓存 30 秒）。

3. **精细化缓存（Cache Key 设计）**
   对部分“公共但经常更新”的数据，可以用更细的策略：

   - 用 `Cache-Control: public, s-maxage=60, stale-while-revalidate=300` 让 CDN 缓 60 秒，并允许“过期但可用”300 秒；
   - 用 `Vary` 告诉 CDN：缓存要按某些 header 分版本，比如：
     - `Vary: Accept-Language` 按语言区分缓存；
     - `Vary: Accept-Encoding` 按压缩格式区分缓存；
   - 对只属于单个用户的响应，设置：
     - `Cache-Control: private, no-store`，只在用户本地（或完全不缓存）。

简而言之：

> **动态内容不是完全不能用 CDN 缓存，而是要按用户、参数、时间等维度设计好缓存键和过期策略。**

---

## 六、CDN 的安全与网络能力：不止是“加速器”

很多人只把 CDN 当“加速器”，但它其实也是一层重要的**安全防护墙**。

1. **隐藏源站 IP、缓解大规模 DDoS**

   - 用户请求只打到 CDN 边缘节点，不直接暴露源站 IP；
   - CDN 在全球有大量节点，可以通过 Anycast 和流量调度，把攻击流量分散；
   - 对于大带宽攻击，比你自己几台源站扛要现实得多。

   > 但需要强调：CDN 是“第一道防线”，不是万能盾牌，应用层仍然要做好安全设计。

2. **负载均衡与健康检查**

   - CDN 可以配置多个源站（主、备、按区域等），并监控健康状态；
   - 某个源站异常时，自动切换到健康源站；
   - 对前端来说，就是“地址没变，但后端切换了机房”。

3. **TLS/SSL 与 HTTPS 支持**

   - CDN 通常在边缘节点终止 TLS（HTTPS 终止），统一管理证书；
   - 优点：
     - 源站可以用明文 HTTP 或内网 HTTPS 减轻证书运维负担；
     - 边缘节点可以统一启用最新协议（TLS 1.3、HTTP/2/3），提升安全和性能。

4. **WAF（Web 应用防火墙）与风控能力**

   - 过滤一些常见攻击模式（简单 SQL 注入、XSS Payload 等）；
   - 按 IP / UA / 请求频率做限流（Rate Limiting），拦截暴力破解和恶意爬虫。

---

## 七、CDN 的性能优化手段

除了“更近”“有缓存”，CDN 通常还会做：

- **压缩与最小化（在边缘自动完成）**

  - 对文本资源（JS、CSS、HTML、JSON）启用 Gzip/Brotli 压缩；
  - 即使构建阶段没有压缩，CDN 也可以在返回时压缩。

- **图片和视频优化**

  - 动态转码为 WebP/AVIF（新格式节省流量）；
  - 按 DPR、视口大小自动裁剪、降分辨率；
  - 自动选择兼容格式：不支持 WebP 的浏览器自动使用 JPEG/PNG。

- **连接优化**

  - 复用到用户的长连接，减少 TLS 握手；
  - TCP 参数和拥塞控制的优化，提升长距离传输性能。

- **智能路由**
  - 避开某些拥塞 / 故障的运营商线路，选择当前更好的网络路径；
  - 对跨运营商、跨地域访问收益明显。

---

## 八、CDN 能帮我们省钱吗？

短答案：**在访问量足够大的场景下，通常可以省钱，但要算总账。**

- **没有 CDN 时：**

  - 所有静态/动态请求都打到源站；
  - 源站需要承担巨大的出口带宽，带宽费用和服务器扩容成本都很高。

- **接入 CDN 之后：**
  - 静态资源在边缘大量命中缓存，源站带宽大幅下降；
  - 同时会多一笔“CDN 流量费 / 请求费”。

实际运营中常见情况：

> 当访问量达到一定规模，“源站带宽费 + 服务器成本的节省” 通常大于 “CDN 费用”。

但也要注意：

- 小型网站、低访问量项目，不用 CDN 也完全能正常跑；
- 选择 CDN 厂商时要综合考虑：覆盖区域、计费模型、功能是否够用（HTTP/3、WAF、边缘函数等）。

---

## 九、前端项目如何实战接入 CDN？

这里给一个比较通用、可落地的流程。

### 1. 拆分域名：业务域名 vs 静态资源域名

典型拆分：

- API：`https://api.example.com`
- 页面：`https://www.example.com`
- 静态资源：`https://static.example.com` → **CNAME 到 CDN**

好处：

- 静态域名可以不开 Cookie，减少请求体积；
- 可以在 CDN 上单独配置缓存策略和图片压缩等功能。

### 2. 构建工具配置静态资源前缀

以 Webpack 为例（CommonJS 写法）：

```js
// webpack.config.js
module.exports = {
  output: {
    publicPath: 'https://static.example.com/',
  },
};
```

Vite 示例（ESM）：

```js
// vite.config.mts 或 vite.config.ts
import { defineConfig } from 'vite';

export default defineConfig({
  base: 'https://static.example.com/',
});
```

Next.js 示例：

```js
// next.config.js
module.exports = {
  assetPrefix: 'https://static.example.com/',
};
```

其他框架（Nuxt、Angular 等）也都有对应的“静态资源前缀”配置，核心思路一致。

### 3. 开启文件名 hash 和强缓存

- 在构建输出中启用内容 hash（通常构建工具默认就支持）；
- 在 CDN 或源站上，对 JS/CSS/图片等配置长期缓存头，例如：

```http
Cache-Control: public, max-age=31536000, immutable
```

- 对入口 HTML 配置短缓存或协商缓存（上一节已说明）。

### 4. 接口与 HTML 的缓存策略示例

可以简单记一个“策略表”：

- 入口 HTML：

  - `Cache-Control: no-cache` + `ETag`
  - 或 `Cache-Control: public, max-age=60`

- 带 hash 的 JS/CSS/图片/字体：

  - `Cache-Control: public, max-age=31536000, immutable`

- 公共推荐列表（如首页热门视频）：

  - `Cache-Control: public, s-maxage=60, stale-while-revalidate=300`

- 强个性化的用户数据（订单列表、消息等）：
  - `Cache-Control: private, no-store` 或不设置缓存，让 CDN 不做共享缓存。

### 5. 发布与缓存失效流程（推荐实践）

一个比较健康的前端发版+CDN 缓存策略：

1. CI 构建产物，生成带 hash 的静态文件；
2. 将构建产物上传到对象存储或源站（注意：旧文件可以暂时保留以兼容旧 HTML）；
3. **只刷新入口 HTML 对应的 URL**（或某个前缀），而不是全站清缓存；
4. 等新 HTML 生效后，新用户会拿到新的入口 HTML，从而加载到新的 hash 资源；
5. 旧用户在刷新页面或缓存过期后自然切换到新版本。

---

## 十、前端如何排查 CDN 相关问题？

遇到“明明发版了用户还看不到”“不同地区表现不一致”时，可以按以下顺序排查：

1. **浏览器 DevTools → Network 面板**

   - 查看响应头：
     - `Cache-Control`、`Age`、`ETag`；
     - 是否有 `x-cache: HIT/MISS`、`via` 等 CDN 特有头；
   - 对比“强刷（Ctrl+F5）”和“普通刷新”有何差别。

2. **用 curl 或 httpie 观察头信息**

   ```bash
   curl -I https://static.example.com/app.8f3a9c.js
   ```

   - 对比不同参数或 header（例如是否带某个 Cookie）时响应是否变化；
   - 检查 `Vary` 设置是否合理（是否因为一些无关 header 导致缓存命中率下降）。

3. **查看 CDN 控制台**

   - 缓存命中率（Hit Ratio）；
   - 回源流量是否异常增高；
   - 是否存在频繁全站刷新缓存操作。

4. **与后端/运维确认**

   - 源站是否正确设置了缓存头与 `Vary`；
   - 是否最近调整过 WAF / 负载均衡 / 证书配置；
   - 是否新增了多源站、多机房，导致行为差异。

---

## 十一、总结：CDN 是现代前端的必修课

回到三个核心问题：

1. **什么是 CDN？**

   - 一张全球（或区域）分布的内容分发网络，通过缓存、就近访问和网络/安全优化，让你的网站“离用户更近”。

2. **CDN 能为我们做什么？**

   - 降低 RTT，加速静态资源加载；
   - 优化动态内容传输（网络路径、协议、边缘函数等）；
   - 构建安全防护层（抗 DDoS、WAF、TLS/SSL 终止等）；
   - 降低源站带宽与服务器成本。

3. **前端工程师为什么要懂 CDN？**
   - 在现代前端工程里，**“会写组件”远远不够**：
     - 你需要知道构建产物如何部署到 CDN；
     - 知道如何为不同类型资源设计缓存策略；
     - 知道如何分析首屏时间、TTFB、缓存命中率；
     - 知道如何与后端、运维配合设计整体架构和发版流程。

只要你的项目希望：

- 打开更快；
- 更稳、更安全；
- 更省钱、更可控；

CDN 就值得你花时间认真研究和实践。
