---
group:
  title: browser
  order: 7
title: DOM 的本质
toc: content
order: 2
---

## 当你以为自己"已经会 DOM"的那一刻

几乎每一个前端开发者，都经历过类似的阶段：学会 `document.querySelector`，能增删一些节点，能在控制台里随手改改样式，于是心里默默给自己贴上一个标签——"**DOM（Document Object Model，文档对象模型）已经会了**"。

与此同时，另一个词偶尔从面试题、教科书角落里蹦出来：**BOM（Browser Object Model，浏览器对象模型）**。你隐约知道它和 `window`、`history` 之类的东西有关，却说不清到底边界在哪；遇到所有和浏览器有关的接口，下意识地把它们统统叫做"DOM API"也没什么心理负担。

**真正的问题，从来不在于你记不记得某几个名词，而在于你默认了一个错误的前提：DOM = 浏览器 API。**

如果沿着这个前提继续往前走，你会发现很多事情解释不通：为什么有些接口明明和文档无关，却也出现在 `window` 上？为什么 Canvas、WebAudio 这种东西，总感觉"不是很 DOM"，却又是浏览器提供的能力？为什么不同规范里，时而提 DOM，时而提 HTML，时而又冒出个什么"Web API"？

要摆脱这种混沌，第一步需要做的其实很简单，却又极少有人认真做过：**换一个更大的视角**——把所有和浏览器交互的能力，统称为 **Browser API（浏览器编程接口）**，而 DOM 只是其中最重要、最核心的一块；BOM 不过是一个历史悠久的小角落；Canvas、Fetch、WebAudio、Service Worker 等等，则散落在"其他 Web API"的广袤平原上。

```ascii
┌─────────────────────────────────────────────┐
│             浏览器 API 全景图               │
├─────────────────────────────────────────────┤
│  DOM (Document Object Model) 文档对象模型   │
│  ┌─────────────────────────────────────┐    │
│  │          Node (基类)                │    │
│  │  ┌─────────────────────────────┐    │    │
│  │  │        Element              │    │    │
│  │  │  ┌─────────────────────┐    │    │    │
│  │  │  │     HTMLElement     │    │    │    │
│  │  │  └─────────────────────┘    │    │    │
│  │  └─────────────────────────────┘    │    │
│  │  ┌─────────────────────────────┐    │    │
│  │  │      CharacterData          │    │    │
│  │  │  ┌─────────────────────┐    │    │    │
│  │  │  │        Text         │    │    │    │
│  │  │  ├─────────────────────┤    │    │    │
│  │  │  │       Comment       │    │    │    │
│  │  │  └─────────────────────┘    │    │    │
│  │  └─────────────────────────────┘    │    │
│  └─────────────────────────────────────┘    │
│                                             │
│  BOM (Browser Object Model) 浏览器对象模型 │
│  ┌─────────────────────────────────────┐    │
│  │  window, navigator, history, ...    │    │
│  └─────────────────────────────────────┘    │
│                                             │
│  其他 Web API (非严格意义上的 DOM/BOM)     │
│  ┌─────────────────────────────────────┐    │
│  │  Fetch, Canvas, WebAudio, ...       │    │
│  └─────────────────────────────────────┘    │
└─────────────────────────────────────────────┘
```

在这张更大的地图中，DOM 的位置反而变得清晰起来：它既不是全部，也远不是"几个操作节点的方法"那么简单。它真正提供的，是一整套关于"**文档是棵树**"的世界观：文档可以被拆解成各种节点；这些节点有继承关系，有类型系统；它们被挂载在一棵树上，而你可以在这棵树中行走、改造、比较。

理解这件事的意义，不在于多会几个方法，而在于你开始习惯用"**一棵树**"来理解页面，而不是用"一堆标签"来理解它。此刻，你写的已经不再只是浏览器脚本，而是在一片结构化的森林中行动。

而故事真正的起点，是那句看似平平无奇的问题：**DOM 树上，究竟都挂着些什么东西？**

---

## "标签表"之外的世界：DOM 是一套类型系统

很多人学 DOM，是从 `<div>`、`<span>`、`<a>` 这些标签开始的；看过一点文档之后，会知道"这些标签在 DOM 里被表示为元素节点（Element）"。如果故事停在这里，你脑中会自然浮现这样一个粗糙的概念：**DOM = 一张标签表 + 一些操作方法**。

而 DOM 真正的设计，却是从完全相反的方向出发的。

在 DOM 的世界里，有一个最顶层的基类：**`Node`**。凡是能够挂在文档树上的东西，统统是 `Node` 的子类。`Node` 就像一份抽象的"节点协定"：只要你想成为这棵树上的一员，就必须遵守它规定的那一套属性和行为——有父节点、有子节点、有兄弟节点，可以被插入、删除、替换、克隆。

在 `Node` 之下，世界才开始分流：

```ascii
DOM 节点家族谱
┌─────────────────────────────────────────────────────────┐
│                         Node                            │ ← 所有节点的基类
└──────────────────────────┬──────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
┌───────▼───────┐  ┌───────▼───────┐  ┌───────▼─────────────┐
│   Element     │  │ CharacterData │  │   DocumentType      │
│ (元素节点)    │  │ (字符数据节点)│  │ (文档类型节点)      │
└───────┬───────┘  └───────┬───────┘  └─────────────────────┘
        │                  │
        │          ┌───────┼───────┐
        │          │       │       │
┌───────▼───────┐  │ ┌─────▼─────┐ │ ┌─────────────────────┐
│  HTMLElement  │  │ │   Text    │ │ │ DocumentFragment    │
│ (HTML元素)    │  │ │ (文本节点)│ │ │ (文档片段)          │
└───────┬───────┘  │ └───────────┘ │ └─────────────────────┘
        │          │               │
┌───────▼───────┐  │ ┌───────────┐ │
│ HTMLDivElement│  │ │  Comment  │ │
│   (<div>)     │  │ │ (注释节点)│ │
└───────────────┘  │ └───────────┘ │
                   │               │
                   │ ┌───────────┐ │
                   │ │ CDATASection │
                   │ │ (CDATA节点) │
                   │ └───────────┘ │
                   └───────────────┘
```

一条支线，是我们最熟悉的 **`Element`**。它对应的是各种可见结构：`<div>`、`<p>`、`<a>`，以及你每天都在写的无数 HTML 标签。**Element 是"可见结构"的代表，但绝不是"全部节点"**。

另一条同样重要但经常被忽略的支线，是 **`CharacterData`**。从名字就能看出来，它关心的是"字符数据"这一类东西。在这条线下面，站着几位容易被当成背景角色的主角：

- `Text`，文本节点——标签之间的文字、标签内部的内容，甚至那些被格式化工具带来的空格和换行，在 DOM 看来，都有资格成为一个独立的 `Text` 节点。
- `Comment`，注释节点——`<!-- ... -->` 里的内容，从渲染角度看是"应该消失"的东西，在 DOM 中却被完整保留。
- `CDATASection`，CDATA 节点——更多活跃在 XML 世界中的角色，在 HTML 中几乎被时代抛在身后，但在规范中依然占有一个位置。

从抽象角度看，`CharacterData` 是一类"持有字符内容的节点"的统一基类，而 `Text`、`Comment`、`CDATASection` 只是不同的具体表现。现实中，我们用得最多的当然是 `Text`，但那张完整的家族谱本身，才是 DOM 的精妙之处：**它用一套面向类型的系统，描述了文档里所有可以存在的"东西"**。

再往外走，你会遇到那些看似"鸡肋"，却在关键时刻不可或缺的角色。

**`DocumentFragment`（文档片段）** 就是典型代表。它是 `Node` 的子类，可以拥有自己的子树，却不能作为真正的"根"挂在文档树上。你可以把它想象成一个"离线的迷你 DOM"：你可以在里面自由地创建、插入、删除节点，等到时机成熟，再一次性把整颗子树插入真实文档中。而一旦插入，它自己会"溶解"掉，只把自己的孩子们留在最终结构里。

这让它天生适合用来做**批量 DOM 操作的性能优化**：与其对真实 DOM 连续做 100 次插入，不如在一个 `DocumentFragment` 里做 100 次，然后只把 fragment 自己挂上去一次。浏览器只需要为这一次变更重新计算布局，所有中间过程产生的频繁重排都被"离线"消化掉了。

还有 **`DocumentType`（文档类型节点）**，对应的就是我们在 HTML 顶部那行看似古老的 `<!DOCTYPE html>`。在日常开发中你几乎不会直接操作它，但它的存在提醒你：**只要语法里有东西，DOM 往往都给它安排了一个对应的类型**。

而在 `Element` 这条看似齐整的分支之下，世界又再一次分裂——这一次，分裂的不是"节点种类"，而是"语言与命名空间"。

DOM 并不是为 HTML 独家打造的。一旦引入命名空间（Namespace）的概念，同一棵 DOM 树上就可以挂载完全不同语义的语言：HTML、SVG、MathML……

于是你会看到：

- 属于 HTML 命名空间的元素，被表示为 `HTMLElement` 及其子类，如 `HTMLDivElement`、`HTMLParagraphElement`。
- 属于 SVG 命名空间的元素，对应 `SVGElement` 及其子类，管理的是 `<circle>`、`<path>` 之类矢量图形。
- 属于 MathML 的部分，则通过 `MathMLElement` 来承载数学公式结构。

至此，你才真正意识到：**DOM 从来不是"标签表"，而是一套完整的类型系统**。标签只是展现形式，类型系统才是骨骼结构。文本、注释、文档片段、文档类型、HTML 元素、SVG 元素、MathML 元素……它们都在那棵抽象的类型树上占据着自己的位置。

当你的视线从"我常见到的标签"提升到"规范中存在的所有节点类型"，DOM 不再是凌乱 API 而是一张有层次、有血缘、有约束的"家族谱"。
你看到的不再只是 `<div>`、`<span>` 的罗列，而是一整套从 `Node` 出发、逐级分化的抽象结构。

当这张家族谱在脑中真正展开时，会发生一件细微却重要的变化：你写代码的时候，不再只是"叫浏览器帮我改一下这个标签"，而是非常清楚地知道，自己正在和一棵树上的哪一类节点打交道，它在类型系统里的位置是什么，它能做什么、不能做什么，它和其它节点之间有哪些天然的关系。

从这里开始，你就有条件迈入下一步：既然 DOM 是一棵树，那么，如何在这棵树上行走？

---

## 在树上行走：从"直接选中"到"沿着结构走过去"

大多数人接触 DOM 的第一反应，是学会一些选择器：`getElementById`、`querySelector`、`querySelectorAll`。这些 API 带来的体验很像开传送门——你给出一个描述，浏览器就把符合描述的节点直接塞给你。久而久之，你习惯于"瞬移"，而不再去思考：这棵树本身是怎样组织的？

真正的 DOM 导航能力，从来不是"会写几个选择器"，而是你能不能在拿到一个节点之后，沿着这棵树的结构一步一步"走"到你想去的地方。

从规范的角度看，DOM 为这种"行走"准备了两套平行世界：一套以 `Node` 为中心，一套以 `Element` 为中心。

在 `Node` 的世界里，树是完整的、赤裸的，没有任何"美化视角"。文本节点、注释节点、空白节点、元素节点，一概平等。你通过 `parentNode` 向上爬，通过 `childNodes` 向下走，通过 `previousSibling` 和 `nextSibling` 在同一层中横移。只要某个"东西"真实存在于文档树中，它就会出现在你的视野里，不会因为"看不见"而被自动忽略。

```javascript
// Node 视角的导航
const parent = node.parentNode;
const children = node.childNodes;
const firstChild = node.firstChild;
const lastChild = node.lastChild;
const previous = node.previousSibling;
const next = node.nextSibling;
```

这套 API 极其真实，却也极其"残酷"：只要你用过格式化工具把 HTML 排版成多行、缩进了一点空格，那么这些换行和空格就有可能成为独立的 `Text` 节点。当你满心以为 `firstChild` 一定是第一个 `<li>` 的时候，现实冷冷地丢给你一个类型为 3 的文本节点。

这恰恰暴露了一件常被忽略的事实：**浏览器渲染的是"视觉结构"，DOM 维护的是"语法结构"**。缩进、换行、注释，在视觉上是"辅助信息"，在 DOM 中却都是货真价实的节点。

于是另一套更贴近"人眼"的导航方式登场了：以 `Element` 为核心的元素导航。在这套 API 中，文本节点、注释节点统统被排除在外，树被重新投影成"只有元素"的简化版本。你通过 `children` 获取子元素，通过 `firstElementChild`、`lastElementChild` 获取首尾节点，通过 `previousElementSibling`、`nextElementSibling` 在兄弟元素之间穿梭。父节点则通过 `parentElement` 获取。

```javascript
// Element 视角的导航
const parentEl = element.parentElement;
const childrenEl = element.children;
const firstEl = element.firstElementChild;
const lastEl = element.lastElementChild;
const previousEl = element.previousElementSibling;
const nextEl = element.nextElementSibling;
```

对于日常开发而言，这套"元素视角"的世界明显更加好用——它屏蔽了那些对布局无直接影响却会干扰导航逻辑的细节，你看到的几乎就是审查元素面板中那棵干净利落的树。也因此，它往往也是我们更值得优先使用的那组 API。

有趣的是，这两套世界之间并不是完全割裂的。比如 `parentNode` 和 `parentElement`，在绝大多数实际场景中给出的结果是相同的；但是从设计语义和历史包袱的角度看，这种"重复"却是刻意保留的——有时候它只是为了让你在读代码时更直觉，有时候则是为了兼容那些并不保证"父节点一定是元素"的环境。

当你真正同时站在这两套视角里，你就会慢慢学会一种更精细的思考方式：**什么时候需要看见全部节点，什么时候只关心元素；什么时候要对空白文本敏感，什么时候干脆把它们当作不存在**。你不再被简单粗暴的"DOM 树 = 元素树"所蒙蔽，而是可以根据问题本身，自觉地选择合适的视角。

更重要的是，一旦你开始习惯先拿到一个节点，然后沿着父子、兄弟关系"走过去"，你就悄悄完成了从"平面思维"向"路径思维"的跃迁。你不再只会写一个足够长的 CSS 选择器直接命中目标，而是会问自己：从这里出发，我可以通过哪些关系一步一步找到我要的那个位置？这意味着，你不再依赖字符串式的规则匹配，而是在真正理解结构本身。

走惯了这棵树，你自然会问出下一个问题：我既然能走，那能不能改？

---

## 改造这棵树：用最少的手势完成最多的重写

如果说导航 API 让你获得了"在树上走路"的能力，那么结构操作 API 则赋予你了一种更接近"上帝视角"的权力——你可以在这棵树上插入新的枝丫，可以剪掉某个子树，也可以把一整段结构连根换掉。

有意思的是，DOM 在这件事上的设计并不追求"花哨"，而是极其克制地围绕一个原则展开：**用最少的原子操作，组合出尽可能丰富的改造能力**。

最经典的一对例子，是 `appendChild` 和 `insertBefore`。

`appendChild` 的语义极其简单：把给定节点挂在当前节点的最后一个子节点位置上。如果你把一个父节点的所有子节点看成一排排列的元素，那么它们之间存在 n+1 个"插入点"，`appendChild` 永远对应最后那一个。在很多人眼中，它几乎成了"往下加东西"的唯一代表。

```javascript
// appendChild 示例
const newDiv = document.createElement('div');
parentElement.appendChild(newDiv);
```

而 `insertBefore` 则稍显别扭：你必须先给出一个"参考节点"，DOM 才能理解"在它前面插入"。这听起来并不直观，却在设计上极为关键——只要有了 `insertBefore` 和 `appendChild`，你就拥有了在任何一个插入点放置节点的能力。可以说，**整个"插入到任意位置"的需求，只靠这两个原子操作就被完全覆盖了**。

```javascript
// insertBefore 示例
const newDiv = document.createElement('div');
const referenceNode = parentElement.children[2];
parentElement.insertBefore(newDiv, referenceNode);
```

这也是为什么 DOM 里一直没有那个"所有人都觉得应该存在"的方法：`insertAfter`。不是没人想到，而是从"最小完备集"的角度看，它是多余的。你完全可以用 `insertBefore` + `nextSibling` 模拟出一个 `insertAfter`，甚至还可以把这个组合封装成自己的工具函数。于是，DOM 保留了表达力，去掉了冗余的 API。

同样的节制，也体现在删除和替换上。DOM 把"删除"的权力，牢牢掌握在父节点手中：你不能让某个节点"自杀"，只能通过其父节点调用 `removeChild` 把它从子列表中摘掉。从树的直觉看，这再自然不过——真正决定"树形结构"的，是父亲对孩子的引用，而不是孩子自己的主张。

```javascript
// removeChild 示例
const childToRemove = parentElement.children[1];
parentElement.removeChild(childToRemove);
```

在这两个原子动作之上，`replaceChild` 又出现为一种"语义上的合并"：它本质上不过是"先删掉旧节点，再在原位插入新节点"的组合，却被赋予了一个独立 API 的地位。一方面，它让调用者更简洁地表达"我要替换这个位置的内容"，另一方面，也为浏览器在实现时提供了潜在的优化空间——这一次改动，在语义上本来就是"原子"的。

```javascript
// replaceChild 示例
const newDiv = document.createElement('div');
const oldChild = parentElement.children[1];
parentElement.replaceChild(newDiv, oldChild);
```

再往深一点看，还有几组名字略显冷门，但一旦用过就很难忘掉的 API：`compareDocumentPosition`、`contains`、`isEqualNode`、`isSameNode`。

它们不负责改变结构，而负责描述结构之间的关系：两个节点谁在前谁在后，有没有包含关系，是不是在同一个文档之中；两个节点是否"长得一样"，是否引用的是同一个对象。许多看似可以"自己写逻辑凑合实现"的判断，一旦牵涉到各种边界情况，就会变得既冗长又脆弱。DOM 索性向你坦诚：这些麻烦的细活，交给我来做。

```javascript
// 节点关系判断示例
const node1 = document.getElementById('node1');
const node2 = document.getElementById('node2');

// 检查节点位置关系
const position = node1.compareDocumentPosition(node2);

// 检查是否包含
const isContained = node1.contains(node2);

// 检查节点是否相等
const isEqual = node1.isEqualNode(node2);
const isSame = node1.isSameNode(node2);
```

而在所有"改造能力"中，也许最有魔力的是 `cloneNode`。它让你从"手工一个个构造节点"，跃迁到"复制一棵已经存在的子树，然后按需微调"。模板渲染、列表生成、编辑器搭建——只要涉及大量结构重复的场景，这种"克隆再改"的方式几乎总是更加简洁、更加高效。

```javascript
// cloneNode 示例 - 深拷贝整个子树
const originalElement = document.getElementById('template');
const clonedElement = originalElement.cloneNode(true);
document.body.appendChild(clonedElement);
```

当你再把视线拉远一点，会发现 DOM 还有一些更"重量级"的武器：Range API 帮你从"以节点为单位"走向"以范围为单位"的精确操作；Traversal API 则提供了一整套"如何系统遍历整棵树"的工具（在实际开发中，人们常常发现：直接用选择器配合递归遍历，往往比这套 API 更直观、可控。结果就是，这组 API 在现实中的使用率并不高，甚至到了"了解不一定要用"的程度）。它们的学习门槛稍高，使用频率不一定是日常工作中的主角，却在富文本编辑器、选区操作、复杂分析工具中展现出难以替代的力量。

至此，你掌握了三件事：**如何在树上行走，如何在树上改造，以及如何判断两段树之间的关系**。这些能力听起来都贴着"DOM 操作"的标签，但其实已经可以被抽象成更普遍的东西。

于是问题自然浮现：如果把浏览器和 HTML 都暂时忘掉，这一整套能力，在更高的层次上，到底在做什么？

---

## "树上行走与重写"：一个可以带出浏览器世界的模型

如果要用一句话概括我们从 DOM 学到的精华，那就是：**学会在一棵树上行走，并有能力重写它**。

这句话看似抽象，实际上可以拆解成清晰的三层。

第一层，是最根本的前提——**世界往往是树状的**。
DOM 是棵树，这点已经无需多言。而只要你稍微把视线从浏览器挪开，就会发现类似的结构比比皆是：React 里的组件树，Vue 的虚拟 DOM，Flutter 的 Widget 树，原生 UI 系统里的视图层级，甚至后端模板渲染时组装出来的页面结构。它们有一个共同点：都以父子关系组织，都存在"根""枝""叶"的分层。

一旦你习惯用"这是棵树"来看待界面，而不是用"这是一堆并列的元素"来看待它，很多原本模糊的概念会突然变得清晰：状态怎么传递、事件如何冒泡、样式为什么会继承、某个改动为什么会重排整个区域……这些现象背后，几乎都能找到那棵树的影子。

第二层，是**在树上行走的能力**。
这对应着节点导航与元素导航的所有 API，但它的本质并不局限于具体的属性名。更本质的是，你开始自然地用"路径"而不是"点"来理解结构——从某个节点出发，向上能找到谁，向下能抵达谁，向左右又有哪些兄弟，以及在不同视角下这些路径包含了哪些细节、忽略了哪些噪音。

这种行走能力的一个重要效果，是让你从"凑选择器"转向"利用关系"：你不再总是写一长串 CSS 选择器来命中一个元素，而是更愿意先锁定一个稳定的参照点，然后从它出发，通过父子、兄弟关系移动到目标位置。久而久之，你会发现自己的代码更健壮——因为结构关系往往比类名更不容易随意被改动。

第三层，则是**在树上重写的能力**。
这就是所有结构操作 API 的抽象：插入、删除、替换、克隆、比较、复制子树、搬移子树……你会逐渐形成一个非常清晰的直觉：任何复杂的界面变更，最终都可以拆解为若干原子动作——在某个父节点下的第 n 个插入点挂上一棵新子树，从另一个位置摘下一棵子树，把一段结构整体替换为另一段等价结构。

一旦你习惯用这种"树上重写"的方式思考，即使在使用 React、Vue 这类更上层的框架时，你也能看穿它们的封装——表面上是声明式地说"这里渲染一个列表"，底层仍然是"一棵虚拟树根据状态变化被不断重写"，然后再通过协调算法映射到真实 DOM 树上。你会明白，所谓的"虚拟 DOM diff"，无非就是在比较两棵树的结构差异，并寻找一组最合适的原子重写动作去弥合它们。

更重要的是，这个"树上行走与重写"的模型并不被 DOM 所垄断。任何以树状结构为基础的系统——语法树、布局树、配置树、权限树——都可以被你用同样的方式对待。你从 DOM 学到的，不再只是"怎么操作节点"，而是一套可以迁移到更广阔领域的结构化思维。

当你真正做到这一点，DOM 就从一个具体技术点，变成了一个训练场：它训练你习惯找到那棵"隐藏的树"，训练你阅读和修改这棵树，训练你用最小的改动完成最精确的结构重写。浏览器 API 成了引子，而你获得的是一整套针对树形世界的"通用武功"。

---

## 超越 API 清单：从"会用 DOM"到"理解结构世界"

走到这里，或许值得停下来问自己一个看似简单的问题：
当你说"我会 DOM"的时候，你到底会的是什么？

如果"会"只意味着记住几个方法名，知道 `appendChild` 会把元素加到最后，知道 `innerHTML` 可以粗暴地改掉一整片区域，那么你拥有的是一份工具清单，而不是一套结构认知。这样的"会"，在短期内也许足够应付业务，却很难支撑你跨越技术栈的变化。

真正值得追求的，是另一种状态：当你面对一个完全陌生的 UI 系统时，你本能地去寻找那棵"隐形的 DOM 树"——即便它不叫 DOM；你会问自己，这里有哪些节点类型，它们的继承关系如何，什么是元素，什么是文本，什么是片段；你会想清楚，在这棵树上我如何从一个节点走到另一个节点，又如何以最小的原子动作去重写它。

这时，你再回头看 DOM，会发现它早已经从"浏览器的一个知识点"变成了你的思维起点。
你理解 Browser API 的版图，知道 DOM 只是其中最耀眼的中心；你知道 BOM 只是历史中的一个侧影，Fetch、Canvas、WebAudio 则构成了另一片广阔大陆；而 DOM 本身，则在这张地图上承担着一份独特的角色——它既是你看待页面结构的第一课，也是你迈向一切树形系统的通用桥梁。

也许更重要的问题是：
在未来技术栈更迭、框架轮换的浪潮中，你究竟想带走什么？

如果你的答案只是"记住更多 API 名字"，那么每一次迁移都会是一次从零开始的背诵；
但如果你的答案是"掌握一套可以迁移的结构化思维"，那么每一次迁移，都只是把同一套武功，施展在一棵新的树上。

DOM，恰好是这套武功的最好练习场之一。

当你下一次打开浏览器的 Elements 面板，看见那棵不断展开、折叠的结构树时，不妨多想一步：
我眼前看到的，真的是"标签"吗？
还是一整套可以被行走、可以被重写、可以被迁移到任何 UI 世界里的结构模型？

从这一刻起，你不再只是一个"会调 DOM 的人"，而是在结构世界里有自己坐标的人。
