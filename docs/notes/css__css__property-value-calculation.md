---
group:
  title: css
  order: 2
title: 属性值的计算过程
toc: content
order: 4
---

## 什么是 CSS 属性值的计算过程

CSS 属性值的计算过程，是指一个元素从**所有 CSS 属性都没有值**到**所有 CSS 属性都有值**的完整过程。

### 为什么需要理解这个过程？

很多开发者认为，元素的 CSS 属性就是我们写的那些样式。但实际上，即使你只给一个 `<h1>` 元素写了一个 CSS 属性，在浏览器的计算结果（Computed）中，你会发现 **h1 元素的每一个 CSS 属性都有值**。

在 Chrome DevTools 中查看元素的 Computed 面板，你会看到数百个 CSS 属性都有具体的值。这是因为浏览器必须保证每个元素的所有 CSS 属性都有明确的值，才能正确渲染页面。

### 计算过程的四个步骤

CSS 属性值的计算遵循严格的四步流程：

1. **确定声明值**（Declared Value）
2. **层叠**（Cascading）
3. **继承**（Inheritance）
4. **使用默认值**（Default Value）

下面我们详细讲解每个步骤。

## 第一步：确定声明值

在这一步，浏览器会查看**两个样式表来源**：

### 1. 样式表的两个来源

- **作者样式表（Author Stylesheet）**：开发者编写的 CSS 样式
- **浏览器默认样式表（User Agent Stylesheet）**：浏览器内置的默认样式

例如，即使你没有给 `<h1>` 元素写任何样式，浏览器也会应用默认样式表中的样式，如 `display: block`、`font-weight: bold` 等。

:::info{title=关于块级元素的说法}
现在 CSS 规范不再使用"块级元素"、"行内元素"这种说法，而是使用"块盒（Block Box）"和"行盒（Inline Box）"的概念。

元素之所以表现为块级，是因为浏览器默认样式表给它设置了 `display: block`，而不是因为它天生就是"块级元素"。
:::

### 2. 处理无冲突的样式

第一步的任务是：**从两个样式表中找出没有冲突的样式，直接作为计算结果**。

例如：

- 作者样式表设置了 `color: red`，浏览器默认样式表没有设置 `color` → 无冲突，直接使用
- 浏览器默认样式表设置了 `display: block`，作者样式表没有设置 `display` → 无冲突，直接使用

### 3. 值的转换

在确定声明值时，浏览器还会将**预设值转换为绝对值**：

- `color: red` → `color: rgb(255, 0, 0)`
- `font-weight: bold` → `font-weight: 700`

第一步完成后，部分 CSS 属性已经有了值，但还有大量属性没有值，需要进入下一步。

## 第二步：层叠（Cascading）

CSS 的全称是"Cascading Style Sheets"（层叠样式表），层叠是 CSS 的核心机制。

### 层叠的作用

**层叠专门用来解决样式冲突**。当同一个 CSS 属性在多个样式表中都有声明时，浏览器需要决定最终使用哪一个值。

:::warning{title=层叠的前提条件}
只有**有冲突的样式**才会进入层叠过程。如果一个属性没有冲突，它在第一步就已经确定了，不需要层叠。
:::

### 层叠的三个比较步骤

当多个样式发生冲突时，浏览器按以下顺序进行比较，直到决出胜者：

#### 1. 比较重要性（Importance）

重要性从高到低的顺序：

1. 带 `!important` 的作者样式
2. 带 `!important` 的浏览器默认样式
3. **作者样式**（最常用）
4. **浏览器默认样式**（最常用）

在日常开发中，我们很少使用 `!important`，所以主要关注第 3 和第 4 项：**作者样式的重要性高于浏览器默认样式**。

**经典面试题：**

```css
* {
  font-size: 16px;
}
```

```html
<h1>标题</h1>
```

问：`<h1>` 的字体大小是 16px 还是 32px（浏览器默认样式表中 `h1` 的 `font-size` 为 2em≈32px）？

**答案是 16px**。虽然通配符选择器 `*` 的特殊性（权重）为 0，远低于浏览器默认样式，但在第一步"比较重要性"时，作者样式就已经胜出，根本不会走到"比较特殊性"这一步。

#### 2. 比较特殊性（Specificity）

如果重要性相同，就比较**选择器的特殊性**（也叫"权重"）。

特殊性的计算方法是四位数值 `(a, b, c, d)`：

- `a`：内联样式的数量（style 属性）
- `b`：ID 选择器的数量
- `c`：类选择器、属性选择器、伪类选择器的数量
- `d`：元素选择器、伪元素选择器的数量

**比较规则：从左到右依次比较，高位相同才比较下一位。**

**示例：**

| 选择器              | 特殊性计算   | 结果 |
| ------------------- | ------------ | ---- |
| `.test`             | (0, 0, 1, 0) | 0010 |
| `h1`                | (0, 0, 0, 1) | 0001 |
| `.test h1`          | (0, 0, 1, 1) | 0011 |
| `div .test h1`      | (0, 0, 1, 2) | 0012 |
| `#id .test`         | (0, 1, 1, 0) | 0110 |
| `.test:first-child` | (0, 0, 2, 0) | 0020 |

VSCode 会自动显示选择器的特殊性，把鼠标悬停在选择器上即可查看。

#### 3. 比较源次序（Order）

如果前两步都无法决出胜负，则**后声明的样式覆盖先声明的样式**。

```css
.test {
  font-size: 20px;
}

.test {
  font-size: 30px; /* 这个会生效 */
}
```

### 层叠示例

假设有以下冲突的样式：

```css
/* 浏览器默认样式 */
h1 {
  font-size: 2em;
}

/* 作者样式 */
.title {
  font-size: 20px;
}

div .title {
  font-size: 30px;
}
```

层叠过程：

1. **比较重要性**：作者样式重要性更高，浏览器默认样式被淘汰
2. **比较特殊性**：`.title` (0010) vs `div .title` (0012)，后者胜出
3. 最终结果：`font-size: 30px`

第二步完成后，所有有冲突的属性都确定了值，但仍有许多属性没有值，需要进入第三步。

## 第三步：继承（Inheritance）

经过前两步，仍然有很多 CSS 属性没有值。对于这些属性，浏览器会尝试从父元素继承值。

### 继承的两个前提条件

继承的发生需要**同时满足**两个条件：

#### 1. 该属性当前没有值

如果属性在前两步已经确定了值，就不会发生继承。

就像一个人自己有钱买车买房，就不需要"啃老"了。

#### 2. 该属性是可继承的

并不是所有 CSS 属性都可以被继承。

**可视化对比图：**

![继承属性示意图](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240610014039.png)

##### 默认可继承的属性

**设计原则：** 只有**不影响布局**的属性才会默认继承。

**（1）字体相关（全部可继承）**

```css
.parent {
  font-family: 'Helvetica', sans-serif;
  font-size: 18px;
  font-style: italic;
  font-weight: bold;
  font-variant: small-caps;
}
/* 子元素自动继承所有字体属性 */
```

**（2）文本相关（大部分可继承）**

```css
.parent {
  color: #333; /* ✅ 继承 */
  text-align: center; /* ✅ 继承 */
  text-indent: 2em; /* ✅ 继承 */
  line-height: 1.5; /* ✅ 继承 */
  letter-spacing: 1px; /* ✅ 继承 */
  word-spacing: 2px; /* ✅ 继承 */
  white-space: nowrap; /* ✅ 继承 */
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3); /* ✅ 继承 */
}
```

**（3）列表相关**

```css
ul {
  list-style: square inside;
  list-style-type: disc;
  list-style-position: inside;
  list-style-image: url('bullet.png');
}
/* 所有 li 子元素继承这些样式 */
```

**（4）其他可继承属性**

```css
.parent {
  visibility: hidden; /* ✅ 继承 */
  cursor: pointer; /* ✅ 继承 */
}
```

##### 默认不可继承的属性

**布局相关属性**都不会继承（避免布局混乱）：

```css
.parent {
  width: 500px; /* ❌ 不继承 */
  height: 300px; /* ❌ 不继承 */
  margin: 20px; /* ❌ 不继承 */
  padding: 10px; /* ❌ 不继承 */
  border: 1px solid #ccc; /* ❌ 不继承 */
  background: #f0f0f0; /* ❌ 不继承 */
  display: flex; /* ❌ 不继承 */
  position: absolute; /* ❌ 不继承 */
}
```

### 继承示例

```html
<div style="text-align: center; color: red;">
  <p>这段文字会继承父元素的样式</p>
</div>
```

对于 `<p>` 元素：

- `text-align`：可继承，且前两步没有值 → 继承为 `center`
- `color`：可继承，且前两步没有值 → 继承为 `red`

### 常见问题：为什么 `<a>` 标签不继承父元素的颜色？

```html
<div style="color: red;">
  <span>这是红色的</span>
  <a href="#">这不是红色的</a>
</div>
```

**原因：** 浏览器默认样式表给 `<a>` 元素设置了 `color` 属性（通常是蓝色）。

在第一步"确定声明值"时，`<a>` 的 `color` 属性就已经有值了，所以不会进入第三步继承。

**解决方法：** 后面会介绍 `inherit` 关键字。

第三步完成后，可继承的属性都有了值，但还有大量不可继承的属性仍然没有值，需要进入第四步。

## 第四步：使用默认值（Default Value）

经过前三步，仍然有大量 CSS 属性没有值。浏览器必须保证**每个元素的所有 CSS 属性都有值**才能正常渲染，因此进入最后一步：使用默认值。

### 默认值的定义

每个 CSS 属性都有自己的**初始值（Initial Value）**。

例如：

- `background-color` 的默认值是 `transparent`（透明）
- `display` 的默认值是 `inline`
- `position` 的默认值是 `static`
- `width` 的默认值是 `auto`

### 查看默认值

在 MDN 文档中，每个 CSS 属性都会明确标注其"初始值"（Initial value）。

### 计算过程总结

经过这四个步骤，浏览器能够保证每个元素的每个 CSS 属性都有明确的值。你可以在 Chrome DevTools 的 Computed 面板中看到完整的计算结果。

```text
1. 确定声明值 → 处理无冲突的样式（作者样式表 + 浏览器默认样式表）
2. 层叠       → 解决有冲突的样式（重要性 > 特殊性 > 源次序）
3. 继承       → 从父元素继承可继承的属性
4. 使用默认值 → 为剩余属性赋予初始值
```

:::warning{title=重要提示}
这四个步骤的顺序是**固定不变**的，不能调整。

作为开发者，我们编写的 CSS 代码**只会影响第一步和第二步**，间接影响第三步和第四步。
:::

---

## 实战应用：CSS 关键字

理解了属性计算过程后，我们可以更好地使用 CSS 提供的特殊关键字来控制属性值的计算。

## `inherit` 关键字：强制继承

### 作用

`inherit` 关键字表示：**将该属性的值设置为父元素该属性的值**。

### 误区澄清

很多人认为 `inherit` 是"强制触发第三步继承"，这是**错误的**！

`inherit` 的本质是：**把父元素的属性值复制粘贴到当前位置**。

它仍然在**第一步或第二步**就确定了属性值，不会进入第三步。

### 应用场景 1：让 `<a>` 标签继承父元素颜色

```css
a {
  color: inherit; /* 使用父元素的 color 值 */
}
```

**原理分析：**

1. 浏览器默认样式表：`a { color: blue; }`
2. 作者样式表：`a { color: inherit; }`
3. 发生层叠冲突，作者样式胜出
4. `inherit` 把父元素的 `color` 值复制到这里
5. 在**第二步层叠**时就确定了 `color` 值，不会进入第三步

### 应用场景 2：让 `<input>` 继承父元素字体大小

```css
input {
  font-size: inherit;
}
```

浏览器默认样式表给 `<input>` 设置了 `font-size`，导致它不会继承父元素的字体大小。使用 `inherit` 可以解决这个问题。

### 应用场景 3：简化子元素样式维护

```css
.container {
  width: 80%;
  margin: 0 auto;
}

.container .child {
  width: inherit; /* 自动跟随父元素的 width */
  margin: inherit; /* 自动跟随父元素的 margin */
}
```

**优势：** 当需要修改父元素的 `width` 或 `margin` 时，子元素会自动跟随，无需修改多处代码。

---

## `initial` 关键字：使用默认值

### 作用

`initial` 关键字表示：**将该属性设置为 CSS 规范定义的初始值（默认值）**。

### 应用场景：重置为默认值

```css
.default {
  line-height: initial; /* 设置为默认值 normal */
}
```

**使用场景：** 当你想让某个属性回归到 CSS 规范定义的初始值，但不想查文档去找具体的默认值是什么时，可以使用 `initial`。

**注意：** `initial` 是在**第一步或第二步**就确定了属性值，不是等到第四步才生效。

---

## `unset` 关键字：智能重置

### 作用

`unset` 是一个智能关键字：

- 如果该属性**可继承**，效果等同于 `inherit`
- 如果该属性**不可继承**，效果等同于 `initial`

### 应用场景：清除浏览器默认样式

```css
/* 传统方法：需要分别设置 */
* {
  margin: 0; /* 不可继承，需要设为默认值 */
  padding: 0; /* 不可继承，需要设为默认值 */
  font-size: inherit; /* 可继承，需要继承父元素 */
  list-style: none; /* 不可继承，需要设为默认值 */
}

/* 使用 unset：一次性处理 */
body * {
  all: unset; /* 重置所有 CSS 属性 */
}
```

**`all` 属性：** 特殊属性，代表所有 CSS 属性（除了 `direction` 和 `unicode-bidi`）。

**注意：** `all: unset` 会清除所有浏览器默认样式，包括让元素从块盒变成行盒，需要谨慎使用。

---

## `revert` 关键字：恢复浏览器默认样式

### 作用

`revert` 关键字表示：**使用浏览器默认样式表中的值**。

### 应用场景：让特定元素回归默认样式

```css
/* 统一按钮样式 */
button {
  all: unset;
  padding: 10px 20px;
  background: #007bff;
  color: white;
  border-radius: 4px;
}

/* 让某个按钮回归浏览器默认样式 */
button.default {
  all: revert;
}

button.default:hover {
  all: revert;
}

button.default:active {
  all: revert;
}
```

**使用场景：** 当你对所有按钮进行了统一样式设置，但希望某个特殊按钮保持浏览器原生样式时。

---

## 关键字对比总结

| 关键字    | 作用                                             | 适用场景                                                |
| --------- | ------------------------------------------------ | ------------------------------------------------------- |
| `inherit` | 使用父元素的值                                   | 让通常不继承的元素继承父元素样式（如 `<a>`、`<input>`） |
| `initial` | 使用 CSS 规范定义的初始值                        | 重置属性为默认值，不想查文档找默认值                    |
| `unset`   | 可继承属性用 `inherit`，不可继承属性用 `initial` | 智能重置，清除浏览器默认样式                            |
| `revert`  | 使用浏览器默认样式表的值                         | 恢复浏览器原生样式                                      |

---

## 调试技巧

当 CSS 样式出现问题时，可以按照属性计算过程进行排查：

1. 打开 Chrome DevTools，选中问题元素
2. 查看 Styles 面板，分析样式来源和冲突情况
3. 查看 Computed 面板，查看最终计算结果
4. 思考：这个属性是在哪一步确定的？
   - 第一步：是否有无冲突的声明？
   - 第二步：是否发生层叠？谁胜出了？
   - 第三步：是否发生继承？为什么没有继承？
   - 第四步：是否使用了默认值？

理解 CSS 属性值的计算过程，能够帮助你快速定位和解决样式问题，是前端开发者必备的核心知识。
