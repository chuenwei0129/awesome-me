作者：灵剑
链接：https://www.zhihu.com/question/568381672/answer/3003808386
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

生命周期里面调用了不幂等的网络请求等副作用操作这不妥妥的就是bug吗……至于清理，本来就为了保障你的网页继续执行的时候清理才有意义吧，浏览器网页本来就是随时可以关掉的，任何和网页关闭有关的回调都不能保证一定被调用。那什么叫做清理只能清理一次……这类问题的解决根本就没必要动用React，React本来就是个生成管理DOM的框架，DOM以外的逻辑从一开始就应该考虑用外部库而不是组件来管理，最多有一部分组件和外部库通过Effect连接起来用来将外部状态同步到UI上而已。像你说的网络一类的状态对于习惯其他语言的人来说本就不是问题，最简单的就是全局或者Singleton对象模式，这个对象有几种可以转换的状态，比如说最开始是未初始化，需要初始化的时候自动调用对应的网络请求走初始化流程，然后保持在工作状态，如果需要登出之类的走一下shutdown流程，之后恢复到未初始化状态，或者变成某种禁止状态之类，这些都跟React没有直接关系，首先保证你的代码脱离React也能很好工作，然后就很容易把它跟React集成起来。举一个例子来说，比如说你的网站有一个WebSocket用来监听通知，网页里面有多个组件都需要监听，但要共享一个WebSocket连接，这个连接在建立之后还得先发一点config过去然后接受一点信息之后才能发真正的监听请求，回复的消息需要统一解析分流，连接断开之后还希望能够自动恢复，而且你还希望只有在有监听需求的时候打开，没有监听需求的时候自动关闭，而且自动关闭还要延迟5秒防止组件刷新的时候反复断开连接再恢复，这已经很复杂了对吧，大致上来说思路应该是这样的：有一个全局的WebSocketListener对象，可以通过导出一个getWebSocketListener()方法，首次调用的时候构造，之后始终返回同一个对象对象简单提供addListener和removeListener两个API，add的时候指定要监听的对象和回调函数，remove的时候移除掉相应的回调函数，一旦有至少一个回调WebSocket就会建立，一个回调都没有的时候延迟5秒关闭WebSocket，期间如果又有addListener的操作就取消定时器为你的对象设计状态机：未连接，addListener时会建立WebSocket对象并转到尝试连接尝试连接，open事件后转到连接成功连接成功，发送config，等待回复，onMessage并校验成功之后转到工作状态，转化时尝试恢复Listener，发送相应的监听请求工作状态，可以申请和取消监听，分发回调。removeListener到没有Listener之后进入等待关闭状态等待关闭，设置定时器，定时器触发关闭后变回未连接任何时候遇到onClose或onError，转化到未连接状态，清除当前的WebSocket对象等待重新创建，如果当前仍然有Listener则开始尝试连接传统的状态机实现通过回调进行，比较先进的方式可以将整个工作循环写到一个不断执行的async函数中，两种方法都可行，对于这个例子来说还是回调简单一点处理API和状态转化的关系：addListener的时候，如果是工作状态则立即发送监听请求，否则先注册，等转化到工作状态之后延迟发送removeListener的时候，如果是工作状态则发送取消请求，否则直接取消注册即可正确实现这样一个WebSocketListener对象之后，跟React集成就非常容易了，显然就使用useEffect就行，在callback里面addListener，在callback里面removeListener。即便useEffect被调用两次，最多就是WebSocket里面多发送了一对开始监听和结束监听的消息，并没有什么大不了的。现在再比如说，你希望在WebSocket需要连接但尚未连接的时候显式提示，或者WebSocket连接失败的时候有个错误状态展示，应该怎么做？也很简单对吧，给WebSocketListener加一个onStateChange的事件，把刚才我们定义的状态暴露出来，同时按照需要细分一下，首次连接和出错之后的重新连接用不同的状态，那么可以在React的状态提示的组件当中使用useEffect获取WebSocketListener对象，增加一个onStateChange的事件监听回调，根据当前状态setState就可以展示出对应的连接状态了（回调首次触发之前手动设置一次state），相应的cleanup里面删除事件监听回调就行了。就算useEffect调用两次，也完全没有影响。结论上来说，如果你发现你的逻辑集成到React的时候有困难，你首先应该先整理好React以外的部分的逻辑。

为什么不用发布订阅模式；使用一个函数来管理分发socket消息；一个全局监听对象监听react组建注册删除和sokect消息分发；react组建挂载后向全局监听对象中注册一个或多个消息事件就行了，组建卸载删掉注册的监听事件，多方便；

<!-- - [React useEffect 的具体作用是什么？](https://www.zhihu.com/question/551894381/answer/2715660072) -->
[在前端开发过程中，你遇到过最复杂的状态管理场景是什么，并且是如何解决或者管理该场景下的状态的？](https://www.zhihu.com/question/295450089/answer/2813117503)
