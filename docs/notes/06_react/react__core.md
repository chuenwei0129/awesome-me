---
group:
  title: 道
title: 核心设计
toc: content
order: 1
---

## 单向渲染

为了解决 UI 和数据同步复杂性的问题，React 的先驱们决定另辟蹊径，寻找一种更加可预测、可依赖的前端 UI 实现方案。一个简单的想法出现了：**能不能用 JS 来构建 UI，在需要更新时，简单地全部更新就可以？**

单向渲染，或者更加本质地来说：

$ \text{f}(\text{state}) = \text{UI} $

这种方式简单易懂：React 就像是一个没有副作用的函数，忠实地根据输入的数据构建符合预期的 UI（在需要更新时，接收变更数据，重新执行函数，构建全新的 UI）。

视图（UI）可以表示为状态（state）通过某个函数（f）的映射。

其中：

- UI 是反映页面的 DOM 树
- f 是 React 的内部运行流程
- state 是状态的集合

从公式可以看出，每次 `state` 改变，整个 `React` 应用会执行一遍更新流程，将状态映射为视图。

## 虚拟 DOM

如果说单向渲染是 React 的内核，那么虚拟 DOM 就是能够让这个内核得以接地气的关键技术。**因为每次都采用完全更新的方式是不可接受的**，当前浏览器的性能并不足以在这种情况下提供可以容忍的使用体验。

React 先驱们通过在 JS 和 DOM 之间增加一个新的抽象表示层，从而在需要更新时，对比这一表示层的 diff，最终差量更新 DOM。这个抽象表示层就是虚拟 DOM。

举个例子，假设我们渲染如下 Component：

```js
const list = [
  { id: 1, text: 'Item 1' },
  { id: 2, text: 'Item 2' },
  { id: 3, text: 'Item 3' }
];

const SimpleList = ({ list }) => (
  <ul className="list">
    {
      list.map((item) => (
        <li key={item.id} className="list-item">{item.text}</li>
      ))
    }
  </ul>
);

export default () => <SimpleList list={list} />;
```

这些节点在 Virtual DOM 中的表示为：

```js
const element = {
  type: 'ul',
  props: { className: 'list' },
  children: [
    { type: 'li', props: { key: 1, className: 'list-item', children: ["Item 1"] } },
    { type: 'li', props: { key: 2, className: 'list-item', children: ["Item 2"] } },
    { type: 'li', props: { key: 3, className: 'list-item', children: ["Item 3"] } },
  ],
};
```

当有数据变化时，例如 list 变为了 `[ { id: 1, text: 'Item 1' } ]`，React 会执行如下三个步骤：

1. 接收到变更数据，整个 UI 被重新渲染为新的 Virtual DOM 表示。
2. 对比新旧 Virtual DOM 表示的区别，得到差量更新内容。React 称这一过程为调和（Reconciliation）过程。在这个例子中，差量更新的内容为：删除后面两个 li。
3. 对 DOM 应用上一步中计算的差量更新。

可以这样评价虚拟 DOM：正是这一技术使得 React 在保持单向渲染理念的同时，在性能上和 Data Binding 方案保持在同一水准。

然而这并不是 Virtual DOM 的全部价值，在增加这一抽象层之后，React 其实脱离了 DOM 这样单一的应用场景，它的解决问题的思路可以普世地应用在所有 UI 场景中。上述例子中，前面三个步骤中的前两个属于 React 核心部分，第三个步骤可以由特定的 Renderer 来完成。目前单就官方目前支持的就有 DOM Renderer（浏览器）、Server Renderer（服务器）、Native Renderer（iOS 和 Android）、ART Renderer（Canvas，SVG 或者 VML），以及测试使用的 Test Renderer。

## Fiber

### 为什么需要 Fiber

React 在每次收到数据更新之后，会进行一次调和过程并一次性更新 DOM，这在一般情况下不存在显著的性能瓶颈。但在一些需要 UI 快速响应的场景中（例如动画、手势等），当 DOM 的更新量较多或者 JS 逻辑较为复杂时，就会引起卡顿等有损体验的情况。

举个例子：

**假如更新一个组件需要 1 毫秒，如果有 200 个组件要更新，那就需要 200 毫秒。在这 200 毫秒的更新过程中，浏览器那个唯一的主线程都在专心运行更新操作，无暇去做任何其他的事情。**

想象一下，在这 200 毫秒内，用户往一个 input 元素中输入点什么，敲击键盘也不会获得响应，因为渲染输入按键结果也是浏览器主线程的工作。但是浏览器主线程被 React 占着呢，抽不出空，最后的结果就是用户敲了按键看不到反应，等 React 更新过程结束之后，按下的所有按键一下子出现在 input 元素里了。

**这就是所谓的界面卡顿，带来很不好的用户体验。**

如何解决这个问题呢？

我们可以将 React 更新看作一个任务，将 click 事件看作另一个任务。**在并发的情况下，React 更新到一半的时候，进来了 click 任务，这个时候先去执行 click 任务。等 click 任务执行完成后，接着继续执行剩余的 React 更新。** 这样就保证了即使在耗时更新的情况下，用户依旧可以进行交互。

如果我们把 React 的更新（如 200 ms）拆分成一个个小的更新（如 40 个 5 ms 的更新），然后每个小更新放到 [requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback) 中执行，那么就意味着这些小更新会在浏览器每一帧的空闲时间去执行。如果一帧里有多余时间就执行，没有多余时间就推到下一帧继续执行。这样的话，更新一直在继续，并且同时还能确保每一帧里的事件如 click，宏任务，微任务，渲染等能够正常执行，也就可以达到用户可交互的目的。

### Fiber 是什么

Fiber 的主要特性是支持增量渲染：能够将渲染工作分割为小块，并且将它们分散到多个帧中。

原调和过程会沿组件树递归遍历，遇到需要更新的情况时直接更新 DOM。由于 JS 和样式计算、布局以及许多情况下的绘制共享浏览器主线程，如果组件执行时间较长，就会导致一些需要快速响应的更新被阻塞，进而导致卡顿等有损用户体验的现象。

新的基于 Fiber 的调和过程将原来的递归遍历打散，可以每次只计算部分节点的更新内容后回到主逻辑查看是否有需要立即更新的高优先级内容，从而能够实现快速响应。

### 如何区分更新内容的优先级

既然总体更新操作是一定的，那么就需要根据响应速度的要求来划分优先级：

1. **动画或者用户手势：** 需要以最快速度进行响应，一般要在 16ms 左右才能保证 60 帧的平滑效果。
2. **点击、触摸：** 控制在 80~150ms 左右即可保证无迟滞感。
3. **网络请求：** 高延迟、被动触发的场景下，UI 更新可以适当排在后面。
4. **非视口范围内的元素：** 可以等待用户即将看到它们时再进行更新。

为了能够将原调和过程的递归调用打散，React 团队基于 Fiber 开发了一套新的调度（Scheduling）算法。其核心思路是：

1. 构建和组件树对应的 Fiber Tree，每个 fiber 节点保存更新信息，并增加 sibling 和 return 分别指向下一同级节点和父节点，以方便暂停遍历、恢复遍历、提交待更新内容等需求。
2. 在检查到更新时，并不立即更新到 DOM，而是分为调和和提交两个阶段，**调和阶段会收集待更新列表，可以被打断，而提交阶段会真正更新 DOM，这一阶段不可以被打断**。
3. 加入时间片的概念，在时间片用光时检查待更新列表，并将其通过 `requestAnimationFrame` 或者 `requestIdleCallback` 让浏览器在合适的时间点进行更新。支持抢占，有高优先级更新内容时会优先对其进行处理。

> Fiber 本质上可以认为是一个虚拟的堆栈帧（Stack Frame），它保留着每个组件实例的更新信息以及对其它 fiber 的指向。新的调度具备对它们的所有控制权，可以按照任意方式对它们进行调度，就像操作系统可以对应用程序随意进行调度一样。这为 React 的未来提供了更多可能性，例如在浏览器支持多线程渲染时，React 的调度可以同时为每个线程安排一些工作量，借助并行处理能力大幅提高渲染性能。

## 结语

1. React 是一个声明式 UI library，读入 data 和组件，处理后输出 UI。为了实现差量更新以降低 DOM 操作成本，React 引入了虚拟 DOM，让 UI 以一种”虚拟“的表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。

2. 单向数据流让 React 具备简单优雅的内核，Virtual DOM 使 React 得以落地生根，新近的 Fiber 令 React 适应越来越复杂严苛的应用场景，这三个设计上的闪光点应该可以解释 React 如此流行的原因。

## 拓展：[前端为何操作 DOM 会耗费大量性能？](https://www.zhihu.com/question/324992717)

JavaScript 引擎通常作为浏览器渲染引擎中的一个内置模块。然而，其独立性很强，甚至可以作为独立的引擎移植到其他环境中使用。

1. **原因一**: 浏览器的 JavaScript 引擎与渲染引擎共享同一个主线程。每次调用 DOM API 时，需要将 JavaScript 数据结构转换为 DOM 数据结构，暂停 JavaScript 引擎的运行，启动渲染引擎并执行操作，执行完毕后再将可能的返回值重新转换回 JavaScript 数据结构，然后重新启动 JavaScript 引擎继续执行。这种频繁的上下文切换会耗费大量性能。

2. **原因二**: 许多 DOM API 的读写操作需要重新计算页面布局以确保返回值的准确性，这通常涉及样式和结构的重新绘制，进一步增加了性能消耗。

单次 DOM API 调用的性能表现已经不尽如人意，频繁调用会迅速累积上述损耗，导致渲染引擎长时间占用主线程，用户操作不能及时触发 JavaScript 事件回调，进而让用户感觉卡顿。

因此，解决这一问题的关键不在于是否使用 jQuery 或虚拟 DOM，而在于**尽量减少不必要的 DOM API 调用**。

所有减少不必要调用的方法都遵循同样的基本思路：**在 JavaScript 中缓存必要的数据，计算界面更新时的阶段性数据差异，并且仅提交最终差异数据**。

**虚拟 DOM 核心在于计算最终 DOM 结构的差异**，而其他框架则可能计算 DOM 所绑定数据的差异。各有所长，各具特色。

## 拓展：JSX 是什么？为什么需要 JSX？

HTML 标签的书写方式与 JSON 的书写方式非常相似：**它们都是树形结构**。

DOM（文档对象模型）本身就是一种树形结构，这种结构对应我们的 HTML 标签。书写 HTML 其实并不复杂，因为所有东西都被抽象成了人类易于理解的标签，层级关系就像画图一样。

然而，用 JavaScript API（虚拟 DOM）直接书写 HTML 标签变得非常痛苦。因此，开发者瞄准了与 HTML 标签结构相似的 JSON 数据格式。由于 JSON 是 JavaScript 的原生对象，这让 **在 JavaScript 中声明式书写 HTML 成为了可能**。

然而，仅仅能书写 HTML 已无法满足现代开发需求。我们需要一种机制：

- **可以声明式书写 HTML**
- **可以在 JavaScript 中书写 HTML**
- **可以在小粒度上复用这些 HTML**

因此，通过 Babel 转换的 JSX 应运而生，**赋予了开发者使用 JavaScript 书写 HTML 的能力，同时又能够声明式地控制以及小粒度地复用这些 HTML 组件**。

## 拓展：单向数据流

**「单向数据流」是一条约定**，它规定了「当状态发生变化时，组件将受到影响，这种变化的影响只会从上往下传递」。这意味着数据像小溪一样，只能顺流而下，绝不会逆流而上！（很环保吧？）

来看看这个有趣的例子：

```js
function Parent() {
  const [num, setNum] = useState(0);
  return <Child data={num} />;
}

function Child({ data }) {
  const isEven = data % 2 === 0;
  return <GrandChild data={isEven} />;
}

function GrandChild({ data }) {
  return <p>{data.toString()}</p>;
}
```

在这个例子中：

- `<Parent />` 组件的状态 `num` 作为 `props` 传递给了 `<Child />` 组件，
- 然后再作为 `props` 传递给了 `<GrandChild />` 组件，
- 整个过程简直就是一场顺畅的数据接力赛，一路向下传递！

我们来用点想象力思考一下：如果数据流动可以逆转，那会是多么的混乱？想象一下小溪逆流而上，鱼儿们得练成倒泳才行！

不过，「单向数据流」并不是前端框架的铁律。**它的存在主要是为了减少开发者的心智负担**，让「状态变化后，计算影响范围」这个过程更可控。靠它，我们就不用熬夜喝十几杯咖啡去追踪代码了！🎉

总之，单向数据流好比是一位金牌管家，让我们的状态管理井井有条。用它来管理数据，你会节省大量的脑细胞，用更多的精力去享受生活吧！🍹

## 拓展：任务时长超过一帧怎么处理？

帧是画面的意思，浏览器页面就像视频一样，每一秒会绘制很多帧，**每一帧的耗时是不定的，可以是任意的时间**。

如果用户不操作页面，也没有什么定时任务，每一帧耗时大概 16 ms，也就是 60 fps。

```js
let lastTime = Date.now()
requestAnimationFrame(function cb() {
  console.log("这一帧耗时：", Date.now() - lastTime)
  lastTime = Date.now()
  requestAnimationFrame(cb)
})
```

如果有耗时的代码，比如：

```js
document.addEventListener("click", function () {
  var now = Date.now()
  requestAnimationFrame(() => console.log("这一帧持续了" + (Date.now() - now)))
  while (Date.now() < now + 1000)
})
```

那么这一帧耗时就会至少 1 秒钟，也就是 1 fps。**任务耗时的后果是让一帧耗时变长，帧率变低，任务不会被跳过。**
