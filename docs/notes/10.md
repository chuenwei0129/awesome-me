**为什么需要箭头函数？从函数的“二义性”说起**

在很多教程里，箭头函数常常被这样介绍：

- 不能当构造函数
- 没有 `prototype`
- `this` 是词法绑定
- 没有 `arguments`

然后给你几道练习题，让你去背这些差异。

但从一个“架构/设计”的视角看，箭头函数的出现不是为了多一种“好看点的写法”，而是为了缓解 JavaScript 里一个更底层的问题——**函数的二义性**。

这篇文章就从这个“二义性”讲起，解释为什么会有箭头函数、`class` 和它们背后的设计动机，并落到实际开发：**什么时候应该用箭头函数，什么时候必须用普通函数或 `class`**。

---

## 一、函数的两种角色：指令序列 vs 构造器

在支持面向对象的语言中，“函数”往往有两种不同的角色：

1. **指令序列（过程）**
   就是一段执行逻辑：先做 A，再做 B，把某件事完成。
2. **构造器（用来创建实例）**
   通过它可以 `new` 出对象，形成原型链，参与面向对象体系。

在 ES6 之前，JavaScript 里这两件事都是用同一种语法来表达的：`function`。

```js
// 普通函数：把逻辑执行一遍
function doSomething() {
  // ...很多行逻辑
}
doSomething();

// 构造函数：用来创建实例
function Person(name) {
  this.name = name;
}
const p = new Person('Alice');
```

从代码形式上看，这两种函数几乎长得一样。

结果是：**当你拿到一个函数 `A` 时，很难一眼看出它到底是“执行逻辑”还是“构造实例”。**

这就是所谓的**函数二义性**：

> 同一个语法实体（`function`），同时扮演“过程（procedure）”和“构造器（constructor）”两个不同角色。

---

## 二、命名规范只能缓解二义性，不能根治

为了缓解这个问题，社区里约定俗成了一些规范，比如：

- 构造函数用**首字母大写**：
  ```js
  function Person() { ... }
  const p = new Person();
  ```
- 普通函数用小写。

这确实能减轻一部分心智负担，但本质问题没解决：

- 这只是“软约定”，不是语言强约束，你完全可以写：
  ```js
  function person() {}
  new person(); // 可以正常 new，不报错
  ```
- 一些内建对象本身就同时支持“函数调用”和“构造调用”：

  ```js
  Number('1'); // 返回 number 1
  new Number('1'); // 返回 Number 对象

  Date(); // 返回时间字符串
  new Date(); // 返回 Date 实例
  ```

所以，**仅靠命名规范，并不能从语法层面真正消除函数的二义性**。

---

## 三、ES6 的“修补思路”：拆角色，而不是再补一堆规则

ES6 引入了非常多的新特性，其中有两个经常被单独讲的语法：

- `class`
- 箭头函数（`=>`）

表面上看，它们分别解决的是“更像传统语言的类语法”和“更简洁的函数写法”。

但从语言设计/架构角度看，它们有一个共同效果：

> **把原来都压在 `function` 一种语法上的“两种角色”，拆成两类更明确的实体：**
>
> - `class`：专职做“构造器 + 原型链”，不能随便当普通函数调用；
> - 箭头函数：专职做“指令序列/计算逻辑”，不能被 `new`，也没有 `prototype`。

这实质上是在**削弱传统 `function` 的二义性，让“谁负责构造，谁负责执行逻辑”变得更清晰**。

下面我们分别看这两块。

---

## 四、`class`：只能构造，不能直接调用

先看 `class`：

```js
class Person {
  constructor(name) {
    this.name = name;
  }
}

const p = new Person('Alice'); // ✅ 正常
Person('Alice'); // ❌ TypeError: Class constructor Person cannot be invoked without 'new'
```

几个关键信息：

- `class` 定义出来的构造器**只能用 `new` 调用**；
- 如果你试图把它当普通函数那样直接调用，会直接报错。

这在语义上做了一件很重要的事：

> 当你看到 `class`，你不用再猜“它是不是构造函数”。
> 它就是构造器，只能用 `new`，语言帮你做了强约束。

相比之前那种“写在 README 里的命名规范”，这种约束直接来自语法层面，可靠得多。

---

## 五、箭头函数：只能执行，不能构造

再看箭头函数：

```js
const add = (a, b) => a + b;

add(1, 2); // ✅ 正常调用，返回 3
new add(1, 2); // ❌ TypeError: add is not a constructor

console.log(add.prototype); // undefined
```

和普通函数相比，它有两个非常关键的差异：

1. **不能通过 `new` 调用**
   语言层面直接禁止了它作为构造器的可能性。
2. **没有 `prototype` 属性**
   所以也无法通过 `new` 建立基于它的原型链。

这背后的设计含义是：

> **箭头函数 = 明确告诉你“我只负责跑逻辑，不负责创建实例，也不参与原型链”**。

也就是说：

- 你看到箭头函数，就知道它只用于执行逻辑（过程）；
- 它不会负责 `new` 出对象，更不会挂实例方法。

这就和 `class` 合起来，形成了一个更清晰的分工：

- `class`：负责“类和实例”这套面向对象机制；
- 箭头函数：负责“指令序列/纯函数逻辑”。

---

## 六、`this` 的差异：动态绑定 vs 词法绑定

在日常开发中我们更常听到的是：

> “箭头函数的 `this` 是词法绑定；普通函数是动态绑定。”

这和上面的“角色划分”其实是配套的。

### 6.1 普通函数：`this` 由调用方式决定（动态绑定）

```js
function f() {
  console.log(this);
}

f(); // 非严格模式下 this 为全局对象；严格模式为 undefined
obj.f(); // this === obj
f.call(other); // this === other
new f(); // this 为新创建的实例
```

普通函数可以用在很多位置：普通调用、对象方法、构造器……
`this` 就随着调用方式而变化。

### 6.2 箭头函数：没有自己的 `this`，沿用外层（词法绑定）

```js
const obj = {
  value: 42,
  foo() {
    setTimeout(function () {
      console.log(this.value); // 常见情况下：undefined（取决于运行环境）
    }, 0);

    setTimeout(() => {
      console.log(this.value); // 42，this 来自 foo 调用时的 this
    }, 0);
  },
};

obj.foo();
```

箭头函数的规则是：

- 它**没有自己的 `this` 绑定**，不会因为怎么调用而改变；
- 它直接“闭包”了**定义时外层函数/环境中的 `this`**。

这在“需要在回调里使用当前实例”的场景极其好用，比如：

- 定时器回调
- Promise 回调
- 数组的 `map` / `filter` / `forEach` 等

从设计角度看，这也是一种“职责分离”：

- 需要扮演“方法”“构造器”等角色，依赖 `this` 的地方，用普通函数或 `class` 方法；
- 只需要“跟随外层 `this`”的回调/工具函数，用箭头函数更省心。

---

## 七、其它差异：`arguments`、`new.target` 等

为了让你在工程里用得更稳，这里把几个常见差异列出来。

### 7.1 `arguments`

- 普通函数：有 `arguments` 对象，可以拿到所有实参：
  ```js
  function fn() {
    console.log(arguments);
  }
  fn(1, 2, 3); // [1, 2, 3, ...]
  ```
- 箭头函数：**没有 `arguments`**，需要用剩余参数：
  ```js
  const fn = (...args) => {
    console.log(args);
  };
  ```

### 7.2 `new.target`

- 普通函数：可以通过 `new.target` 判断是否是用 `new` 调用：

  ```js
  function Fn() {
    if (!new.target) {
      throw new Error('请使用 new 调用 Fn');
    }
  }

  new Fn(); // 正常
  Fn(); // 抛错
  ```

- 箭头函数：没有 `new.target`，本身也不能被 `new`。

### 7.3 语法简洁性（隐式返回等）

箭头函数还有一大优势是**语法简洁**，尤其是配合数组方法、回调：

```js
// 单表达式函数可以省略 return 和花括号
const square = (x) => x * x;

// 在数组处理里非常自然
const names = users.map((user) => user.name);
```

---

## 八、实战中如何选择：一些可落地的经验法则

到这里，你已经知道：

- `class` 和箭头函数一起，把“构造器”和“指令序列”的角色拆开了；
- 普通函数和箭头函数在 `this`、`prototype` 等方面有明显差异。

接下来就是工程落地层面的问题：**什么时候用哪个？**

### 8.1 适合用箭头函数的场景

1. **回调中需要沿用外层 `this`**

   典型场景：

   - 定时器、事件回调
   - Promise 链
   - 数组高阶函数（`map` / `filter` / `reduce` 等）

   ```js
   class Counter {
     constructor() {
       this.count = 0;
     }

     start() {
       setInterval(() => {
         this.count++;
         console.log(this.count); // this 始终指向当前实例
       }, 1000);
     }
   }
   ```

2. **纯函数工具、小而专一的逻辑**

   ```js
   const double = (x) => x * 2;
   const pluckNames = (arr) => arr.map((item) => item.name);
   ```

   这类函数不依赖 `this`，只关心输入输出，用箭头函数更简洁。

### 8.2 不适合用箭头函数的场景

1. **构造函数**

   任何需要通过 `new` 调用的，都必须使用 `function` 或 `class`：

   ```js
   // 推荐：使用 class
   class Person {
     constructor(name) {
       this.name = name;
     }
   }

   // 或传统构造函数
   function Person(name) {
     this.name = name;
   }
   ```

2. **需要挂在原型上的方法**

   原型方法通常依赖实例 `this`，不能用箭头函数：

   ```js
   function Person(name) {
     this.name = name;
   }

   Person.prototype.sayHi = function () {
     console.log(this.name); // this 指向实例
   };
   ```

   如果写成箭头函数：

   ```js
   Person.prototype.sayHi = () => {
     console.log(this.name); // this 来自定义时的外层，不是实例
   };
   ```

   这里的 `this` 很可能不是你期望的那个。

3. **希望 `this` 随调用者变化的对象方法**

   ```js
   const obj = {
     value: 1,
     // 推荐：普通方法写法
     inc() {
       this.value++;
     },
   };

   const other = { value: 10, inc: obj.inc };
   other.inc(); // this === other，value 变成 11
   ```

   如果把 `inc` 写成箭头函数，它的 `this` 会永久绑定到定义时的环境，而不是调用者，这通常不是你想要的行为。

---

## 九、小结：抓住本质，细节就变得“理所当然”

如果你只从语法特性去记箭头函数和普通函数的区别，你会得到一长串规则：

- 箭头函数不能 `new`
- 没有 `prototype`
- 没有自己的 `this`，而是词法绑定
- 没有 `arguments`
- 没有 `new.target`
- ……

这些都没错，但很零散，也很容易忘。

从“语言架构”的视角看，可以把整个图景压缩成一句话：

> **ES6 通过 `class` 和箭头函数，对传统 `function` 的双重角色做了拆分：**
>
> - `class`：只负责“构造器 + 原型链”，
> - 箭头函数：只负责“指令序列/计算逻辑”，
>   由此减轻了函数的“二义性”。

当你理解了这层本质之后，再看所有现象：

- 为什么 `class` 只能 `new` 不能直接调用？
- 为什么箭头函数不能 `new`、没有 `prototype`？
- 为什么箭头函数的 `this` 要词法绑定？
- 为什么箭头函数不适合作构造函数或原型方法？

都会变得“很自然、很好推理”，而不是一堆需要死记硬背的规定。
