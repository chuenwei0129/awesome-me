---
group:
  title: browser
  order: 7
title: 解码浏览器事件
toc: content
---

## 一次点击背后的隐形剧场

大多数人第一次接触浏览器事件，是在某行极其朴素的代码里：

```js
button.addEventListener('click', handler);
```

点击、执行、打印，一切看起来再简单不过。于是我们很容易以为，这只是"点一下，就跑一个函数"的机械关系。

但如果把界面真正当成一个活着的系统，你就会发现，这一行代码更像是在一个巨大而复杂的建筑里，装上一部电话：**谁能打得通、什么时候会响、响几次、响到谁手上、能不能中途挂断**，都不是这一行字面上那么简单，而是藏在一整套规则之中。

`addEventListener` 只是一道入口，真正有趣的是它背后那条完整的"**事件旅程**"。用户拇指落在屏幕上的那一瞬间，浏览器内部已经悄无声息地搭起了一条从外到内，再从内到外的信号通道，而每一个监听器，都只是这条通道某一站台上的一部电话。

如果你只把 `addEventListener` 当成"监听一下"的工具，你会下意识在看到问题时随手多绑一个监听器，再多绑一个，再多绑一个。它们一开始确实解决问题，但渐渐地，系统变得难以理解：**事件从哪来、往哪去、在哪被拦截、在哪被改写**，谁也说不清。

**真正的分界线在于**：你是只会"挂电话"，还是能看见整个"电话网络"的结构。

这一切的起点，正是那三个看似普通的参数。

---

## 三根线拉开帷幕：从"会用"到"用对"的关键

`addEventListener` 的三根参数线，本质上决定了你在这场事件旅程中的**权力边界**。

**第一根线，是 `type`。**
它不是一个随便填的字符串，而是你用一句话宣布"刚刚发生了什么"。一次点击是 `'click'`，键盘按下是 `'keydown'`，输入变动是 `'input'` 或 `'change'`，页面滚动是 `'scroll'`。这些词并不只是"名字"，而是浏览器事件宇宙里的"**列车类型**"：你选择了哪一种，就上了哪一班车。

**第二根线，是 `listener`。**
这才是真正接电话的那只手。每当事件经过你挂电话的那一站，浏览器会唤醒这只手，并递给它一张叫做 `event` 的记录单——这张单子写着：**谁发起的、坐标在哪、走到哪一阶段了、默认行为是否已经被阻止**。这意味着，你的监听函数从来不是在黑箱里工作，它握着足够多的上下文信息，随时可以做出有针对性的决定。

**第三根线，是最容易被忽略、却决定几乎所有细节的 `options`。**
它表面上只是一个布尔值或配置对象，实质上是在声明你想占据怎样的位置、行使怎样的权力：

当它是布尔值时，你只回答一个问题：
**"这部电话，是接在事件从外往里走的路上（捕获），还是从里往外走的路上（冒泡）？"**

```js
// 捕获阶段监听
div.addEventListener('click', handler, true);

// 冒泡阶段监听（默认）
div.addEventListener('click', handler, false);
// 或者省略第三个参数
div.addEventListener('click', handler);
```

当它变成一个对象时，你开始进行更精细的自我定位：

- `capture` 告诉浏览器：我在哪一段旅程插手。
- `once` 告诉浏览器：这部电话是一次性的，响完就拆。
- `passive` 则更微妙一些：你是在作出一个承诺——"我不会阻止默认行为"，或者相反，"我有可能要拦截，请等我说完"。

```js
// 精细控制的事件监听
div.addEventListener('click', handler, {
  capture: true, // 在捕获阶段触发
  once: true, // 只触发一次
  passive: false, // 可能调用 preventDefault()
});
```

很多人以为"会写第三个参数"只是进阶技巧，其实不然。
**真正的分水岭是**：当你开始认真对待这第三个参数时，`addEventListener` 才真正从"凑合能用"变成"**精确可控**"。

---

## 从外到内再到外：事件如何穿过一棵树

要理解捕获（capture）和冒泡（bubble），先要承认一个常被忽视的事实：
**就算你从不写 `addEventListener`，事件的旅程也照样在走。**

当你点击一个元素，浏览器会做两件事。

**第一件，是从"宇宙顶层"一路往下查找**：到底是谁被点中了。
从 `window` 到 `document`，再到 `html`、`body`，一路走进一个个嵌套的节点，直到抵达那个真正被点中的目标元素。这就是**捕获阶段**——就像一支侦察队，从城市边界一路摸排，最终确认"是这栋楼的这间房间发生了什么"。

**第二件，是走反向的路**：从目标元素开始，一层层往外通知："刚才发生了这个事件，你要不要管一管？"
这就是**冒泡阶段**——事件从目标元素出发，经过它的父节点、祖先节点，一直回到 `body`、`html`、`document`、`window`。此时侦察队已经知道问题在哪，现在开始逐级上报，让每一层都可以做出自己的反应。

**重要的在于**：
这两段旅程并不依赖于你是否监听。事件本身就在流动，你只是在某些节点上摆了一部电话。当事件经过这里时，如果有电话，就会响；如果没有，它只是悄无声息地路过。

默认情况下，写下：

```js
div.addEventListener('click', handler);
```

其实是在说："**只在冒泡阶段接电话**"。
也就是说，当某个内层元素被点中，事件先由外到内完成捕获，抵达目标，再从里往外冒泡。当它经过这个外层 `div` 时，你的监听器被调用一次。

而当你改成：

```js
div.addEventListener('click', handler, { capture: true });
```

你就把监听器接到了**捕获阶段**——那意味着，事件还在往内走、目标元素还没"意识到自己被点了"的时候，你就已经先一步出手。

如果把前面那种事件顺序打印出来，你会看到一种极其有秩序的节奏：

```html
<div id="outer">
  <div id="inner">点击我</div>
</div>

<script>
  const outer = document.getElementById('outer');
  const inner = document.getElementById('inner');

  // 捕获阶段监听
  outer.addEventListener(
    'click',
    (e) => {
      console.log('外层捕获');
    },
    true,
  );

  inner.addEventListener(
    'click',
    (e) => {
      console.log('内层捕获');
    },
    true,
  );

  // 冒泡阶段监听
  outer.addEventListener('click', (e) => {
    console.log('外层冒泡');
  });

  inner.addEventListener('click', (e) => {
    console.log('内层冒泡');
  });
</script>
```

点击内层元素时，控制台输出：

```
外层捕获
内层捕获
内层冒泡
外层冒泡
```

**捕获，从外到内；冒泡，从内到外；目标元素，在两者中间短暂闪过。**

这里还有一个常被忽略的细节：在同一个阶段、同一个节点上，多次调用 `addEventListener`，浏览器会遵循"**先注册先执行**"的顺序。这说明在每个节点内部，也有一条属于这个节点自己的监听队列。事件每到一站，就沿着这条队列，从头执行到尾。

当你开始把"事件旅程"看成一条从根到叶、再从叶到根的路径时，节点不再只是孤立的方块，而是一棵**有方向、有节奏的树**。你可以选择在任何一段路上插一部电话，也可以决定在哪一站把事件彻底拦截。

---

## 那张快递单：`event` 不是参数，是权力清单

每次电话响起，浏览器都会把一份事件对象塞进监听器里。这份 `event`，更像是一张随着旅程流转的**快递单**，上面写着这趟行程的全部上下文。

其中最容易让人混淆的，是 `target` 和 `currentTarget`。

**`event.target` 永远指向事件真正发生的那一个元素**，是这次旅程的发货地址。你点在按钮上，它就是按钮；你点在输入框里，它就是输入框。只要是同一次事件，`target` 就不会改变，无论事件此刻处于捕获、目标还是冒泡阶段。

**`event.currentTarget` 则是当前这一次监听回调对应的元素。**
同一条事件会经过多个节点，每到一个挂着监听器的节点，浏览器就把 `currentTarget` 改成这个节点，然后调用你当初挂在这里的那段函数。

```html
<div id="parent">
  <button id="child">点击我</button>
</div>

<script>
  const parent = document.getElementById('parent');
  const child = document.getElementById('child');

  parent.addEventListener('click', function (e) {
    console.log('target:', e.target.id); // 永远是 child
    console.log('currentTarget:', e.currentTarget.id); // 当前是 parent
  });

  child.addEventListener('click', function (e) {
    console.log('target:', e.target.id); // 永远是 child
    console.log('currentTarget:', e.currentTarget.id); // 当前是 child
  });
</script>
```

于是，同一条事件，在不同监听器里看到的 `currentTarget` 完全可能不同，而它们看到的 `target` 却始终一致：
**源头不变，站点轮换。**

这张快递单上还有更多细节：坐标（`clientX`、`clientY` 或 `pageX`、`pageY`）、时间戳（`timeStamp`）、键盘按键信息（`key`、`code`）、当前处于捕获还是冒泡阶段（`eventPhase`）……这些信息让你不必猜测，而是可以根据当下语境做精确判断。

更有趣的是，这张单子并不是只读的。
它提供了几种**极具权力色彩的方法**，让你在旅途的任意站点，改变后续的命运。

**`event.stopPropagation()`** 会在当前监听器执行结束后，阻止事件继续流向下一个节点。你既可以在捕获阶段用它阻止事件到达目标，也可以在冒泡阶段把它截停在某个父级之内。

```js
// 阻止事件继续传播
child.addEventListener('click', (e) => {
  e.stopPropagation();
  console.log('事件在这里停止，不会传到父级');
});
```

**`event.stopImmediatePropagation()`** 更加决绝。它不仅阻止事件继续去往下一个节点，还会阻止当前节点上后续的监听器执行——就像在这一站直接拉闸，后面的监听电话根本来不及响。

```js
// 阻止当前节点后续的所有监听器
child.addEventListener('click', (e) => {
  e.stopImmediatePropagation();
  console.log('只有这个监听器会执行');
});

child.addEventListener('click', (e) => {
  console.log('这个监听器永远不会执行');
});
```

而 **`event.preventDefault()`** 则是另一种截断。
很多事件背后都挂着默认行为：点击链接会跳转，点击提交按钮会提交表单，滚动事件会带动文档滚动。调用 `preventDefault()`，就是对浏览器说："这一次，请不要按惯例行事，由我来接管。"

```js
// 阻止默认行为
link.addEventListener('click', (e) => {
  e.preventDefault();
  console.log('链接不会跳转，由我处理');
});
```

不过，这个权力与第三个参数紧密相连。如果你在一个被标记为 `{ passive: true }` 的监听器里调用 `preventDefault()`，浏览器有权无视你，因为你事先已经做出了承诺："我不会阻止默认行为。"

**`event` 不是可有可无的参数，而是你在这条旅程中可以阅读与行使的权力清单。** 你读得越仔细，就越有能力掌控事件的命运。

---

## 只响一次、永不阻挡：当意图写进配置之中

现实中的交互，有一些从一开始就是**一次性的**。
比如新手引导里的"我知道了"，再比如首次加载时只需展示一次的提示。这类场景用完即走，没有必要在内存里留下长久的监听器。

传统做法，是在监听函数里手写一行 `removeEventListener`。
这确实能工作，但有一种"先多绑，再补救"的意味——明明一开始就知道它只会用一次，却要等到第一次调用结束，才仓促把它拆掉。

**`once` 让意图直接成为配置的一部分**：

```js
button.addEventListener('click', handler, { once: true });
```

这句话的真实意思是："**这部电话只响一次，响完就拆。**"
浏览器在第一次触发时正常调用 `handler`，然后自动把这条监听从队列里删掉。你不再需要在回调中费心清理，代码看起来也更接近真实心智。

如果说 `once` 处理的是"**次数**"维度，那么 `passive` 处理的，就是"**承诺**"维度。

在 `touchmove`、`wheel`、`scroll` 这些与滚动紧密相关的事件上，浏览器长期处在一种尴尬处境：
它不知道你会不会在监听器中阻止默认滚动。
如果不能确定，它就必须停下来，等你把监听器跑完，检查你有没有调用 `preventDefault()`，再决定到底滚不滚。这种等待，在移动设备上往往直接表现为滚动延迟、页面不跟手。

当你写下：

```js
element.addEventListener('touchmove', handler, { passive: true });
```

你给出的不是一个"性能优化选项"，而是一个非常具体的承诺："**在这个监听器里，我不会调用 `preventDefault()`。**"

得到这个承诺之后，浏览器就不用再战战兢兢地等你表态，而可以一边流畅地处理滚动，一边异步执行你的处理逻辑，交互的顺滑感就从这里生出来。

相反，如果你确实打算阻止默认滚动，比如实现一个自定义的滑动组件，就不能标记为 passive。有些现代浏览器甚至出于性能考虑，会默认把某些滚动监听当成被动监听。这时，如果你希望 `preventDefault()` 真正生效，就必须主动写出 `{ passive: false }`，明确表示："**这一次，我要保留拦截权。**"

```js
// 明确声明需要阻止默认行为
element.addEventListener(
  'wheel',
  (e) => {
    e.preventDefault(); // 这会生效
    console.log('自定义滚动处理');
  },
  { passive: false },
);
```

很多"为什么我明明写了 `preventDefault()` 页面还在滚"的疑惑，本质上都不是语法问题，而是一个**没被说清的承诺问题**。

于是，在 `capture`、`once`、`passive` 这三个维度上，你分别回答了三个问题：
**我要在旅程的哪一段插手？**
**要插手多少次？**
**插手的时候，是观众，还是可能改写默认命运的裁判？**

当这些意图写进配置中，事件监听不再是零星的补丁，而是一种**清晰而可控的契约**。

---

## 一只监听接住一片区域：事件委托的空间魔术

了解了冒泡，很难不生出这样的念头：既然事件最终会冒到父级去，我是不是可以只在外层挂一次监听，用它接住整片区域的点击？

这正是**事件委托**的核心。

想象一个长长的待办事项列表，每一行都有一个"删除"按钮。如果你在每个按钮上都单独挂一个监听器，当列表有一百项时，就有一百个监听器；当列表不断增减时，你还得同步增减这些监听器。浏览器可以撑住，但你的代码会越来越像一张缠绕的网。

通过事件委托，你可以只在列表容器上挂一次 `click`，然后在回调里根据 `event.target` 判断，这次点击落在了哪一个子元素上，再做相应处理。
利用 `closest` 这样的 API，可以快速从点击源头找到负责真正动作的那个按钮。

```html
<ul id="todo-list">
  <li>
    任务1
    <button class="delete-btn" data-id="1">删除</button>
  </li>
  <li>
    任务2
    <button class="delete-btn" data-id="2">删除</button>
  </li>
</ul>

<script>
  const todoList = document.getElementById('todo-list');

  // 事件委托：一个监听器处理所有删除按钮
  todoList.addEventListener('click', (e) => {
    // 检查点击的是否是删除按钮
    const deleteBtn = e.target.closest('.delete-btn');
    if (deleteBtn) {
      const taskId = deleteBtn.dataset.id;
      console.log(`删除任务 ${taskId}`);
      // 实际处理删除逻辑
    }
  });
</script>
```

效果是显而易见的：**监听器数量与列表长度脱钩**，新增和删除项无需额外的绑定与解绑，只要结构满足约定，就自然被纳入统一的处理。

不过，委托并不是无条件成立，它有一个先决条件：**事件必须会冒泡**。
`click`、`keydown`、`input` 等事件天然会从内向外传播，极适合用委托；而 `focus`、`blur`、`mouseenter`、`mouseleave` 这类事件默认不冒泡，想要统一处理，就得借助它们的"兄弟事件"——例如 `focusin`、`focusout`，或者改用 `mouseover` / `mouseout` 配合额外判断。

```js
// 对于不冒泡的事件，使用替代方案
form.addEventListener('focusin', (e) => {
  console.log('某个表单元素获得焦点:', e.target);
});
```

如果说 `once` 和 `passive` 解决的是"**时间维度**"的控制，那事件委托解决的，就是"**空间维度**"的复杂度。你不再在无数个细小节点上重复挂监听，而是把逻辑收敛在少数几个关键关口，让事件流在 DOM 树上的路径变得简洁而可预测。

在大型应用里，这种收敛带来的性能红利是一方面，更重要的是**结构上的清晰**：你可以一眼看出哪些节点是"观察者"，哪些节点只是"信号的起点"。

---

## 始于绑定，终于生命周期：别让监听器变成幽灵

当你开始大量监听，尤其是在 `window`、`document` 或长期存在的容器上挂监听时，一个更隐蔽的问题随之而来：这些监听器，会活到什么时候？

在传统的页面模型里，我们习惯于"刷新一切重置"，好像生命周期问题不值一提。但在单页应用和长时间运行的管理后台里，刷新已经不再频繁出现，组件不断创建与销毁，如果监听器不随着它们的逻辑一同离场，就会留下大批"**幽灵监听器**"：看不见、摸不着，却仍然可能在某一刻被触发。

**`removeEventListener` 是你与这些监听器告别的正式仪式。**

不过，真正棘手的是：**只有你握着当初传入的那一个函数引用，才能把它解下来。** 如果当初随手绑上了一个匿名函数，那之后几乎没有机会精确地把它移除。你可以写出一段看起来一模一样的函数交给 `removeEventListener`，但浏览器只认引用，不认"长得像"。

```js
// 错误：无法移除匿名函数
button.addEventListener('click', () => {
  console.log('点击');
});

// 这样是移除不掉的！
button.removeEventListener('click', () => {
  console.log('点击');
});

// 正确：使用具名函数引用
function handleClick() {
  console.log('点击');
}

button.addEventListener('click', handleClick);
// 之后可以精确移除
button.removeEventListener('click', handleClick);
```

这也是为什么，成熟的代码往往会把监听函数保存成具名函数、对象属性或类的实例方法，在合适的生命周期里统一解绑。尤其是绑在 `window` 上的监听，就算逻辑再简单，也值得你认真考虑"何时结束"。

在这方面，**`AbortController` 提供了一种更优雅的解法。**
你可以把一组相关监听挂在同一个 `signal` 上，然后在某个时刻调用一个 `abort()`，就让这一整组监听同时退出舞台——不再逐一调用 `removeEventListener`，不用担心忘掉某一处，也不用在代码各处塞满清理逻辑。

```js
// 使用 AbortController 管理一组监听器
const controller = new AbortController();
const { signal } = controller;

// 绑定多个监听器，共用同一个 signal
button.addEventListener('click', handleClick, { signal });
input.addEventListener('input', handleInput, { signal });
window.addEventListener('resize', handleResize, { signal });

// 在需要的时候，一次性取消所有监听
controller.abort(); // 所有通过这个 signal 注册的监听器都会被移除
```

从这个角度看，`once: true` 其实也是一种内建的生命周期管理：
它把"**执行一次就解绑**"这件事，从监听函数内部抽离出来，变成配置上的事实。这不会改变功能，却极大改变代码的叙事方式——你不再显得像是在"事后补救"，而是从一开始就把生命周期说清楚。

当你开始自觉地为监听器设定出生与死亡的时刻，它们就不再是到处乱跑的游魂，而是有着**严格边界的演员**。事件系统，也因此从一堆回调的拼凑，变成了一部有完整生命周期的剧场。

---

## "事件流思维"：从局部监听走向全局编排

把前面的所有拼图拼在一起，会浮现出一个更高层的视角，可以叫它"**事件流思维**"。

在这种思维里，每一次用户操作，不再是孤立的"点了一下""按了一下"，而是一条**从源头出发、沿着固定路径传播、在多个站点被观察和可能被改写的信号**。

你再写 `addEventListener` 时，不会只盯着那一个按钮，而会先问自己几件事。

**首先，这次事件真正的源头是谁？**
是某个具体的 DOM 节点，还是某种抽象的"流程状态"？它有没有可能迁移到别的节点上？如果源头可以变化，那么监听是否也应该迁移，抑或用自定义事件把这种变化抽象出来？

```js
// 自定义事件，用于模块间通信
const taskCompletedEvent = new CustomEvent('taskcompleted', {
  detail: { taskId: 123, result: 'success' },
  bubbles: true,
});

// 触发自定义事件
document.dispatchEvent(taskCompletedEvent);

// 在其他模块监听
document.addEventListener('taskcompleted', (e) => {
  console.log('任务完成:', e.detail.taskId);
});
```

**其次，这条事件会经过哪些必要的中转？**
是不是可以用事件委托，把密密麻麻的小监听收敛到少数几个关键节点？在捕获阶段和冒泡阶段，分别应该承担什么角色？有没有哪一层更适合成为"安全阀"，在必要时阻止事件继续扩散？

```js
// 在文档层面设置安全阀
document.addEventListener(
  'click',
  (e) => {
    // 检查是否是应该被阻止的点击
    if (e.target.closest('.prevent-all')) {
      e.stopPropagation();
      console.log('阻止所有点击事件继续传播');
    }
  },
  true,
); // 在捕获阶段就拦截
```

**再次，在每一个监听器里，你到底想行使哪些权力？**
只是读一读 `event`，做一些观测和埋点，还是要通过 `preventDefault` 和 `stopPropagation` 修改这次事件的命运？这段逻辑是一次性的，还是常驻的？是否应该用 `once` 或 `AbortController` 明确它的生命周期？如果涉及滚动和触摸，是否需要通过 `passive` 主动与浏览器达成性能契约？

当你用这样的方式思考时，`addEventListener` 就从一个"会背的 API"，变成了一种**行为编排语言**。浏览器内建的事件（例如 `click`、`input`、`scroll`、`resize`）只是一部分，你也可以通过 `CustomEvent` 设计自己的"词汇"：
比如，当结算完成时抛出 `checkout:finished`，在加载结束时抛出某个业务事件，让其他模块通过监听这些事件来响应。此时，事件不再只是"用户和界面"的沟通方式，更是"**模块和模块**"的沟通渠道。

再往前，你会看见 Pointer Events（指针事件）试图统一鼠标、触控与手写笔；看见一些不会冒泡的事件如何通过捕获或专用替代事件融入统一的管理体系；看见浏览器如何在可取消、可冒泡、带 `detail` 的事件之间提供一条完整光谱。

所有这些，最终都回到一个问题：
**你不再只关心"在这里监听点什么"，而是开始设计"整个系统里，事件如何被看见、被传递、被接住、被转译"。**

这就是事件流思维的真正含义：**从孤立回调的世界，走向行为编排的世界。**

---

## 当你再写下一行 `addEventListener`

也许在读完这些之后，你回到项目里，再次写下那一行熟悉的代码：

```js
element.addEventListener('click', handler);
```

手指会自然地停顿半秒。

你会意识到，自己默认接入的是**冒泡阶段**；会意识到，如果这是一个长期存在的监听，它未来需要一个**明确的终点**；会意识到，若此处顺手写了匿名函数，等你想解绑时，很可能已经失去了把它请下舞台的能力。

如果这段监听和滚动、手势相关，你会本能地思考：是否该声明 `passive: true`，换取更流畅的体验？
如果它只需响应一次，你会更坦率地写上 `{ once: true }`，而不是再在回调里补上一行 `removeEventListener`。

当你在一个列表里处理点击，你会第一时间想到**事件委托**，而不是在每一个子元素上重复挂监听；当你在一个组件里绑定多个全局监听时，会自然地用 `AbortController` 或清晰的生命周期钩子为它们划定边界。

那一刻你会发现，自己已经不再是那个"看到问题就随手多绑一个事件试试"的人，而是一个真正能够**从整体上编排行为**的人。

浏览器的事件系统从来不神秘，它始终遵循着一套**稳定、清晰、可推理的规则**。

`addEventListener` 也从来不只是"监听一下"那么简单。
它是一份**邀请**——邀请你走进一个由事件流构成的世界，在那里，你不只是被动响应一次次点击，而是主动设计整条旅程的节奏、路径与结局。

当这份邀请真正被接住，你写下的每一个监听，都将不再只是"加上一行代码"，而是对整个系统行为的**一次有意识编排**。
