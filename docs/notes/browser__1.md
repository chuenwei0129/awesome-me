# 当 JavaScript 不再直线执行：宏任务、微任务与事件循环的隐秘秩序

## 一段看似“顺序”的代码，为何结果总在意料之外？

很多人第一次写异步 JavaScript 的时候，都经历过同一个瞬间：明明代码一行一行写下来，明明 `console.log` 的位置清清楚楚，但真正跑起来，输出顺序却像被人悄悄打乱了一样。

你怀疑过浏览器有 bug，怀疑过自己的眼睛，最后只好耸耸肩，把这一切归结为一句含糊的说法——“这是异步的嘛”。

可“异步”三个字，如果只是用来终结讨论，而不是开启理解，那它带来的更多是无力感，而不是掌控感。

要真正理解 JavaScript 的运行时，就必须承认一个事实：你写在编辑器里的那段代码，只是你看到的样子；在引擎眼中，它的存在方式完全不同。引擎不会“从上到下”这么简单粗暴地看待代码，它依赖的是一套关于“任务”（task）的秩序。

今天，我们就从这套秩序的两个关键角色讲起：macro task（宏任务）与 micro task（微任务），再走向 event loop（事件循环）。一旦你理解了它们，你就会发现，之前那些看似诡异的执行顺序，其实都有迹可循。

## 宏任务：引擎眼中那“一块一块的世界”

在 JavaScript 引擎的内部世界里，有一个经常被忽略的前提：引擎并不是自己“长出”代码的，它只是一个被动执行者。真正掌控节奏的，是外面的宿主环境——浏览器、Node.js 进程，或者一个嵌入了 JS 引擎的原生应用。

当宿主把一段字符串形式的代码交给引擎，让它去执行的时候，引擎看到的是一块完整的“执行单元”。在异步模型里，这一块，就被称为一个 macro task（宏任务）。

在这个角度下，“运行一段代码”其实可以被理解为：宿主环境构造了一个宏任务，把它排进队列，然后交给 JavaScript 引擎执行。比如：

- 浏览器解析到一个 `<script>` 标签，构造出一个宏任务，把这段脚本作为任务内容塞给引擎；
- 用户在控制台输入一行 JavaScript，按下回车，这个输入同样会成为一个宏任务；
- 在原生应用中，通过 JavaScriptCore（JSC，引擎）创建一个 JSContext（JavaScript 上下文），调用 `evaluateScript` 传入一整段脚本，这次调用，在引擎看来，也就是一个宏任务的生命周期。

在这个宏任务内部，引擎会按照它自己的规则，对代码分层地进行表示：

- 最外层是这个宏任务整体；
- 它内部由一个个函数调用构成；
- 函数内部，是语句（statement）与声明；
- 再往下，是表达式（expression）和直接量。

这是一棵从“整段代码”一路向下拆解的树。你在编辑器里看到的是源代码的文本形态，引擎看到的是抽象语法树（AST），以及围绕它构建的执行结构。

但有趣的地方在于：宏任务并不是执行的最小粒度。真正控制“下一步什么时候跑”的，是另一种更细腻的任务形态——micro task（微任务）。

## 微任务：Promise 编织出的时间暗流

如果说宏任务定义了“这一大块代码什么时候被安排执行”，那么 micro task（微任务）则决定了“在这块执行的间隙中，哪些细小的异步逻辑要优先被兑现”。

在 JavaScript 的标准模型里，微任务的核心来源是 Promise。每一次 `promise.then(...)`，标准都会要求：`then` 里的回调，不得与当前代码同步执行，而是被安排成一个稍后执行的 job（作业），进入 micro task 队列。

想象这样一段代码（只看逻辑，不必拘泥于语法细节）：

```js
let x = 1;
const p = new Promise((resolve) => {
  resolve();
});

p.then(() => {
  x = 2;
});

x = 3;
```

我们肉眼看到的顺序，似乎是：

1. `x = 1`;
2. 创建 `Promise` 并立即 `resolve`;
3. `p.then(...)` 里的回调被注册；
4. `x = 3`.

很多初学者会直觉地以为：既然 Promise 立刻被 resolve 了，那 `then` 的回调是不是也立刻执行？如果是，那 `x` 最终应该为 2；如果不是，那它什么时候执行？

标准给出的答案非常明确：`then` 的回调必须异步执行，作为一个微任务，被推入 micro task 队列中。当前宏任务里的同步代码——包括 `x = 3`——要先走完，才轮到这些微任务。

于是，这段代码的真实节奏变成了：

- 宏任务开始执行，依次运行 `x = 1`、创建 `Promise`、注册 `then` 回调、执行 `x = 3`；
- 当前宏任务的同步部分结束，开始清空 micro task 队列；
- 前面因为 `resolve` 而入队的 micro task 被执行，`x` 在此时被改写成 2。

这就是为何在一些示例里，当你在原生应用中把整段脚本丢给引擎执行，最后在宿主环境中打印 `x` 的值时，会看到 `3` 或 `2`，取决于你选择在什么时刻去观察它：

- 如果你在宏任务刚结束时观察，有可能看到的是“同步代码跑完时”的状态；
- 如果宿主在底层封装里，已经在 `evaluateScript` 的调用中执行了整个微任务清空过程，那么你看到的就是所有 micro task 都执行之后的最终值。

从引擎的视角来看：那一段被塞进来的代码，结果上被分裂成了两个微任务——一块是“同步执行到注册 `then` 为止”的那部分，另一块是“微任务队列里的 `then` 回调”。微任务之间紧密连接，却又与宏任务保持着严格的时间边界。

当我们把宏任务与微任务都纳入视野时，才会真正意识到：所谓“代码从上到下执行”，只是语言层面的错觉。在运行时，真正决定顺序的，是任务队列的调度策略。

## 事件循环：让 JavaScript 世界转起来的那只无形之手

宏任务与微任务，解决的是“任务在队列中如何排列”的问题；但还有一个问题没回答：是谁在不断地从队列里拿任务、执行任务，再等待下一轮？这只看不见的手，就是 event loop（事件循环）。

event loop（事件循环）这个词，最早经常出现在 Node.js 的语境里。浏览器里也有类似的机制，只不过很多资料并不会把它直接叫做“事件循环”。无论在何处，它的本质都可以拆解成极为朴素的三步：

1. 获取代码（或一个待执行的任务）；
2. 执行这段代码；
3. 等待某个条件被触发（时间、事件、I/O、锁等），然后回到第一步。

如果你用 Objective-C（OC，Objective-C 语言）加上 JavaScriptCore 写过一个小工具，会对这个过程有更具体的感受。你可能会做这样一件事：

- 创建一个 JSContext 实例，把它当作一个独立的 JavaScript 引擎；
- 在终端里打印一个提示符，等待用户输入一行代码；
- 把这一行字符串作为脚本，传入 `evaluateScript`；
- 将执行结果再打印出来；
- 重复上述步骤。

这就是一个极简化的事件循环模型：等待用户输入（等待）、获取这一行代码（获取任务）、交给引擎执行，并输出结果（执行）。然后，再次等待下一行输入。

在真实的浏览器环境里，“等待”的对象可能是用户的点击、键盘输入、定时器触发；在 Node.js 中，它可能是一个文件 I/O、一个 socket 上的请求；在嵌入式环境中，它甚至可能是一个底层锁的状态变化。

宿主环境会在底层用一个循环，不断地做这样的事情：

- 从宏任务队列中取出一个 macro task，交给引擎执行；
- 在这个宏任务执行的过程中，引擎会不断往微任务队列里塞入 micro task；
- 当当前宏任务的同步部分执行结束，引擎会清空 micro task 队列；
- 完成这整个“宏任务 + 微任务”的组合后，控制权交还给宿主；
- 宿主再根据定时器、事件、I/O 的状态，准备下一批要塞给引擎的宏任务。

这个过程被抽象成一个“事件循环”：事件驱动任务产生，循环驱动任务消耗。它既不是 JavaScript 语言本身的一部分，又是所有 JavaScript 程序得以运行的前提。

也正因为如此，许多真正理解 JavaScript 的工程师，都会从语言本身的语法往下多看一层：他们关心的不只是 `async/await`、`Promise` 这样的语法糖，而是底层那条默默运转的时间之河——事件循环。

## “任务层级”心智模型：构建属于你的前端运行时地图

如果把这节内容浓缩成一个可以反复使用的框架，那便是一个关于“任务层级”的心智模型。

在这套模型里，JavaScript 程序不再是单纯的“源代码文件”，而是一层一层嵌套的结构：

最外面一层，是宿主环境提供的“执行机会”。每一次浏览器加载一个 `<script>`，每一次 Node.js 触发一个回调，每一次原生应用调用 `evaluateScript`，都是它给予 JavaScript 引擎的一次宏观执行机会。这一层，就是宏任务（macro task）的世界。

再往里，是一个个由 Promise 之类机制创建出来的微型任务。每一个 `then`、每一个 `await` 背后，都对应着一个 micro task。这些微任务不直接出现在源代码的“行号”里，却悄无声息地改变了执行顺序。

在 micro task 之内，才是我们熟悉的函数调用栈。一个宏任务可以包含多个函数调用，每个函数内部又装着若干语句。你在调试器里看到的栈信息，就发生在这个层级之中。

再往下，是语句和表达式，这些是编译器和引擎优化、重排、常量折叠的地方；最底层，是各种直接量：数字、字符串、对象字面量，是一切抽象的原材料。

这就像一座城市的多层地图：

- “宏任务”层，是按天、按小时来组织的日程表；
- “微任务”层，是夹在日程之间的小插曲、小待办；
- “函数调用”层，是你真正坐下来工作的那几个小时；
- “语句和表达式”层，是你在键盘上敲下的每一个字符；
- “直接量”层，是构成世界的原子。

理解这座多层地图，有几个重要的意义。

第一，它把“结构化程序设计”提升到了时间维度。传统的结构化编程教会我们如何模块化地组织代码；而宏任务与微任务的层级，教会我们如何模块化地组织时间。编程不再只是“写出正确的逻辑”，更是“安排好逻辑何时执行”。

第二，它让调试异步问题有了明确的抓手。当你看到一段代码的执行顺序与预期不符时，可以主动问自己：这是宏任务之间的顺序问题，还是宏任务内部微任务队列的问题？是事件循环没轮到这段代码，还是微任务还没来得及清空？这种思考方式，比盲目地加 `console.log` 要可靠得多。

第三，它为你理解更高层的抽象打好了基础。无论是前端框架的更新机制、状态管理库的变更合并，还是 Node.js 服务器的请求处理模型，背后几乎都绕不开这套任务层级。掌握了它，你就拥有了一块可以递归使用的认知基石。

## 学会与时间做朋友的程序员

当我们还把 JavaScript 理解成“一行一行往下走”的简单脚本语言时，异步世界看起来总是混乱的。宏任务、微任务、事件循环像三个陌生的名词，散落在各类博客、教程和面试题里，彼此之间缺乏联系。

一旦从“任务层级”的角度重新审视它们，就会发现它们其实从来没有分开过：

- 宏任务定义了引擎被唤醒的节奏；
- 微任务在宏任务结束前，完成了对时间的再切分；
- 事件循环在更大时间尺度上，协调了宿主环境与引擎之间的互动。

这三者共同构成了一门语言的“时间观”。而真正成熟的前端工程师，往往都在某个时刻，完成了从“只写代码”到“理解时间”的跨越。

写同步代码，看的是空间结构：函数如何拆分，模块如何组织；写异步代码，看的是时间结构：哪些逻辑应该在这一轮事件循环内完成，哪些逻辑要留到下一轮。

当你在控制台里敲下一行 JavaScript，当你在业务代码里写下一个 `await`，当你为性能优化而斟酌一个定时器的延迟，其实都在与这套“时间秩序”打交道。区别只在于：你是被动地接受其结果，还是主动地利用其规律。

理解宏任务、微任务与事件循环，并不会立刻让你的代码变得“炫技”，但会悄悄改变你看待问题的方式。你会更少地被奇怪的执行顺序困扰，更少地被异步 bug 牵着鼻子走，也更有底气去阅读和设计复杂的前端系统。

编程，终究是一种与时间对话的艺术。学会这门语言的时间语法，你才能真正从容地在它的世界里，安排一切。
