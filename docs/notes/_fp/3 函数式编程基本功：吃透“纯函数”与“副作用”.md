也许你曾经在 Redux 的官方文档中，读到过这样的描述：“reducer 必须是一个**纯函数**”。

也许你曾经在某一次面试中，遇到过这样的问题：“如何理解**纯函数**的优势”？

也许你曾经在某篇社区热门文章中，读到过这样的描述：“xxx 会引入**副作用**，这样做不够优雅”。

随着函数式编程思想在前端领域逐渐崭露头角，纯函数这个概念也越来越多地受到前端社区的关注。

在过去，它对你来说可能是一套 Redux 的编写规则，也可能是一道稍显晦涩的问答题。

但现在，你需要知道，**纯函数是函数式编程的一个最大的前提，也是这坨知识体系的根基**。

为了打好这个根基，我们将在接下来的两节课里深入探讨如下问题：

-   纯函数、副作用的内涵
-   纯函数/非纯函数的辨析
-   从数据流的角度理解“纯”与“不纯”的本质
-   纯函数解决了什么问题

  


上面罗列的几个问题，足以帮助你对这块知识构建起全面的理解，也基本覆盖了面试中所有可能的提问角度。

大家不妨把这几个问题先记下来，作为自己构建知识体系的线索，也作为后续检验自己学习成果的标准。

  


在本节的开始，我们首先要来探讨“**是什么**”的问题。

  


## 厘清两个概念

### 什么是纯函数？

同时满足以下两个特征的函数，我们就认为是纯函数：

-   对于相同的输入，总是会得到相同的输出
-   在执行过程中没有语义上可观察的副作用。

### 什么是副作用？

我们看到，在纯函数的定义中，出现了对”副作用“的描述。

  


相比于“函数副作用”来说，更为大家所熟知的一个概念或许是“药物副作用”：我们为了治疗A疾病服用某种药物，药物在缓解A疾病的症状之余，可能会导致B疾病。那么“引发B疾病”就是这个药物的副作用。

生活经验告诉我们， 药物副作用的产生是由“**药物的影响面过大**”导致的。

比如我们原本只是期望药物帮助我们消除呼吸系统的炎症，但这种药物的作用范围并不仅限于你的呼吸系统，它还会刺激你的肠胃、导致肠胃功能紊乱。

原本我们只希望它伸出一只手来解决呼吸系统的问题，但现在它却**伸出了两只手，一只手帮你解决问题，另一只手创造更多的问题**（如下图）：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42ac074d3d0344178e7b7bcdede5e2a9~tplv-k3u1fbpfcp-zoom-1.image)

从图中我们可以看出，副作用指的正是药物在完成正常工作任务（作用于呼吸系统）之外，对外部环境（消化系统）所施加的影响。

我们对这句话稍作修改，便能够得到函数副作用的定义：

> 在计算机科学中，**函数副作用**指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。 ——维基百科

简单地讲：对函数来说，它的正常工作任务就是【**计算**】，除了计算之外，它不应该搞别的。

**如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”。**

  


干嚼理论太空洞，接下来我们就趁热打铁，借助几个具体的编码案例，一起来认识一下纯函数的真面目。

  


## 举几个🌰来辨析一下

### Case #1：加法函数

先来看一个 add 函数：

```js
let a = 10
let b = 20
function add() {
  return a+b
}
```

这个函数是不是纯函数？

答案是否定的，因为对于相同的输入，它无法做到相同的输出。

比如我们初次执行 add() 时，它会 return 一个 30 出来。

但如果我在全局作用域做了如下修改：

```js
a = 30  
b = 40
```

此时再次调用 `add()`，我们得到的输出就将从 30 变为 70。

对于相同的输入，`add()`函数给到了不同的输出。这违背了纯函数的第一条规则：**对于相同的输入，总是会得到相同的输出**。

有同学可能产生这样的疑问：楼上好像是两次截然不同的输入啊？第一次输入了 `a=10,b=20`；第二次又改为了 `a=30,b=40`。

这里需要强调的是，“输入”指的是**函数的入参**。

对于 `add()` 函数来说，它的输入其实是一直都是 void。

那么我们怎么处理才能够使 add 函数变为一个纯函数呢？

方法也很简单，只需要把“数据的输入”这件事情完全交给入参来做就可以了，我们可以这样改造：

```js
let a = 10  
let b = 20

function add(a, b) {
  return a+b
}

// 30
add(a, b)   

a = 30  
b = 40

// 70
add(a, b)
```

简单的改造后，add 函数就能够充分满足纯函数的两个条件了：

1.  对于相同的输入，总是会得到相同的输出：对于相同的 `a` 和 `b` 来说，它们的和总是相等的✅
1.  在执行过程中没有语义上可观察的副作用：`add()` 函数除了加法计算之外没有做任何事，不会对外部世界造成额外影响✅

### Case #2：姓名处理函数

接下来我们来看一个姓名处理函数：

```js
function processName(firstName, secondName) {
  const fullName = `${firstName}·${secondName}`
  console.log(`I am ${fullName}`)
  return fullName
}

processName('约瑟翰', '庞麦郎')
```

这个函数也是一个不纯的函数，问题出在这行 `console.log()` 上。

` console.log()  `会在控制台打印一行文字，这改变了浏览器的控制台，属于对外部世界的影响，也就是说 **processName 函数在执行过程中产生了副作用**。

要想把它改回纯函数也非常简单，只需要像这样把副作用摘出去就可以了：

```js
function processName(firstName, secondName) {
  const fullName = `${firstName}·${secondName}`
  return fullName
}

console.log(processName('约瑟翰', '庞麦郎'))
```

### Case #3：网络请求函数

最后我们再来看一个非常经典的 Case：

```js
function getData(url) {
  const response = await fetch(url)
  const { data } = response   
  return data
}
```

`getData` 函数是否是一个纯函数？

答案是否定的，**一个引入了网络请求的函数，从原则上来说是纯不起来的**。

为什么网络请求会使函数变得不纯呢？我们以示例代码中的 get 请求为例来分析一下：

-   请求获取到的 `response` 是动态的：需要通过网络请求获取的数据往往是动态的，**对于相同的输入，服务端未必能够给到相同的输出**。
-   请求可能出错：既然是网络请求，那就一定要考虑失败率的问题。网络拥塞、机房起火、后端删库跑路等等问题都有可能导致请求过程中的 `Error`，**未经捕获的 `Error` 本身就是一种副作用**。

当请求方法为 `post`、`delete` 等具有“写”能力的类型时，网络请求将会执行对外部数据的写操作，这会使函数的“不纯”更进一步。

  


  


## “纯”与“不纯”的本质

通过对以上示例的分析，我们已经能够借助两大特征来快速地对函数的“纯”与“不纯”进行甄别。

### “纯”的本质——有且仅有【显式数据流】

站在特征的肩膀上，我们再去理解纯函数的学术定义，就会简单得多：

>纯函数（Pure Function）——输入输出数据流全是**显式**（Explicit）的函数。    
                                                   —— 维基百科

定义中的“显式”这个概念，其实非常好理解，它约束的是数据的来源（**入参**）和出口（**返回值**）。

数据以入参形式传入，这叫【显式输入数据流】。

数据以返回值形式输出，这叫【显式输出数据流】。

定义中要求“输入输出数据流全是**显式**（Explicit）的”，那就是说数据只能以入参的形式进来，并且只能以返回值的形式出去。

由此，我们可以把“学术定义”翻译为如下的大白话：

> 纯函数——**输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，不以任何其它形式和外界进行数据交换的函数**。   ——修·格拉底·鲁迅·言思妥耶夫斯基

所以说，纯函数到底“纯”在哪里？

纯就纯在【**显式数据流**】！

那么，显式数据流是啥呢？

显式数据流意味着**函数除了入参和返回值之外，不以任何其它形式与外界进行数据交换**。

反复把这句话说三遍，然后我们带着这个结论重新分析一遍楼上的 3 个案例。

### “不纯”的元凶——隐式数据流

对于 **Case #1** 中的加法函数来说，它的不纯是由**隐式的数据输入**导致的——我们通过观察 `add()` 函数的入参声明，并不能够发觉 a 和 b 两个数据源的存在。

`a` 和 `b` 两个变量并没有以入参的形式传入，而是在函数执行过程中直接被从全局作用域“抓进来”参与计算的（如下图），这就是典型的隐式数据交换。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5d19c82dfb446abbfd66ef8bc71376d~tplv-k3u1fbpfcp-zoom-1.image)

图中的横向数据流表示函数自身的显式数据流动，方向是从入参到出参。

纵向数据流则是隐式数据流，代表函数和外界的数据交换。

**一个纯函数在执行过程中应该只有横向数据流，而不应该有纵向数据流。**

对于 **Case #2** 中的姓名处理函数来说，它的不纯则是由**隐式的数据输出**导致的。

我们通过观察 ` processName()`的 return 语句，只能够观察到“`fullName`”这个变量的输出。

但在实际的执行中，`processName()` 会偷偷地向控制台输出一行字符串，这个字符串脱离了显式数据流的流向，进而导致函数不纯（如下图）：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c0e99785844984a87b5bb50e382609~tplv-k3u1fbpfcp-zoom-1.image)

**Case #3** 中的网络请求函数，同样是与外界进行了隐式的数据交换，导致出现了显式和隐式的两条交叉的数据流。这里不再赘述。

## 小结

行文至此，大家已经对“纯函数”和“副作用”的内涵有了透彻的理解。

此时你或许已经开始好奇：创造这么多名词、制定这么多条条框框来约束的这一类特别的函数，对于我们实际的生产生活到底有什么益处呢？纯函数这东西又是何德何能，足以称得上是函数式编程知识体系的“根基”呢？

带着这些疑问，让我们开启下一节的学习吧！ღ( ´･ᴗ･` )  


（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）