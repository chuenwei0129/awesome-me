在上一节，我们围绕“什么是不可变数据”这个话题进行了深入的探讨，并建立了不可变数据和函数纯度之间的关联关系。我们已经明确知道，**要想写出好的函数式代码，就需要确保数据的不可变性。**

理解了“what”和“why”的问题，本节我们来好好聊一下“how”。

## “不可变”不是要消灭变化，而是要控制变化

大家知道，我们现代前端应用的复杂度整体是比较高的，其中最引人注目的莫过于“状态的复杂度”。

“状态”其实就是数据。

一个看似简单的 H5 营销游戏页面，背后可能就有几十上百个状态需要维护，如果没有状态之间的相互作用、相互转化，又怎能将精彩纷呈的前端交互呈现给用户呢？

程序失去变化，宛如人类失去灵魂。

所以咱们说，消灭变化是不可能的事情，也是万万不可的事情。

我们真正要做的，是**控制变化，确保所有的变化都在可预期的范围内发生**，从而防止我们的程序被变化“偷袭”。

正如老话所说：不怕他来，就怕他乱来。

我们本节要学习的，正是“不让他有机会乱来”的技术。

  


## 名不副实的 "constant"

首先，你需要小心 constant。

我至今仍然记得，“const” 关键字首次被引入 JavaScript 的那一年，函数式编程社区的 JS 开发者几乎集体高潮——不少人都认为，const 是对 JS 语言特性的一次重大改进，它将从根本上限制开发者的reassign（重新赋值）操作，进而保障数据的不可变性。

然而，理想很丰满，现实很骨感。const 真的能够保证数据的不变性吗？我只能说，const 了，但没完全 const（此处应有苦笑）。

众所周知，const 其实是单词“constant”的缩写，而“constant”意为“不变的”。如果我说，“the price is constant”，那么我想表达的就是“价格是不变的”：我早上去买是10块钱一斤，晚上去买也应该是10块钱一斤。

也就是说，假如我们单纯从**语义上**来理解“const”这个关键字，那么它确实应该为我们保障数据的不变性。

但语义归语义，现实情况是，**const 只能够保证值类型数据的不变性，却不能够保证引用类型数据的不变性。**

对于值类型来说，我这里用 `const` 创建一个变量 `price`，并将它赋值为一个值类型（Number）数据：

```js
const price = 10
```

如果我想修改 `price` 的值，我只能尝试对它进行 reassign（重新赋值），比如这样：

```js
price = 20
```

显然，如下图所示，这是行不通的，毕竟我们的 `const` 生下来就是专门阻止你做 reassign 这个动作的。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a98fab8e8c1431b82c1cf30194d7d19~tplv-k3u1fbpfcp-zoom-1.image)

只要禁止了 reassign， 就堵死了修改值类型变量的唯一一条路，也就确保了其数据内容的不变性。

因此，对于存储值类型数据的变量来说，`const` 确实能够确保其内容的不变性。

  


但对于引用类型来说，就算堵住了 reassign，也不影响我们修改数据的内容。 比如这段代码就是不会抛错的：

```js
const me = {
  name: 'xiuyan',
  age: 30
}

// 这一行不会报错
me.age = 35

console.log(me)
```

在这个案例中，我同样是使用 `const` 关键字创建了变量 `me`，但在尝试修改 me 的内容时，我并没有将一个新的对象 reassign 给 me 变量，而是使用“.age”语法来访问并修改既有对象的其中一个属性。

`const` 没想到啊，引用类型的数据内容改变居然根本不需要 reassign。没有了 reassign，`const` 察觉不到变化的发生，也就只能原地摆烂了。

  


因此，**`const` 对数据不变性的保证是有前提的，对于引用类型来说，const 并没有什么卵用**。

事实上，由于值类型数据天然存在不可变性，当我们讨论“JS 数据不可变性”时，更多的其实就是在讨论如何保证【引用类型】数据的不可变性。

  


## 不可变数据の实践原则：拷贝，而不是修改

既然 constant 指望不上，那么我们有什么办法来确保引用类型数据的不可变性呢？

答案也很简单，大家只需要记住一个原则：**不要修改，要拷贝。**

  


### 拷贝行为实践：安全、快速、药到病除

这里我们继续沿用上一节招聘平台的例子，首先我有一个编号为001的岗位，它的主要信息囊括在这样一个对象里：

```
const JOB_INFO_001 = {level: 7, workTime:2 , type:'engineer', city:'New York'} 
```

某天，hr找到我说，想要给代码里添加这样一段动态增加新职位的逻辑：

1.  首先确认公司当前的高管职位总数是否少于一定的阈值，从而决定要增加的新职位是高管职位还是基础职位 (这里我们假定有一个现成的函数可以使用，它叫做 `isHighPosition()`）
1.  如果 `isHighPosition()` 调用返回为 `true`，那么就动态地增加一个高管职位，这个职位基本所有信息都和某个现有的基础职位（此处以`001`为例）一致，只有 `level` 需要调整为 10。
1.  否则，不增加高管职位，只增加一个基础职位（此处以`001`为例）。

这个需求很简单，我们先来无脑实现一个粗糙版本：

```js
// 将 hr 的需求实现为函数 dynamicCreateJob()
function dynamicCreateJob(baseJob) {
  let newJob = baseJob
  // 判断当前是否需要增加一个高管职位
  if(isHighPosition()) {
      // 针对高管职位，调整level信息
      newJob.level = 10 
  }
  return newJob
}

// 这里以 001 为例，对函数进行测试
const dynamicJob = dynamicCreateJob(JOB_INFO_001)
```

这个粗糙版本显然并没有遵循“不可变数据”的原则——它直接在 `baseJob` 的对象本体上进行了篡改，这将导致 `JOB_INFO_001` 的内容直接被覆盖，从而影响整个程序中所有引用到 `JOB_INFO_001` 的逻辑模块，导致这些模块集体“躺枪”。

人生建议：**不要修改 baseJob，而是修改它的副本**：

```
// 将 hr 的需求实现为函数 dynamicCreateJob()
function dynamicCreateJob(baseJob) {
  // 创建一个 baseJob 的副本
  let newJob = {...baseJob}
  // 判断当前是否需要增加一个高管职位
  if(isHighPosition()) {
      // 针对高管职位，调整level信息
      newJob.level = 10 
  }
  return newJob
}

// 这里以 001 为例，对函数进行测试
const dynamicJob = dynamicCreateJob(JOB_INFO_001)
```

这样一来，baseJob 和 newJob 就彻底变成了两个泾渭分明的对象了。我对 newJob 所做的任何修改，都不会影响到 baseJob。

通过拷贝，我们顺利地**将变化控制在了 `dynamicCreateJob()` 函数内部**，避免了对全局其它逻辑模块的影响。

  


### 拷贝的目的：确保外部数据的只读性

用拷贝代替修改后，`baseJob` 对于 `dynamicCreateJob()` 函数来说，成为了一个彻头彻尾的**只读数据**。

关于只读数据，如果你是一个函数式编程发烧友，你可能会在一些文章中读到过一种过度概括的观点：不可变数据的内涵就是创造并使用“只读数据”。

之所以说这种观点是过度概括的，是因为它少了一个“**外部数据**”的限定词。

正如我在开篇时强调的那样，如果一个程序里只有只读数据、而没有数据的变化，这个程序几乎无法做任何事情。

因此，无论是什么样的编程范式，**只读数据都必须和可写数据共存**。

对于函数式编程来说，**函数的外部数据是只读的，函数的内部数据则是可写的**。

对于一个函数来说，”外部数据“可以包括全局变量、文件系统数据、数据库数据、网络层数据等。有且仅有这些**外部数据**，存在【只读】的必要。

> 注：由于纯函数只能通过参数获取数据，因此如果需要使用外部数据，就必须将其作为参数传递给函数。


## 小结

本节，我们探讨了不可变数据的两种最直接的实践思路：对于值类型数据，我们可以使用 const 来确保其不变性；对于引用类型数据，我们可以使用拷贝来确保源数据的不变性。

这其中，引用类型数据的不可变性值得我们再三思考——拷贝是否是一个完美的解法？它背后是否隐藏着种种问题？有没有比拷贝更加高效的解法呢？

答案当然是有啦，下一节，我们就将讨论不可变数据的进阶解法中最有名的一个——Persistent Data Structure（持久化数据结构）。

## 补充

在本节，我们探讨了拷贝行为在函数式编程中的作用与意义，由此不难联想到另一个更加独立的命题：如何在 JS 中实现引用类型数据的拷贝？

这也是一道非常经典、也相对基础的面试题。

由于过于经典，相关的探讨在社区随处可见，有过面试经历的同学也基本都能对此信手拈来。这里我并不打算单独为其铺陈一个章节来叙述。

但对于不熟悉拷贝的同学，我想要给你以下的学习建议：

在本文的示例中，我使用了扩展运算符来拷贝一个简单的对象。

类似的，你也可以使用 Object.assign 接口来实现拷贝。

而对于数组，除了扩展运算符外，还有像 slice、concat、map 等实用的数组接口供你挑选。

当然啦，这还并非“拷贝”的全貌，若想学得精些，你还需要辨析深、浅拷贝的区别。

其中深拷贝的实现尤其耐人寻味，也经常作为大厂的笔试题出现。

学习深拷贝时，我建议你不仅要多吸收社区群众的智慧，更要善于向成熟的工具方法库进行学习，[lodash](https://github.com/lodash/lodash) 的 deepClone 函数就是一个不错的教材。  
  
（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）