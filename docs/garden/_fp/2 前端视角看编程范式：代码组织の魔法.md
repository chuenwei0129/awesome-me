## 前端视角看编程范式

在 JS 世界中，以下三种编程范式是大家一定要了解的：

-   命令式编程
-   面向对象编程
-   函数式编程

  


对于许多前端同学来说，入门前端的第一步，接触到的基本都是命令式编程。

紧接着，随着 JS 知识的精进，你会渐渐地进入面向对象的世界，“模拟继承”、“原型与原型链”是许多同学学习 JS 遇到的第一个系统性难点知识。

然后，你可能会接触到一些基于 Class 来构建自己组件系统的热门框架（比如旧版本的 React），这将强化你对面向对象风格的熟悉和认同。  
**于是，左手命令式、右手面向对象，偶尔（或从不）引入函数式编程的某些特性，这成为了许多同学的前端入行起手式。**

这也解释了为什么对于不少已经上手业务开发的前端同学来说，函数式编程仍然是个神秘而未知的东西。

**对于未知事物，如果我们单纯凭借干巴巴的概念定义去认识它，这需要极强的悟性和心性。**

**但如果能够借助对已知事物的理解，一步一步类比推理出对未知事物的认知，我们的学习曲线就将平滑得多，吸收知识的效率也将大大提升。**

在我们已知的编程范式中，面向对象固然经典，但在没有系统学习过函数式编程的情况下，我们很难对这两者进行深入、透彻的对比。因此我将把 OOP VS FP 的辨析放在小册的后半程。

本节，在整本小册的开篇，我们首先从大家最为熟悉的命令式编程入手，将命令式的思维模式与函数式进行类比，帮助大家**借助已知去认识未知**、从感性上建立对函数式编程的宏观理解。

  


  


## 命令式 vs 函数式：“过程思维” vs “结果思维”

命令式编程关注的是一系列具体的执行步骤，当你想要使用一段命令式的代码来达到某个目的，你需要一步一步地告诉计算机应该“怎样做”。

与命令式编程严格对立的其实是“声明式编程”：不关心“怎样做”，只关心“得到什么”。

函数式编程是声明式编程的一种。

具体到范式表达上，函数式编程总是需要我们去思考这样两个问题：

-   **我想要什么样的输出？**
-   **我应该提供什么样的输入？**

对于这两套思维模式的差异，我们不妨借助生活中的吃饭场景来理解。

## 举个生活例子🌰：番茄🍅炒蛋🥚的故事

有一天韩梅梅突然很想吃番茄炒蛋，为了吃到这口番茄炒蛋，她想到了命令式做菜和函数式做菜两种思路：

### 命令式做菜：让我来告诉你如何炒出番茄炒蛋

如果韩梅梅选择了命令式做菜，那么她这时会喊来打游戏打到一半的李雷，把他推进厨房，并按顺序发出如下命令：

1.  你要把鸡蛋敲开打散，番茄切块备用
1.  锅里倒油，油热后倒入蛋液
1.  鸡蛋凝固后，放入西红柿开炒
1.  加调味，再炒
1.  大火收汁
1.  关火
1.  装盘

......

命令式做菜要求韩梅梅必须对做菜的过程了如指掌，每一个步骤她都需要事无巨细地关注到。

**这些具体步骤组成的命令序列，就是一段命令式程序。**

  


### 函数式做菜：不关心菜谱，只关心输入与输出

如果韩梅梅选择了函数式做菜，那么她的体验就会轻松得多。

同样是喊来打游戏打到一半的李雷，她可以考虑：

1.  从冰箱摸3个番茄和2个鸡蛋，交给李雷，让李雷去厨房想办法弄出这道菜
1.  给李雷20块钱，让他去楼下买一份番茄炒蛋上来
1.  当然，她也可以打开自己手机里的丑团外卖下一个订单，这样李雷的游戏血条就保住了

  


此时，对于韩梅梅来说，生产番茄炒蛋的过程就像一个黑盒：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/102ac7e08c014456821b14e79a2a1a07~tplv-k3u1fbpfcp-zoom-1.image)

无论是李雷冒着炸厨房的风险试验出这道菜，还是李雷拿着20块钱到楼下买这道菜，亦或是厨师做好菜交给丑团小哥、丑团小哥送上门的这些具体细节，对于韩梅梅来说都是不需要感知的。

在函数式做菜的过程中，韩梅梅只需要关注两件事情：

-   **我想要什么样的输出？** （一盘番茄炒蛋）
-   **我应该提供什么样的输入？** （食材或者钱💰）

  


## 举个 Coding 例子🌰：员工信息筛选工作流

接下来我们用一个编码案例，来对两者的差异做更进一步的阐述。

考虑这样一个场景：

我们有一个员工信息数据库。现在为了对年龄大于等于 24 岁的员工做生涯指导，需要拉出一张满足条件的员工信息清单，要求清单中每一条信息中间用逗号分隔，并按照年龄升序展示。

把这个需求简单梳理一下，分三步走：

1.  对列表进行排序
1.  筛选出 `>= 24` 岁这个区间内的员工列表
1.  针对该列表中的每一条员工数据历史，保存到 `logText` 中

  


当然，你也可以交换步骤1和步骤2的顺序，这样可以缩小排序范围，提高排序效率。

但就编码内容来说，不管是以什么样的顺序来执行这三个步骤，该写的代码是一点也少不了。

接下来我就按照 `1->2->3` 这个顺序来给大家写写看。

按照命令式编程的脑回路来实现，我们不难想到用循环来做。命令式编程的代码如下所示：

```js
// 这里我mock了一组员工信息作为原始数据，实际处理的数据信息量应该比这个大很多
const peopleList = [
  {
    name: 'John Lee',
    age: 24,
    career: 'engineer'
  },
  {
    name: 'Bob Chen',
    age: 22,
    career: 'engineer'
  },
  {
    name: 'Lucy Liu',
    age: 28,
    career: 'PM'
  },
  {
    name: 'Jack Zhang',
    age: 26,
    career: 'PM'
  },
  {
    name: 'Yan Xiu',
    age: 30,
    career: 'engineer'
  }
]

const len = peopleList.length

// 对员工列表按照年龄【排序】
for(let i=0;i<len;i++) {
  // 内层循环用于完成每一轮遍历过程中的重复比较+交换
  for(let j=0;j<len-1;j++) {
    // 若相邻元素前面的数比后面的大
    if(peopleList[j].age > peopleList[j+1].age) {
      // 交换两者
      [peopleList[j], peopleList[j+1]] = [peopleList[j+1], peopleList[j]]
    }
  }
}

let logText = ''
for(let i=0; i<len; i++) {
  const person = peopleList[i]
  // 【筛选】出年龄符合条件的
  if( person.age >= 24 ) {
    // 从数组中【提取】目标信息到 logText
    const perLogText = `${person.name}'s age is ${person.age}`
    if(i!==len-1) {
      logText += `${perLogText},`
    } else {
      logText += perLogText
    }
  }
}

console.log(logText)
```

在这段代码中，我们逐个实现了排序、筛选、信息提取这三大块逻辑。

下面再来看看函数式的解法：

```js
// 定义筛选逻辑
const ageBiggerThan24 = (person)=> person.age >= 24

// 定义排序逻辑
const smallAgeFirst = (a, b) => {
  return a.age - b.age
}

// 定义信息提取逻辑
const generateLogText = (person)=>{
  const perLogText = `${person.name}'s age is ${person.age}`
  return perLogText
}

const logText = peopleList.filter(ageBiggerThan24)
                      .sort(smallAgeFirst)
                      .map(generateLogText)
                      .join(',')

console.log(logText)
```

这段代码在执行结果上和命令式代码是一样的，但内容却非常简洁，也具有更强的可读性。

作为用户，我不需要了解每个函数内部都执行了哪些语句，仅仅通过函数名就可以推断出来这个调用链做了哪些事情。

此外，声明式代码定义的 `ageBiggerThan24`、 `sortByAge`、`getLogText`等方法，是可以被复用的。

而命令式代码中的比大小、排序、字符串处理等逻辑，更像是“一锤子买卖”，执行完也就过去了，日后想要实现相同的逻辑，只能靠复制粘贴。

## 思考：函数式编程是怎样解决问题的

有同学这时候可能会纳闷儿了：这段代码不就是几个简单的数组方法调用么？这也叫函数式编程？就这？

首先，尽管对于一些“原教旨主义者”来说，数组方法的函数式确实不够彻底——因为这些函数仍然是作为数组对象的实例方法存在的，尚存一些 OOP 的”余孽“。

但 JS 本身就是多范式的语言，对 JS 来说，**数组方法确实是非常重要的函数式编程工具**。这一点我们在后续的章节里还会反复验证。

  


接下来我们看回楼上的示例代码，它的背后表达了一种与命令式编程截然相反的脑回路：

**以“输入”和“输出”为轴心，来组织程序。**


具体到代码里来说，我们首先可以根据需求明确输入输出：

输入是一个 `peopleList`（员工列表），而输出是一个 `logText`（逗号分隔的字符串）。

以输入为起点，输出为终点，我们就可以拉起来这样一条数据转换的“流水线”：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6625bce5f774b088ef71cc6e41f5ecd~tplv-k3u1fbpfcp-zoom-1.image)

此时中间的 Operation 对我们来说还是一个黑盒，但我们可以通过进一步分析数据的变换来明确出黑盒中的函数组合：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4275ed8ed75e493090b739a16a7f095e~tplv-k3u1fbpfcp-zoom-1.image)

对于流水线中的每一个步骤、每一个函数调用，我们**仍然不必去关注其内部的执行细节，只需要关注函数的输入与输出**。

  


每一个函数都是一个逻辑块，每一个逻辑块都代表着一次变换。

在函数式编程的代码组织模式下，我们关注的不再是具体逻辑的实现，而是**对“变换”的组合**。

这个过程其实和工厂生产果汁的过程很相似。

我们放几个橙子🍊到流水线的入口，它会经历去皮、压榨、滤渣等几个环节。

函数式编程中的“函数”就像流水线上的一个个工序，这些工序吃进去原材料，吐出目标产物。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/735d36ff233d4e9f87405e9e280ebb40~tplv-k3u1fbpfcp-zoom-1.image)

  


作为一个流水线工人，我不需要知道每一个工序的执行细节，我只要能把不同工序的机器组装到一起就可以了。

  


## 小结

命令式编程对许多同学来说，是真正意义上的“入行起手式”。

本节我们以命令式编程为引子，意在帮助大家认识函数式编程“**结果导向**”的思维方式、以及【**抽象+组合】** 的行为方法论。

在小册的调研阶段，我注意到不少同学对于范式的认识和思考比较欠缺——不仅仅对于函数式编程缺乏了解，甚至对于自己每天都在使用的命令式、面向对象等范式也无法给出系统的理解，最终导致在实践和面试中都吃了很多亏。

因此，对于范式相关的基础知识，我会讲得比较详细。也希望大家在理解这些内容之后，能够去主动思考一些平时没空去思考、但是对自己真正有益的问题。

通过本节的学习，相信你不仅能够建立对函数式编程的初步认识，更能够深化自己对命令式编程的理解。

最重要的是，**你将开始主动去思考一些略高于编码本身的问题**。而这样的思考，将会贯穿我们整本小册。

下一节，我们将进入正题，从函数式编程的基本功开始，一窥它的全貌。

（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）