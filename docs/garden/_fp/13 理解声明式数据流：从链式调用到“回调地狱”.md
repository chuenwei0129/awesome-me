书接上回，我们仍然用数组方法作为我们切入本节的引子。

考虑这样一个数字数组 `arr`：

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8]  
```

现在我想以 `arr` 数组作为数据源，按照如下的步骤指引做一个求和操作：

1.  筛选出 `arr` 里大于 2 的数字
1.  将步骤1中筛选出的这些数字逐个乘以 2
1.  对步骤 2 中的偶数数组做一次求和

当然啦，1、2都只是过程，我想要的只有步骤3的求和结果而已。

从一个朴素的视角出发，我可以实现如下的计算过程：

```js
// 用于筛选大于2的数组元素
const biggerThan2 = num => num > 2  
// 用于做乘以2计算
const multi2 = num => num * 2    
// 用于求和
const add = (a, b) => a + b   

// 完成步骤 1
const filteredArr = arr.filter(biggerThan2)    
// 完成步骤 2
const multipledArr = filteredArr.map(multi2)    
// 完成步骤 3
const sum = multipledArr.reduce(add, 0)
```

大家可以试着把这坨代码丢进控制台，每个步骤的计算结果输出如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ebf3958cb834a42a60cc4c1a95945f7~tplv-k3u1fbpfcp-zoom-1.image)

输出结果符合预期，说明这坨代码是能用的。

## 🌰code review 思考：简洁否？安全否？

然而，作为一个好的程序员，“能用”只是最基本的代码标准。在此基础上，我们还需要兼顾代码的质量。

代码质量衡量是一个相对宏大的命题。这里我们的例子比较简单，不需要整太多花活，只需要考虑最基础的两个要素——**简洁否？安全否？** 。

本着简洁和安全的原则，我们来对楼上的🌰进行一次 code review。

首先，代码是否简洁？

**答案是【否】。**

**我们的目标输出只有** `sum` **这一个求和结果，计算过程中额外定义的** `filteredArr` **、** `multipledArr` **完全属于混淆视听的冗余常量，它们拉垮了代码的可读性。**

一旦我走出了当前的代码块，我将不会在任何地方再用到`filteredArr`和`multipledArr`——它们唯一的作用，就是作为入参，辅助 `sum` 的求和。

像这样的值，我们可以记为“计算中间态”。

其次，代码是否安全？

**答案是【否】。**

`filteredArr` **和** `multipledArr` **作为引用类型，完全有可能在运行过程中被修改。**

试想一下，楼下的这三行代码，它们是严格绑定的吗？

```js
const filteredArr = arr.filter(biggerThan2)    
const multipledArr = filteredArr.map(multi2)    
const sum = multipledArr.reduce(add, 0)
```

显然不是，只要我想，我可以往它们中间插入任何噪音代码，像这样：

```js
const filteredArr = arr.filter(biggerThan2)         

// 噪音代码1号
function changeArray() {
  .....  
  filteredArr.push(100)
}
changeArray()

const multipledArr = filteredArr.map(multi2)     

// 噪音代码2号
function changeArrayAgain() {
  .....  
  multipledArr.push(101)
}    
changeArrayAgain()

const sum = multipledArr.reduce(add, 0)
```

如上面代码所示：我不费吹灰之力就可以在 sum 计算还没有完成的情况下，打断整个计算流程，并且篡改 filteredArr 和 multipledArr 这两个关键的**计算中间态**。

你可能会觉得，这样的篡改看上去显得有些暴力且无脑。如果这个模块只有你自己在开发，你一定会想办法避免破坏这3行代码执行的连续性。

但是当你**写了10000行代码再往回看**这3行代码的时候......你真的还会记得自己立下的那个“禁止打断、绝不篡改”的 flag 吗？

以及，当你带的实习生**协助你迭代**这个模块时，他会知道这背后还会有一个“禁止打断、绝不篡改”的 flag 需要守护吗？

与其寄希望于 flag，不如一开始就**不要把计算中间态暴露出去**。

## 解法启蒙：蛋糕🍰工厂流水线是如何组合多道工序的？

如何改善这段代码呢？

想象我们在一家蛋糕🍰工厂工作。

制作一个蛋糕，需要很多工序，比如：

1.  工序①：混合原材料，制作**蛋糕液**
1.  工序②：烘焙蛋糕液，制作**蛋糕坯**
1.  工序③：往蛋糕胚上**撒糖霜**，增加基本的风味
1.  工序④：往蛋糕坯上**放巧克力/草莓/芒果**等等，增加进阶的风味

截止目前，工人们是这样协作的：

工序①的工人们完成了工作之后，就把装有蛋糕液的桶放在地上，等候工序②的工人过来取走它。

工序②的工人制作完蛋糕坯后，又把蛋糕坯放在地上，等候工序③的工人过来取走它。

工序③的工人撒完糖霜后，又把蛋糕坯放在地上，等候工序④的工人过来取走它......

很快，工厂老板就会发现这样两个问题：

1.  放在地上的蛋糕液/蛋糕坯非常容易遭受污染，也容易被路过的工人一脚踢翻。
1.  无论是蛋糕液桶，还是蛋糕坯块，丢在地上总是需要占用空间的。在生产旺季，堆积如山的“蛋糕中间态”将使得本不宽敞的厂房雪上加霜。

仔细想想，楼上给出的串行计算示例，是不是就恰似这条蛋糕流水线？

地板上堆积如山的“蛋糕中间态”，是不是就恰似那些冗余的“计算中间态”？

工厂老板会如何解决这个问题呢？

在工厂打过螺丝/看别人在工厂打过螺丝的同学会知道，不同工序之间的流水线是由**传送带**连接的。

完成一道工序后，传送带会主动把这一步交付的产物送到下一道工序里去。这样就可以确保所有的 **“蛋糕中间态”只会穿梭于不同的工序之间，而不会暴露在流水线的外部**。

  


在 JS 世界中，最像“传送带”的东西，无疑是**链式调用**。

## 借助链式调用构建声明式数据流

大家知道，像 map、reduce、filter 这些数组方法，它们彼此之间是可以进行链式调用的。

因此，我们完全可以把楼上的啰嗦代码改写为如下风格：

```js
const sum = arr.filter(biggerThan2).map(multi2).reduce(add, 0)
```

链式调用的每一步，都会像传送带一样，把上一步的输出作为下一步的输入“传送”出去。

对比一下链式调用前后的两个函数工作流（左侧为链式调用前，右侧为链式调用后）：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e1de59b45848e0982ba71d67c99de3~tplv-k3u1fbpfcp-zoom-1.image)

我们可以看到，借助链式调用，足以完美地规避掉那些尴尬的“中间态”，从而确保我们的代码简洁安全。

同时，链式调用也大大改善了代码的可读性：

过去，我有三行代码，我需要逐行阅读、理解计算中间态和主流程之间的逻辑关系，才能够推导出程序的意图。**这样的代码，是命令式的。**

现在，我只需要观察一个函数调用链，这个调用链如同一条传送带一般，用函数名标注了每道工序的行为。即便不清楚数据到底是如何在“传送带”上流转的，我们也能够通过函数名去理解程序的意图。

**这样的代码，是声明式的。** 基于此构建出的数据流，就是**声明式的数据流**。

**实现声明式的数据流，除了借助链式调用，还可以借助函数组合。**

  


## 链式调用的前提

链式调用虽然牛，可它不是万金油。

map()、reduce()、filter() 这些方法之间，之所以能够进行链式调用，是因为：

1.  它们都**挂载在 Array 原型的 Array.prototype** 上
1.  它们在计算结束后都会 return 一个新的 Array
1.  既然 return 出来的也是 Array，那么自然可以继续访问原型 **Array.prototype** 上的方法

也就是说，链式调用是有前提的。

链式调用的本质 **，是通过在方法中返回对象实例本身的 this/ 与实例 this 相同类型的对象，达到多次调用其原型（链）上方法的目的。**

要对函数执行链式调用，**前提是函数挂载在一个靠谱的宿主 Object 上。**

 
>tips: 在函数式编程中，范畴论设计模式的编码形态也是以链式调用呈现的，关于这点，我们从[第17节](https://juejin.cn/book/7173591403639865377/section/7175422979646423098)开始会有详细的讲解。



  


那么对于那些没有挂载在对象上的函数（为了区分，下文称“独立函数”）来说，链式调用这条路显然走不通了，有没有其它的路子可以走呢？

## 独立函数的组合姿势：组合，但是回调地狱版

为了减少不必要的理解成本，这里我直接定义几个极简的独立函数，代码如下：

```js
function add4(num) {
  return num + 4
}  

function multiply3(num) {
  return num*3
}  

function divide2(num) {
  return num/2
}
```

问：如何基于这些独立函数，构建一个多个函数串行执行的工作流？

从朴素的视角出发，我们不难想到这样一个解法：



![47166E1B-D683-4105-9DF8-F4A8B2541E37.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66a6311c378f4ef783df7ec74d847ec0~tplv-k3u1fbpfcp-watermark.image?)    
多说无益，我直接贴出套娃代码：

```js
const sum =  add4(multiply3(divide2(num)))
```

套娃，顾名思义，就是把函数的执行结果套进下一个函数里作为入参，然后再把下一个函数的执行结果作为下下一个函数的执行结果作为入参......

也就是说**反复去嵌套各种回调函数**。

3个函数的套娃看上去似乎还没有那么可怕， 但数量稍微多一点，代码就变得有点面目全非了：

```js
const sum =  square(minus10(computeWithBonus(add4(muliply3(divide2(num))))))
```

问：有哪位家人可以一眼看出，这个套娃试图构建起来的是一个什么样的数据流？

讲真，即便我稍微改善一下这坨东西的排版，也无法掩盖它混乱不堪的事实：

```js
const sum = square(
  minus10(
    computeWithBonus(
      add4(
        multiply3(
          divide2(
            num
          )
        )
      )
    )
  )
)
```

区区 6 个函数的套娃，已经让人望而生畏了。

数量再多一点会怎样，我都不敢想了！（突然提高音量[○･｀Д´･ ○]）

在这场套娃灾难里，并不是只有读代码的人在受苦，写代码的人也一样抓狂。

好奇心重的同学可以试着在自己的编辑器里重现一遍套娃的过程：

首先，我写下了 `divide2(num)`；接着，我要把它作为入参传递给 `multiply3()`，也就是说我要先在 ` divide2(num)  `前面写上 "`multiply3(`"，然后再跑到 `divide2(num)` 后面写上 "`)`" ......

有多少层嵌套，就需要重复多少次这个过程。

当嵌套层级很深的时候，光是确认哪个括号对应哪个函数，就需要花上半天时间。

  


这场要命的套娃灾难，实际上有一个更贴切的名字，叫做“**回调地狱**”。

（此处强烈建议对这个名字感到陌生的年轻同学去搜索一下“回调地狱”这个关键词，你会学到许多有趣的前端黑历史）。

总之，为什么前端开发在 `Promise` 问世那天饱含泪水？

因为他们对回调地狱恨得深沉。

  


## 思考：如何摆脱回调地狱？

到这里，我们已经引出了函数组合的目标：组合多个独立函数，构造**声明式的数据流**。

过程中也拜访了隔壁 `OOP` 世界的成功人士：**链式调用**。

同时，我们也遇到了组合过程中的最大问题：套娃（AKA**回调地狱**）。

那么如何用魔法打败魔法，用函数式的姿势解决函数嵌套过深的问题呢？

这里先给大家一个小提示：关键字就是我们上节反复强调的 **reduce**。

我们将会在下一节讲解具体的解法。  
  
（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）