函数式编程是一门有着复杂数学背景的学问，它背靠的数学理论非常多，但在笔者看来，最关键的理论无外乎以下三个：

-   **Lambda 演算**
-   **组合子**
-   **范畴论**

接下来我们就展开聊聊这些理论的内涵，一起看看它们是如何被映射为实用的编码套路的。

## Lambda演算

**Lambda 演算是一种简洁的数学模型**，它涉及的概念包括变量绑定、α-转换、β-归约等等等等 **......** 这些理论别说大家没听说过，我自己看了也头大 **。** 所幸，Lambda 演算的核心概念经过扩展和演变，已经形成了我们今天在函数式编程中喜闻乐见的编码特性，其中最为核心两个特性分别是：

1.  **函数是一等公民**
1.  **匿名函数**

### “函数是一等公民”缘起何处？

#### Lambda 演算溯源

在前面的学习中，我们不止一次地解读和重申过“函数是一等公民”之于函数式编程的重要性。那么，这么重要的特性到底是谁“发明”出来的呢？

其实，在追溯“函数是一等公民”的概念时，我们很难找到一个特定的作者或时间点。不过，我们倒是可以将其与 Lisp 语言的出现联系起来——**Lisp 是第一种将函数视为一等公民的编程语言**，而 Lisp 语言及其后继者们（如 Scheme 和 Clojure）都深受 Lambda 演算的影响，强调函数在计算过程中的重要性。

因此我们可以认为， **“函数是一等公民”是 Lambda 演算对函数式编程最重要的影响之一**。

#### Lambda 演算中的“函数是一等公民”

Lambda 演算的核心思想是：**所有的计算都是通过函数来表示的，没有其他基本构建块（如变量或对象）** ——就这个核心思想，已经充分体现了“函数是一等公民”的要义。

回到数学层面的应用上来看，Lambda 演算使用一种特殊的表示法（即 **Lambda 表达式**）来定义和应用函数。Lambda 表达式使用希腊字母 **λ（Lambda）** 作为一个前缀，表示我们正在**定义一个抽象函数**。

我们可以使用 λx 表示一个关于变量 x 的抽象函数，并且可以在 λ 后面跟上一个表达式来表示函数体。举个例子，λx.(x + 1)  就表示一个将输入的数值加1的抽象函数。

当将一个参数应用于一个 Lambda 函数时，我们只需将参数放在函数后面，用空格隔开。举个例子，(λx.(x + 1)) 2 表示给我们之前定义的抽象函数传入一个值为2的参数，其对应的计算结果为3。

在 Lambda 计算中，我们只能够像上面这样，**定义和应用函数**，**使用函数来表达所有的计算**，**而不能够定义和应用函数之外的任何构建块**。

Lambda 运算中的函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。

因此，**Lambda 演算中不存在其他数据类型或结构（如变量、对象等），所有计算都是通过函数及其组合来表示的。这，就是“函数是一等公民”在数学世界的内涵。**

#### “函数是一等公民”背景下的数学应用

基于“函数是一等公民”这一内涵，Lambda 运算能够支持非常多样化的函数应用方式。高阶函数和函数组合是其中最经典的 case：

1.  **高阶函数**：它的数学背景可以映射到“Lambda 演算中的函数可以接受其他函数作为参数”这一点。例如，我们可以定义一个函数 λf.λx.(f (f x))，它接受一个函数 f 作为参数，并将函数 f 应用两次于参数 x。现在我们可以将之前定义的 λx.(x + 1) 函数作为参数传递给这个高阶函数：(λf.λx.(f (f x))) (λx.(x + 1))。这将产生一个新的函数，将输入值加 2。
1.  **函数组合**：在 Lambda 演算中，我们可以通过函数组合来构建更复杂的计算。例如，我们可以将两个函数 f 和 g 组合成一个新函数 λx.(f (g x))：给定函数 f = λx.(x + 1) 和 g = λx.(x * 2) *，* 我们可以创建一个新函数 λx.((x * 2) + 1)，它会先将输入值乘以 2，然后加 1。

通过这两个示例，我们可以看出，在 Lambda 演算中，函数确实是所有计算和操作的核心 **。作为一等公民，函数可以像其他值一样被传递、组合和操作，实现高度抽象和灵活的计算模型。**

总结一下：**函数式编程背靠 Lambda 演算，沿用了“函数是一等公民”这一核心原则，这一原则恰恰就是我们将高阶函数、函数组合等数学技巧转化为编码实践的理论背景。**

### 匿名函数

相比于“函数是一等公民”的抽象理念，“匿名函数”是一个更具体、更好理解的东西。

顾名思义，“匿名函数”当然就是没有名字的函数。在 Lambda 演算中，**匿名函数指的其实就是 Lambda 表达式**。在我们楼上的示例中，函数组合中的 f = λx.(x + 1)  和 g = λx.(x * 2) 都是具名函数。但如果我们把 f、g 这两个名字拿掉，那么 λx.(x + 1)  和 λx.(x * 2)  这两个函数就都是匿名函数了。

在编程语言（如 JavaScript）中，匿名函数的内涵仍然是“没有名字”这么简单。例如，我们可以像这样创建一个没有名称的匿名函数：

```js
function(x) { return x + 1 }
```

或者使用 ES6 的箭头函数语法创建一个匿名函数：

```js
(x) => x + 1
```

匿名函数看似是一个非常小的知识点，但它在函数式编程中的应用其实是非常广泛的。

匿名函数可以使代码看起来更简洁，尤其是在某些场景下（例如传递一个小型函数作为参数、或者创建一个立即执行函数来限制作用域等），匿名函数的应用尤为普遍。

当然啦，这并不是说具名函数不能实现这样的功能，只是说在这些情况下，使用匿名函数可以让代码更简洁。

## 组合子

组合子在数学中是一种特殊类型的函数，它只依赖于它的输入参数，而不依赖于外部环境或内部状态。**组合子的主要作用是将其他函数或参数组合在一起，产生新的函数或结果。**

#### 数学中的组合子

两个典型的组合子例子是 "S" 和 "K" 组合子。这里给出它们的定义：

1.  K 组合子：`Kxy = x`
1.  S 组合子：`Sxyz = xz(yz)`

首先，我们来看 K 组合子。它是一个接受两个参数的函数，总是返回第一个参数。如下面的表达式所示：

`K(3, 5) = 3`

S 组合子稍微复杂一些。它接受三个参数 x、y 和 z，并将 z 应用于 x 和 y，然后将 x 和 y 的结果相互应用。如下面的表达式所示：

`S(f, g, x) = f(x)(g(x))`

在这个表达式里，f 和 g 是函数，x 是任意输入。S 组合子将 x 传递给 f 和 g，然后将 g 的结果传递给 f。

从 K 组合子的设定，我们可以注意到，数学中的组合子并不仅仅是用来组合函数的，它也可以用来组合参数。然而，**在函数式编程的实际应用中，组合子的主要用途确实就是组合函数**。

#### `compose`组合子

在 JavaScript 中，我们完全可以将数学中的组合子编码化，然后用这些组合子来实现对函数的加工和组合。下面是对 S、B、C 几个数学组合子编码化的例子：

```js
// 组合子 S，接受三个参数f、g和x，返回f(x)(g(x))
const S = (f, g, x) => f(x)(g(x))  

// 组合子 B，接受三个参数f、g和x，返回f(g(x))
const B = (f, g, x) => f(g(x))

// 组合子 C，接受一个参数f，返回一个函数，该函数接受两个参数x和y，返回f(y)(x)
const C = f => x => y => f(y)(x)
```

在这个例子中，我们定义了组合子函数 S、B 和 C，它们分别对应于 Lambda 演算中的 S、B 和 C 组合子。这些组合子能够实现几种不同方式的函数复合。其中 B 组合子最为经典，有心的同学可以看出来，它其实就是我们在 21 节曾经实现过的“compose 的最小单元函数”。

**通过嵌套地调用 B 组合子，我们可以实现任意多个函数的组合，这恰恰就是函数式编程中`compose` 函数的内涵**。

也就是说，我们完全可以把 `compose`函数可以看作是基于 B 组合子派生出来的一个组合子——没错，`compose`**就是一个组合子**。

除了 `compose` 组合子之外，在 JavaScript 函数式编程中，还有一些其他常见的组合子可以使用。下面我将分别介绍这些组合子的使用方法和代码实现。

#### `pipe` 组合子

与 `compose` 组合子类似，`pipe` 组合子也可以将多个函数组合成一个新函数。不同的是，`pipe` 组合子的函数组合顺序是从左到右，而 `compose` 组合子的函数组合顺序是从右到左。   

```js
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x)

const addOne = x => x + 1
const double = x => x * 2
const addOneThenDouble = pipe(addOne, double)

// 输出: 8
console.log(addOneThenDouble(3))
```

在这个例子中，我们定义了一个 `pipe` 组合子，它接受多个函数作为参数，并返回一个新的函数。这个新函数的行为是将输入值依次传递给这些函数，然后将最终的结果返回。

我们还定义了两个简单的函数 `addOne` 和 `double`，然后使用 `pipe` 创建了一个新的函数 `addOneThenDouble`，它将输入值加 1，然后将结果乘以 2。与 `compose` 相反，`pipe` 的函数组合顺序是从左到右。  
> 注：pipe 和 compose 的推导过程，在[第14节](https://juejin.cn/book/7173591403639865377/section/7175422922192846907)有详尽的分析，此处仅作复习，不多赘述。

#### `curry` 组合子

`curry` 组合子可以将一个多参数函数转化为一系列嵌套的单参数函数。下面是一个 `curry` 组合子的例子：

```js
// curry 函数借助 Function.length 读取函数元数
function curry(func, arity=func.length) {
  // 定义一个递归式 generateCurried
  function generateCurried(prevArgs) {
    // generateCurried 函数必定返回一层嵌套
    return function curried(nextArg) {
      // 统计目前“已记忆”+“未记忆”的参数
      const args = [...prevArgs, nextArg]  
      // 若 “已记忆”+“未记忆”的参数数量 >= 回调函数元数，则认为已经记忆了所有的参数
      if(args.length >= arity) {
        // 触碰递归边界，传入所有参数，调用回调函数
        return func(...args)
      } else {
        // 未触碰递归边界，则递归调用 generateCurried 自身，创造新一层的嵌套
        return generateCurried(args)
      }
    }
  }
  // 调用 generateCurried，起始传参为空数组，表示“目前还没有记住任何参数”
  return generateCurried([])
}

const add = (a, b) => a + b
const curriedAdd = curry(add)

// 3
console.log(curriedAdd(1)(2))
```

在这个例子中，我们定义了一个 `curry` 组合子，它接受一个多参数函数作为参数，并返回一个新的函数。

我们还定义了一个简单的函数 `add`，然后使用 `curry` 创建了一个新的函数 `curriedAdd`。通过使用 `curriedAdd`，我们可以将 `add` 函数转化为一系列单参数函数的组合形式，从而使其更容易被组合和复用。  
> 注：curry 的推导过程，在[第16节](https://juejin.cn/book/7173591403639865377/section/7175422948306583611)有详尽的分析，此处仅作复习，不多赘述。

#### `flip` 组合子  

`flip` 组合子可以将一个多参数函数的参数顺序翻转。下面代码是一个 `flip` 组合子的例子：

```js
const flip = fn => (a, b, ...args) => fn(b, a, ...args)

const subtract = (a, b) => a - b
const flippedSubtract = flip(subtract)

// 输出：2
console.log(flippedSubtract(3, 5))
```

在这个例子中，我们定义了一个 `flip` 组合子，它接受一个多参数函数作为参数，并返回一个新的函数。这个新函数的行为是：将原函数的前两个参数顺序翻转，然后将剩余的参数传递给原函数。

我们还定义了一个简单的函数 `subtract`，然后使用 `flip` 创建了一个新的函数 `flippedSubtract`。通过使用 `flippedSubtract`，我们可以将 `subtract` 函数的参数顺序翻转，从而使其更容易被组合和复用。

### 补充：组合子与纯函数的辨析

最后，让我们来回顾一下组合子的定义：组合子在数学中是一种特殊类型的函数，它只依赖于它的输入参数，而不依赖于外部环境或内部状态。

单看这个定义的话，你可能很容易联想到函数式编程中的另一个重要概念——纯函数。

确实，组合子和纯函数在定义上都强调了函数的纯度。但在实际的编程实践中，组合子主要关注**函数操作和组合**，而纯函数关注无副作用和相同输入产生相同输出；**组合子通常具有纯函数的特性，但并非所有纯函数都是组合子**。

## 程序世界的范畴理论

在本书的 [17](<https://juejin.cn/book/7173591403639865377/section/7175422979646423098>)-[21 节](<https://juejin.cn/book/7173591403639865377/section/7175421412075634725>)，我们系统地学习了范畴论中的核心实践方法。作为函数式编程中的关键数学依据，我们在本节仍然有必要对范畴论作整体的回顾和总结。

### 当我们谈论范畴论时，我们在谈论什么

对于本书来说， [17](<https://juejin.cn/book/7173591403639865377/section/7175422979646423098>)-[21 节](<https://juejin.cn/book/7173591403639865377/section/7175421412075634725>)是相对独立的一块内容。一些同学反馈说从 17 节开始就“顶不住了”，这其实也是非常正常的现象。并不是因为你不行，而是因为范畴理论本身的学习曲线就非常陡峭，它涉及更高层次的抽象和复杂的数学概念。

但正如我在小册开篇（第1节）和第17节中反复强调的，对于复杂的数学理论，我们不必执着于理论本身，而是应该**从代码去推导数学**。

具体来说，Functor 听上去是一个唬人的新名词，但数组 `Array` 至少算是你的老朋友了；Monad 看上去面目有些狰狞，但 `RxJS` 可是我们做状态管理的好帮手；Semigroup 和 Monoid 太抽象，那么 `compose` 总不算抽象吧。

**细看之下，这些晦涩的名词包裹的其实仍然是一些非常实用的编程方法和实践模式。很多时候，劝退大家的并不是理论本身，而是一种“这个东西好陌生“带来的疏离感。**

当我们在函数式编程的语境中谈论范畴论时，数学理论本身是最不重要的一个部分。我希望所有在 17-21 节被理论知识劝退过的朋友，都能重新打开这几节，好好琢磨一下其中的代码示例。很多时候，只要你理解了代码的内涵，理论的问题就会迎刃而解了。

### 从范畴论到 JS 函数式编程实践

在 JavaScript 函数式编程中，范畴论的实践主要体现在对 Functor、Monad、Semigroup 和 Monoid 这四种结构的应用。下面我将结合具体的代码，和大家一起对这四种结构的特征进行回顾。

#### Functor（函子）

Functor 是一个实现了 `map` 方法的容器。`map` 方法接收一个函数 `f`，并将 `f` 应用于容器中的值。Functor 可以帮助我们将普通函数应用于特定的容器，如数组、对象等。在 JS 函数式编程中，数组是最常见的 Functor：

```js
const double = x => x * 2
 // 结果是 [2, 4, 6]
const result = [1, 2, 3].map(double)
```

#### Monad（单子）

Monad 是一个特殊的 Functor，它提供了一种将值装入容器的方法（通常称为 `of` 或 `unit`），以及一种将嵌套的容器扁平化的方法（通常称为 `flatMap` 、`bind`、`join` 或 `chain` 等）。

常见的 Monad 示例除了嵌套盒子计算、`RxJS` 中 `Observable` 盒子之外，还有 `Task`—— `Task`  也是非常经典的对副作用的封装，下面是一个使用 `Task` Monad 处理异步操作的示例，注释中包含了对 `Task` Monad 实现思路的解读：

```js
// Task Monad 构造函数
const Task = run => ({
  run,
  // map 方法：接收一个函数 f，并将其应用于 Task Monad 包装的值，返回一个新的 Task Monad
  map: f => Task((resolve, reject) => run(value => resolve(f(value)), reject)),
  // flatMap 方法：接收一个函数 f，并将其应用于 Task Monad 包装的值，
  // f 返回一个新的 Task Monad 实例
  flatMap: f => Task((resolve, reject) => run(value => f(value).run(resolve, reject), reject)),
  // fork 方法：开始执行 Task Monad，并根据结果执行成功或失败的回调函数
  fork: (resolve, reject) => run(resolve, reject)
})

// 创建一个包含值的 Task 实例
Task.of = value => Task((resolve) => resolve(value))

// 封装一个返回 Task Monad 实例的异步请求函数
const fetchUrl = url => Task((resolve, reject) => {
  fetch(url)
    .then(response => response.json())
    .then(data => resolve(data))
    .catch(error => reject(error))
})

// 模拟获取用户基本信息的函数，异步
const getUser = id => Task((resolve, reject) => {
  setTimeout(() => {
    resolve({id: id, name: 'Xiu Yan'})
  }, 1000)
})

// 模拟获取用户职业的函数，异步
const getJob = user => Task((resolve, reject) => {
  setTimeout(() => {
    if (user.id === 1) {
      resolve('programmer')
    } else {
      reject('Job not found')
    }
  }, 1000)
})

const userId = 1

// 使用 flatMap 实现链式异步操作
getUser(userId)
  .flatMap(user => getJob(user))
  .fork(
    // 成功回调：输出获取到的工作信息
    job => console.log('Job:', job),
    // 失败回调：输出错误信息
    error => console.error('Error:', error)
  )
```

#### Semigroup（半群）

Semigroup 是一种具有关联性二元运算的集合，它的代表方法是 `concat()`。在 JS 函数式编程中，常见的 Semigroup 包括字符串、数组等。这些数据类型都有一个具有关联性的二元运算（例如，字符串的拼接和数组的合并）。下面是一个字符串 Semigroup 的实现实例：

```js
// 定义一个字符串 Semigroup
const StringSemigroup = s1 => ({
  value: s1,
  concat: s2 => StringSemigroup(s1 + s2.value)
})

// 创建两个字符串 Semigroup
const str1 = StringSemigroup('Hello, ')
const str2 = StringSemigroup('world!')  

// 拼接字符串
const str3 = str1.concat(str2);

// 输出："Hello, world!"
console.log(str3.value)
```

#### Monoid（幺半群）

Monoid 是一个特殊的 Semigroup，它的代表方法除了 `concat()` ，还有`empty()`（单位元）。单位元与任何其他元素结合进行运算时，结果都保持不变。以下是一个简单的 Monoid 示例，它展示了数组的求和过程，这个示例足以体现特定场景下单位元的重要性：

```js
// 将一个值映射为一个 Sum Monoid
const Sum = (value) => ({
  value,
  concat: (other) => Sum(value + other.value)
})

// 单位元：数字 0
Sum.empty = () => Sum(0)

// foldMap 实现
const foldMap = (f, list) => 
                  list.map(f).reduce((acc, x) => acc.concat(x), f.empty())

// 使用 foldMap 计算数组元素之和
const array = [1, 2, 3, 4, 5]
const sumArray = (arr) => foldMap(Sum, arr).value

// 输出: 15
console.log(sumArray(array)) 
// 输出: 0
console.log(sumArray([]))
```

在函数式编程实践中，这四种结构都非常重要。它们帮助开发者以更加抽象和通用的方式处理各种操作和数据结构，从而简化代码、提高代码的可读性和可维护性。同时，它们在一定程度上也促进了代码的模块化和复用。

## 小结

本节，我们回溯分析了函数式编程中的三种主要数学理论。这个过程既加深了我们对这些数学理论的理解，也让我们从全新的视角重新串联了各种已学知识。

事实上，无论是编程语言的特性还是数学理论，它们最终的效用都是为了更好地支持软件开发和前端工程实践。

在前端工程实践中，函数式编程已经变得越来越受欢迎。许多现代前端框架/库都倾向于采用函数式编程的原则。这些框架/库包括但不限于我们已经讨论过的 React、Redux、RxJS 等等。下一节，我们就将放眼整个前端生态，对生产级别的函数式编程实践做一个整体的分析和总结。