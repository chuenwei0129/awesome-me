---
group:
  title: JavaScript
title: GC
toc: content
---

不要沉溺在“我看懂了”、“我理解了”、“我知道你说的是啥意思了”这种虚无的成就感中——假的，都是假的，只有自己写出来的代码才是真的！

产品部提出了很多新需求，开发部需要响应——这叫高吞吐量。开发部多招几个人响应需求——这叫多核多线程并行处理。开发部没条件招新人，于是 Leader 老张要求开发小王周一上午处理 A 需求，下午处理 B 需求（没做完的 A 需求先搁置），周二上午处理 C 需求，周二下午处理 A 需求后续，如此循环……——这叫单核多线程分时复用

历史上单核多线程比多处理器/多核系统更早出现，毕竟当年打不起这么富余的仗。

小王的 Leader 换成了老刘，老刘不规定小王的工作排期，但是开发部的需求 A、B、C 却会直接分配到小王头上，小王需要自己安排工作时间分配——这叫用户态多任务。

如今这个层级通常被统称为「协程」

小王回想起老张给他安排工作的模式，依样画葫芦把工作时间划分成时间片，用于轮番响应不同需求——这叫抢占式用户态线程，即纤程 (fiber)，又称有栈协程。

作者：李晟显
链接：https://www.zhihu.com/question/553280714/answer/3573527248
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Goroutine 即属于此类小王认为按照老张的模式，脑子需要经常被动地在未完成的任务之间切换，效率不理想。于是他决定以需求内容为本，做完 A 需求的开发再去着手于 B 需求——这可以看作对并发任务重新建模。采用这种模式需要对业务逻辑（即控制流）进行重构进行 A 需求开发的过程中，经常需要等待其它部门配合。小王认为在等待 A 需求相关部门配合的时间段内，自己可以转而进行 B 需求的开发——这就是典型的异步并发建模针对的场景相对于之前提到的抢占式调度，这种则称为协作式调度因为切换开发任务时总是处于告一段落的状态，所以脑子切换工作状态的压力也更小——这就是相对于「有栈协程」的「无栈协程」需求 A 开发到一半，需要新增美工素材，美工小赵让小王等他把图画完；小王让小赵画完图之后戳他——这是异步运行时建模中的通知机制。产品部只管走流程布置需求任务，什么时候开工由小王决定——需求任务对应 Rust 中的 Future，而产品部对应于调用处(Call site)，小王对应于运行时(Runtime)。小王只在有空的时候才跟产品部沟通需求，需求沟通完立刻开工——需求任务对应 JS 中的 Promise，而产品部对应于调用处，小王对应于 JS 运行时。
