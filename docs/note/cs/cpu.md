---
title: CPU 的奥秘
toc: content
order: -1
group:
  title: 计算机组成原理
  order: 0
---

## CPU 是怎么设计与实现的？

> [你管这破玩意叫 CPU？](https://zhuanlan.zhihu.com/p/367927405)

## 硬件还是软件？

尽管我们可以用 AND、OR、NOT 表达出所有的逻辑函数，但我们真的有必要把所有的逻辑运算都用与或非门实现出来吗？这显然是不现实的。

**我们没有必要为所有的计算逻辑实现出对应的硬件，硬件只需要提供最基本的功能，最终所有的计算逻辑都通过这些最基本的功能用软件表达出来就好**，这就是所谓的软件一词的来源，硬件不可变，但软件可变，不变的是硬件但提供不同的软件就能让硬件实现全新的功能，无比天才的思想。

## 指令

CPU 怎样才能知道要执行哪种操作，比如加法运算，并且知道要对哪两个数进行计算呢？

答案很简单：我们需要告诉 CPU。但如何告诉它呢？就像人需要说明书来学习新设备的操作一样，CPU 也需要一套指令来指导其下一步行动。这就是机器指令的角色。

然而，显而易见的问题是，指令的种类可能非常多。以加法为例，我们可以指示 CPU 执行 `1+1`，也可以是 `1+2`，等等。显然，CPU 不可能内置所有可能的指令。实际上，CPU 只需**提供加法这个操作**，我们通过指令告诉它具体的**操作数**即可。

因此，CPU 的操作机制是通过一套称为指令集的编码来实现的。指令集定义了 CPU 可以理解和执行的所有操作，从而使得复杂的程序可以通过一系列基础指令来控制 CPU 的行为。

### 复杂指令集 CISC 和精简指令集 RISC

> 不知道什么原因，特别喜欢精简指令集的设计哲学。就像写代码就要像堆积木一样。RISC 就是用多个小方法互相调用完成复杂的功能，CISC 则是专门写一个大方法完成复杂的功能。

- [你管这破玩意叫精简指令集？](https://zhuanlan.zhihu.com/p/384606064)
- [你管这破玩意叫复杂指令集？](https://zhuanlan.zhihu.com/p/375844125)

### 指令的执行速度

> [a = 1 + 2 执行具体过程](https://xiaolincoding.com/os/1_hardware/how_cpu_run.html#a-1-2-%E6%89%A7%E8%A1%8C%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B)

## 计算机系统 64 位、32 位指的是什么？

> [CPU 是如何执行程序的？](https://xiaolincoding.com/os/1_hardware/how_cpu_run.html#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8)

## CPU 的 4 核 8 线程什么意思？

那是 CPU 说你可以把我认为有 8 个独立工作的单核 CPU 的意思，4 核代表我真的由 4 个可以实际独立工作的单核 CPU 组成，8 线程代表 CPU 说你可以把我认为我是由 8 个可以独立工作的单核 CPU，但是实际上多出来 4 个是我一个人干两个人的活，用的时候小心一点。

## [多核 CPU 和多个 CPU 有何区别？](https://zhuanlan.zhihu.com/p/85819786)

多核 CPU 和多 Die 乃至多路 CPU，**对操作系统等来看，区别不大，BIOS 都报告了同样多的很多 CPU 供他们调度**。区别主要在于性能 (_数据流和指令流的交流，越方便性能越好_) 上面，**多核 CPU 性能最好**，但成本最高；多 CPU 成本小，便宜，但性能相对较差。

## 磁盘比内存慢几万倍？

![20240409165038](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240409165038.png)

各种存储器之间的关系，可以用我们在图书馆学习这个场景来理解。

CPU 可以比喻成我们的大脑，我们当前正在思考和处理的知识的过程，就好比 CPU 中的寄存器处理数据的过程，速度极快，但是容量很小。而 CPU 中的 L1-L3 Cache 好比我们大脑中的短期记忆和长期记忆，需要小小花费点时间来调取数据并处理。

我们面前的桌子就相当于内存，能放下更多的书 (数据)，但是找起来和看起来就要花费一些时间，相比 CPU Cache 慢不少。而图书馆的书架相当于硬盘，能放下比内存更多的数据，但找起来就更费时间了，可以说是最慢的存储器设备了。

从寄存器、CPU Cache，到内存、硬盘，这样一层层下来的存储器，访问速度越来越慢，存储容量越来越大，价格也越来越便宜，而且每个存储器只和相邻的一层存储器设备打交道，于是这样就形成了存储器的层次结构。

## [如何写出让 CPU 跑得更快的代码？](https://xiaolincoding.com/os/1_hardware/how_to_make_cpu_run_faster.html)

要想写出让 CPU 跑得更快的代码，就需要写出缓存命中率高的代码，CPU L1 Cache 分为数据缓存和指令缓存，因而需要分别提高它们的缓存命中率：

1. 对于数据缓存，我们在遍历数据的时候，应该按照内存布局的顺序操作，这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升；

2. 对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率；

3. 另外，对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高线程的缓存命中率，可以考虑把线程绑定 CPU 到某一个 CPU 核心。

## [什么是软中断？](https://xiaolincoding.com/os/1_hardware/soft_interrupt.html)

### 中断

我中午搬完砖，肚子饿了，点了份白切鸡外卖。虽然平台上会显示配送进度，但是我也不能一直傻傻地盯着呀，时间很宝贵，当然得去干别的事情，等外卖到了配送员会通过 “电话” 通知我，电话响了，我就会停下手中地事情，去拿外卖。

这里的打电话，其实就是对应计算机里的中断，没接到电话的时候，我可以做其他的事情，只有接到了电话，也就是发生中断，我才会停下当前的事情，去进行另一个事情，也就是拿外卖。

操作系统收到了中断请求，会打断其他进程的运行，所以中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。

而且，中断处理程序在响应中断时，可能还会 “临时关闭中断”，这意味着，如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以中断处理程序要短且快。

还是回到外卖的例子，我到了晚上又点起了外卖，这次为了犒劳自己，共点了两份外卖，一份小龙虾和一份奶茶，并且是由不同地配送员来配送，那么问题来了，当第一份外卖送到时，配送员给我打了长长的电话，说了一些杂七杂八的事情，比如给个好评等等，但如果这时另一位配送员也想给我打电话。

很明显，这时第二位配送员因为我在通话中 (相当于关闭了中断响应)，自然就无法打通我的电话，他可能尝试了几次后就走掉了 (相当于丢失了一次中断)。

### 软中断

那 Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是 “上半部和下半部分”。

- 上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。
- 下半部用来延迟处理上半部未完成的工作，一般以 “内核线程” 的方式运行。

前面的外卖例子，由于第一个配送员长时间跟我通话，则导致第二位配送员无法拨通我的电话，其实当我接到第一位配送员的电话，可以告诉配送员说我现在下楼，剩下的事情，等我们见面再说 (上半部)，然后就可以挂断电话，到楼下后，在拿外卖，以及跟配送员说其他的事情 (下半部)。

这样，第一位配送员就不会占用我手机太多时间，当第二位配送员正好过来时，会有很大几率拨通我的电话。

## [计算机是如何启动的？](https://www.zhihu.com/question/40831686)

CPU 的工作就是不断读取指令，然后执行这些指令。

写一段 CPU 能读的程序，加电后，让它去初始化其它硬件，去使用其它硬件。

从最低级的操作硬件的程序读起，逐渐高级，直到普通程序。

## [CPU 空闲时在干嘛？](https://zhuanlan.zhihu.com/p/356447262)

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220418-eaz.png)

## [CPU 内部各个部件的时延大概是多少？(皮秒，纳秒)？](https://www.zhihu.com/question/488790905)

![20240409233306](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240409233306.png)

## [shell、操作系统、内核是一个东西吗？](https://www.zhihu.com/question/37695460)

操作系统：包括操作系统内核、shell、驱动、运行库、引导程序等各种东西都是操作系统的一部分。对于 Windows 来说，大部分 Windows 目录下的东西都属于操作系统的一部分。对于 Linux 来说，/lib，/boot 下的大多数东西都属于操作系统。

内核：操作系统最核心的部分，一般来说，内核特指某一个或者几个文件。对于 Windows 来说，内核文件是\Windows\system32\NTOSKRNL.EXE 对于 Linux 来说，是内核镜像，一般在 boot 下面，具体是哪个要看配置情况。

Shell (外壳)：一般是指跟用户直接交互的界面，可以是命令行，也可以是窗口，用户通过 shell 访问并控制计算机。对于 Windows 来说，Shell 应该是资源管理器 (也就是我的电脑)。对于 Linux 来说，就是命令行。

一个操作系统的 Shell 可以被替换，Linux 也可以搞图形界面，Windows 也可以自定义 Shell (方法比较麻烦)。所以 Shell 和内核都是操作系统的一部分，Shell 是你能看见的部分，内核是最核心的部分 (一般情况下也看不见)，操作系统本身规模最大的应该是驱动和各种支撑库，Shell 和内核只占一小部分。

对于内核的架构一般有这三种类型：

- 宏内核，包含多个模块，整个内核像一个完整的程序；
- 微内核，有一个最小版本的内核，一些模块和服务则由用户态管理；
- 混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；

Linux 的内核设计是采用了宏内核，Window 的内核设计则是采用了混合内核。

## [编程语言](https://www.zhihu.com/question/268303059)

语言是用来写代码的，代码是给人看的。

计算机只看得懂程序 (`01010101`)，看不懂代码。

把代码变成程序有两个常用的方法：

1. 把所有的代码变成程序，再执行。**即，先编译再执行**。
2. 把一丢丢代码变成一丢丢程序执行，然后再把一丢丢代码变成一丢丢程序执行，...。**即，边解释边执行**。

谁来编译？谁来解释？谁来执行？

- **编译型**：编译器来编译，系统执行。
- **解释型**：解释器解释并执行。

举个例子 🌰：

你女网友只懂中文 (源代码)，你只懂英文 (机器码 / CPU 指令)，现在你俩要搞对象，怎么办？

女网友写下了自己的：`要求.py`：

```py
二号男嘉宾
我要吃好的
我要穿好的
我要住好的
我不会做饭
我不会家务
我脾气不好
```

由于你们语言不通，直接是无法交流的，所以必须要有一个翻译官 (python 解释器)

1. **解释器的执行流程**

   ```py
   二号男嘉宾 => SLOT #2
   我要吃好的 => FOOD +10W
   我要穿好的 => DRESS + 10W
   我要住好的 => HOUSE + 100W
   我不会做饭 => ELEME + 7W
   我不会家务 => BABYSITTER + 3W
   我脾气不好 => PSYCHOLOGIST + 10W
   ```

   翻译官将中文翻译成了你能懂的英文 (CPU 指令)，这是你的执行流程：

   ```py
   SLOT #2 => ACK
   FOOD +10W => +10W
   DRESS + 10W => +10W
   HOUSE + 100W => +100W
   ELEME + 7W => +7W
   BABYSITTER + 3W => +3W
   PSYCHOLOGIST + 10W => +10W
   ```

   **每接到一次指令，你就去 `ATM` 取一次钱，一共需要取 `6` 次钱；**

   然后你将继续等待对方开出的条件，进入 `Idle` 状态，直到翻译将新的指令给你，直到条件开完毕，而你又能一直从 `ATM` 里面取出钱来，然后你们就幸福的在一起了。

2. **`JIT` 优化**

   你应该看出来了，`Python` 解释器 (翻译官) 每次传递一行指令，但要求其实都差不多，所以 `JIT` 这时候就派上用场了，**第一次的过程其实是一样的**，但是你的女网友发现你没有回复她的时候，又说了一遍，还说了第三遍，这个时候如果有 `JIT` (比如 `Pypy`)，那么从第二次开始，翻译官给你的就不再是一行一行的指令了，而是：

   ```py
   +10W + 10W + 100W + 7W + 3W + 10W
   ```

   **这时候，你只需要去一次 `ATM`，一次性取出需要的这些钱，你们就能幸福的在一起了。**

   > [JIT 即时编译的原理](https://zhuanlan.zhihu.com/p/46917559)

3. **顺提一下编译型**

   就是翻译官 (此处应该叫编译官) 把**你女网友的** `要求.py` 直接重新找了一张 `A4` 纸，上面写着：

   ```py
   $$
   ```

   这样每次你女网友拿着这张纸到 `x86` 窗口的 `ATM` 直接就能办理了，**注意，仅此窗口，别家店不可以用的**，咦，好像少了什么人？也是，如果都能直接跟 `ATM` 沟通了，谁还需要男盆友呢？

4. **性能**

   因为解释型语言在编译的时候只是编译成了字节码，运行的时候，还需要解释器挨个把字节码翻译成机器语言才能执行。

   相当于你写的程序，每次都要先 “编译”，再运行，运行速度必然比只需要运行不需要编译的编译型语言慢。

   <!-- javascript 运行时确定类型 -->

   `JavaScript` 是一种动态类型语言，在编译时并不能准确知道变量的类型，只可以在运行时确定，这就不像 `c++` 或者 `java` 等静态类型语言，在编译时候就可以确切知道变量的类型。然而，在运行时计算和决定类型，会严重影响语言性能，这也就是 `JavaScript` 运行效率比 `C++` 或者 `JAVA` 低很多的原因之一。
