---
title: 进程、线程、协程
toc: content
order: 0
group:
  title: 操作系统
---

## 进程

当你的代码变成一个可执行文件并启动时，它在内存中活动起来，由 CPU 逐条执行指令。这个活动中的实体，我们称之为 “进程”。

## 进程管理

现在我们考虑有一个会读取硬盘文件数据的程序被执行了，那么当运行到读取文件的指令时，就会去从硬盘读取数据，但是硬盘的读写速度是非常慢的，那么在这个时候，如果 CPU 傻傻的等硬盘返回数据的话，那 CPU 的利用率是非常低的。

![20240409215917](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240409215917.png)

所以，当进程要从硬盘读取数据时，CPU 不需要阻塞等待数据的返回，而是去执行另外的进程。当硬盘数据返回时，CPU 会收到个中断，于是 CPU 再继续运行这个进程。

这种多个程序、交替执行的思想，就有 CPU 管理多个进程的初步想法。

对于一个支持多进程的系统，CPU 会从一个进程快速切换至另一个进程，其间每个进程各运行几十或几百个毫秒。

虽然单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生并行的错觉，实际上这是并发。

## 并发和并行有什么区别？

![20240409215732](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240409215732.png)

## [进程的状态](https://xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81)

![20240409220208](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240409220208.png)

## CPU 的上下文切换

大多数操作系统都是多任务，通常支持大于 CPU 数量的任务同时运行。

任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。

所以，操作系统需要事先帮 CPU 设置好 CPU 寄存器和程序计数器。

CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。

CPU 上下文切换就是先把前一个任务的 CPU 上下文 (CPU 寄存器和程序计数器) 保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

上面说到所谓的 “任务”，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。

## 进程的上下文切换

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

![20240409220807](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240409220807.png)

## 线程

线程是进程当中的一条执行流程。同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。

![20240409221104](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240409221104.png)

线程的优点：

- 一个进程中可以同时存在多个线程；
- 各个线程之间可以并发执行；
- 各个线程之间可以共享地址空间和文件等资源；

线程的缺点：

当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃 (这里是针对 C/C++ 语言，Java 语言中的线程奔溃不会造成进程崩溃)

## 线程与进程的比较

线程与进程的比较如下：

- 进程是资源 (包括内存、打开的文件等) 分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

对于，线程相比进程能减少开销，体现在：

- **线程的创建时间比进程快**，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
- **线程的终止时间比进程快**，因为线程释放的资源相比进程少很多；
- **同一个进程内的线程切换比进程切换快**，因为线程具有相同的地址空间 (虚拟内存共享)，这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
- **由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了**；

所以，不管是时间效率，还是空间效率线程比进程都要高。

## 线程的上下文切换

> 当进程只有一个线程时，可以认为进程就等于线程。

这还得看线程是不是属于同一个进程：

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数。

## [有了线程，为什么还要有协程？](https://www.zhihu.com/question/504791946)

![20230304022053](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230304022053.png)

## [协程的好处有哪些？](https://www.zhihu.com/question/20511233)

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220418-fwh.png)
