---
title: 同源策略与 CORS
order: -1
toc: content
group:
  title: WEB
---

## 同源策略

同源策略是 Web 安全的基石，它用于限制一个源 (origin) 中加载的文档或脚本如何与另一个源的资源进行交互。这里的 “源” 指的是协议 (例如，http 或 https)、域名 (例如，`example.com`) 和端口 (例如，80 或 443) 的组合。**只有当两个资源的协议、域名和端口号完全相同时，它们才被认为是 “同源” 的。**

### 为什么需要同源策略？

同源策略的主要目的是提供一种安全机制，防止恶意网站读取或操作另一个网站的敏感数据。没有同源策略的限制，恶意网站可以通过脚本来读取或操作其他网站的数据，这可能包括个人信息、登录状态和其他敏感信息，从而导致一系列的安全问题，如身份盗窃、信息泄露等。

### 同源策略的限制

同源策略主要限制了以下几种跨源访问：

1. **Web 内容的读取**：一个源的脚本不能读取或修改另一个源的文档内容。例如，通过 JavaScript 的 `XMLHttpRequest` 或 `Fetch API` 直接访问另一个源的数据是受限的。
2. **DOM 操作**：不能操作另一个源加载的页面的 DOM。
3. **Cookie、LocalStorage 和 IndexedDB**：不允许访问另一个源的数据存储。

> 跨源 HTTP 请求的一个例子：运行在 `https://domain-a.com` 的 JavaScript 代码使用 XMLHttpRequest 来发起一个到 `https://domain-b.com/data.json` 的请求。

### 同源策略与跨窗口通信

同源策略限制了不同来源的窗口或框架 (例如，网页的不同标签或内嵌 frame 页面) 之间的交互。这项策略的核心目的是保护用户信息免遭未经授权的访问和窃取。

想象一下，您同时打开了两个网页：一个是个人博客 `john-smith.com`，另一个是您的电子邮件服务 `gmail.com`。理想情况下，您不希望 `john-smith.com` 能够访问或读取 `gmail.com` 上的私人邮件。同源策略正是为了防止这种情况的发生，确保您的在线活动安全。

**同源策略规定：**

- 如果我们有对另外一个窗口 (例如，一个使用 `window.open` 创建的弹窗，或者一个窗口中的 iframe) 的引用，并且该窗口是同源的，那么我们就具有对该窗口的全部访问权限。
- 否则，如果该窗口不是同源的，那么我们就无法访问该窗口中的内容：变量，文档，任何东西。唯一的例外是 `location`：我们可以修改它 (进而重定向用户)。但是我们无法读取 `location` (因此，我们无法看到用户当前所处的位置，也就不会泄漏任何信息)。

#### 跨子域通信

在某些情况下，即使两个网页的一级域名相同，但由于它们位于不同的子域下，标准的同源策略仍然会阻止它们之间的直接通信。例如，`john.site.com` 和 `peter.site.com` 默认被视为不同的源。幸运的是，通过设置 `document.domain` 为共同的一级域名 (如 `site.com`)，这些页面可以被视为同源，从而允许它们之间自由通信：

```js
document.domain = 'site.com'
```

#### 使用 postMessage 进行安全通信

为了在保持安全的前提下实现不同源窗口间的通信，`postMessage` 方法提供了一种解决方案。它允许来自不同源的窗口安全地交换信息。无论窗口的原始来源如何，只要两边的代码都同意并正确实现了 `postMessage` 接口，就可以实现跨源通信，同时保护用户数据不被恶意访问。

### 跨源网络访问

严格来说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。

同源策略控制了不同源之间的交互，这些交互通常分为三类：

- ✅ 通常浏览器允许进行跨域**写操作** (Cross-origin writes)，如链接、重定向以及表单提交
- ✅ 通常浏览器允许跨域**资源嵌入** (Cross-origin embedding)，如 `img`、`script` 标签
- ❌ 通常浏览器不允许跨域**读操作** (Cross-origin reads)，但常可以通过内嵌资源来巧妙地进行读取访问。例如可以读取嵌套图片的高度和宽度，调用内嵌脚本的方法。

> ⚠️ 注意：HTML 中 `<link>`、`<script>`、`<img>` 等标签自带连接属性进行 HTTP 请求是能够无视同源策略的。

### 如何突破同源策略的限制？

尽管同源策略对于保障网站安全至关重要，但在现实开发中，经常需要进行跨域资源共享 (Cross-Origin Resource Sharing，CORS)。为了安全地实现这一需求，现代浏览器实现了 CORS 机制，允许网站的服务器通过设置特定的 HTTP 响应头来明确允许某些跨源请求。

此外，还有其他技术和策略可以用于安全地绕过同源策略的限制，如使用 JSONP (仅限于 GET 请求)、WebSocket (WebSocket 没有跨源限制)、通过服务器端代理跨源请求 (Webpack Dev Server 与 Nginx 反向代理) 等。

## [跨源资源共享 (CORS)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)

### 什么是 CORS？

**跨源资源共享标准新增了一组 HTTP 标头字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源**。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法 (特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求)，浏览器必须首先使用 OPTIONS 方法发起一个预检请求 (preflight request)，从而获知服务端是否允许该跨源请求。

服务器确认允许之后，才发起实际的 HTTP 请求。**在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证 (例如 Cookie 和 HTTP 认证相关数据)**。

CORS 请求失败会产生错误，但是为了安全，在 JavaScript 代码层面无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。

### CORS 预请求 (Preflight Request)

预请求的目的是检查真实请求是否安全、是否被允许。

**简单请求的条件包括：**

- 使用 GET、HEAD 或 POST 方法 (注意，POST 请求的 `Content-Type` 只能是 `application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`)。
- 没有自定义请求头，只能使用 CORS 安全的首部字段集合 (如 `Accept`、`Accept-Language`、`Content-Language`、`Content-Type`)。

如果请求不符合上述条件，就会触发预请求。

**预请求中的响应头：**

- **`Access-Control-Allow-Origin`**：这个响应头指明了哪些来源可以访问该资源。出于安全考虑，这是必须的。如果服务器设置为特定域名，只有来自这个域名的请求才被允许；如果设置为 `*`，则表示允许任何域的请求。

- **`Access-Control-Allow-Methods`**：这个响应头在预请求的响应中指定了服务器支持的所有跨域请求方法。这是为了让客户端知道哪些 HTTP 请求方法是可以使用的。

- **`Access-Control-Allow-Headers`**：当请求中包含 `Access-Control-Request-Headers` 时，这个响应头就是必需的。它告诉浏览器服务器允许的头部字段，这样浏览器才会发送包含这些头部的请求。

- **`Access-Control-Max-Age`**：这个响应头可以减少预请求的次数。它告诉浏览器，在指定的时间内 (秒)，不需要再发送预请求来验证跨域请求。这可以减少请求的总数，提高应用性能。

- **`Access-Control-Allow-Credentials`**：在跨源资源共享 (CORS) 请求中，默认情况下，Cookie 和 HTTP 认证信息不会被发送。为了安全地将 Cookie 信息发送到服务器，需要满足两个条件：首先，服务器必须明确允许携带凭证的请求。这通过设置 `Access-Control-Allow-Credentials` 字段为 `true` 来实现。此外，`Access-Control-Allow-Origin` 字段不能设置为通配符 `*`，必须指定为一个确切且可信的域名。这一限制是基于安全考虑，因为与不携带凭证的请求相比，携带凭证的请求面临更高的安全风险。其次，开发者在发起 AJAX 请求时，必须启用 `withCredentials` 属性。如果未启用此属性，即使服务器配置允许发送 Cookie，浏览器也不会执行发送操作。同样，如果服务器设置了 Cookie，但未正确配置 CORS 凭证共享，浏览器同样不会处理这些 Cookie。值得注意的是，Cookie 遵循同源政策，这意味着只有当 Cookie 是由服务器域名设置时，它们才会被上传。来自其他域的 Cookie 将不会被包含在请求中。

通过正确设置这些响应头，服务器可以精细控制哪些跨域请求是被允许的，同时保持应用的安全性。这些设置通常在服务器端配置。

### 什么情况下需要 CORS？

- 由 XMLHttpRequest 或 Fetch API 发起的跨源 HTTP 请求。
- Web 字体 (CSS 中通过 @font-face 使用跨源字体资源)，因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。
- 使用 `drawImage()` 将图片或视频画面绘制到 canvas。
