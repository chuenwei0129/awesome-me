---
group:
  title: 2024
  order: -2024
title: 我的面试准备
toc: content
---

建议大家一定要把简历上所有提到的技术（或者实现的功能用到的技术）都能知道：

- 为啥用它（技术选型）
- 它的怎么做的（原理）
- 怎么用它更好（优化）

## 跨端

1. [WebView与APP交互实战记录](https://segmentfault.com/a/1190000018208609)
2. [关于小程序的一切，读这一篇就够了～](https://juejin.cn/post/7039162006464626718)
3. [React Native 新架构](https://zhuanlan.zhihu.com/p/281238593)
4. [React Native原理之跨端通信机制](https://zhuanlan.zhihu.com/p/473710695)
5. [小程序底层实现原理及一些思考](https://zhuanlan.zhihu.com/p/81775922)

### 浏览器

- [从一个 bug 中延伸出 canvas 最大内存限制和浏览器渲染原理](https://zhuanlan.zhihu.com/p/540761999)
经过一步步增加内存占用，试出了 Safari 的最大限制（4096MB）

结果是成功的，因此可以推断出 chrome 几乎没有对 canvas 做内存限制，只要设备内存够大就能吃得下。

### 网络

[浏览器开两个窗口分别访问百度，各自窗口会单独创建tcp连接吗，还是复用之前的tcp？](https://www.zhihu.com/question/554796551/answer/2688086521)

浏览器渲染流水线与滚动
首先简单讲一下 chrome 中渲染流水线的流程，一个 html 是怎么被处理成一个页面的。html 中 dom 部分生成 dom tree，css 部分生成 stylesheet，dom tree 在解析完后会等待 stylesheet 构建完再渲染。stylesheet 根据默认样式、样式继承、css 选择器规则、样式优先级等规则，找到对应的 dom 节点赋予它样式，形成 dom 结构+样式的 render tree。其中有些节点是不可见的（不是 opacity: 0，而是诸如 display: none 这样的），它们不会影响其他节点的位置，在渲染时不需要考虑，所以过滤掉这些节点之后生成 layout tree，layout tree 会根据节点之间的相互影响生成它们的位置信息（reflow 回流/重排）。

你以为到了 layout tree 这一步终于可以渲染了吗，还远没有。layout tree 会根据某些 css 属性分层，比如 position: absolute; position: fixed 等等。如果它们发生更新，不需要连带其他节点 reflow，所以分层有利于单独处理。然后每个图层会生成各自的绘制指令列表（repaint 重绘），很底层的命令，描述了每一个点每一条线如何绘制。

你以为生成了绘制命令终于可以渲染了吗，还远没有。它们会被交给合成层，顾名思义，它是负责将那些图层合并的。它并不会全量的处理整个页面，而是优先处理可见视口附近的图块，如果页面过于复杂，它还会先给出低分辨率的位图。图块的绘制命令会通过光栅化线程池交给 gpu 绘制。合成层拿到 gpu 绘制出来的位图后，将它们合成为一张位图，这就是当前页面。你觉得终于渲染完了吗，并没有。它会将位图交给浏览器进程里的 biz 组件，biz 组件会交给显示器的后缓冲区，当显示器需要显示下一帧之前，前后缓冲区交换，屏幕上终于展示出新渲染的页面帧。（这里补个小知识，requestAnimationFrame 的背后原理就是显示器发送了 sync 信号，渲染进程将 requestAnimationFrame 回调放进消息队列，从而实现了 js 未阻塞的情况下 requestAnimationFrame 可以随帧调用）

可以发现浏览器想渲染一帧页面要经过如此多的步骤，是不是真为它的性能捏一把汗，这也是 HTML 方便开发带来的代价。我们还可以看出整个流程中最昂贵的步骤就是 reflow 和 repaint 了，至于合成层那边主要是和 GPU 打交道，不会占用渲染线程（也就是执行 js 的线程），并且 GPU 本来就十分擅长处理图片，所以合成层的工作很快。

因此，性能优化的核心思路其实就是尽可能减少 reflow、repaint 的工作，尽可能多利用合成层的工作。比如 css 硬件加速，包括 transform3D、opacity、willchange 等。拿 transform3D 来说，其实它只是图层的位移、转换，并不影响其他图层，所以不会经过 reflow 和 repaint，直接在合成层处理，GPU 处理这种变换非常快。因此硬件加速技巧可以极大的优化 css 性能。

下面谈一下滚动操作带来的影响在渲染流水线中的处于什么位置。首先滚动可能会产生滚动条，它的突然出现影响了其他元素的布局位置，会触发 reflow 以及后面的所有流程。滚动过程中，前面说过合成层初始优先处理可见视口附近的图块，其他部分其实还没有处理，元素结构太复杂时滚动过快可能让合成层来不及处理，从而出现白屏区域。还有比如 position: fixed 的元素，会跟着滚动走，那么它也会在滚动中 repaint 的。


### 设计模式

- [如何无痛降低 if else 面条代码复杂度](https://juejin.cn/post/6844903502611759117)

从URL输入到渲染
eventloop 先讲理解，再做一个题。
Vue源码

设计模式




原型链（这个到处都有）
手写防抖，注意下细节，比如函数调用的this指向，以及防抖默认执行一次，最好自己写的时候就把这些考虑在里面，不要等面试官提示你。(我的博客中性能优化部分有)

Vue双向绑定的原理
响应式原理
Vue3在响应式方面对比Vue2 性能方面有哪些提升
在Vue中如何抽取公共逻辑复用
你说的这几种复用的方式有哪些优缺点，以及它们适用于哪些场景，能举一些例子吗
项目介绍 及 一些具体实现细节
手写题 Promise 并发控制

自我介绍
项目介绍 及 项目问答（项目细节的实现、项目的难点、做过哪些优化）
页面性能优化的手段有哪些
webpack 的 loader 和 plugin 是什么，有没有自己写过loader、plugin
loader可以改变输出结果吗
常用的 plugin 有哪些
提到了 post-css，预处理 和 后处理 是什么
webpack 如何实现的模块懒加载
滚动懒加载
http 缓存
项目中使用哪种缓存
babel-loader 的输入输出是什么？
代码题——Promise按顺序输出

自我介绍
项目提问（主要是一些项目上的痛点提问，问如何优化，问具体思路）
拖拽相关的问题（先说哪些方案、其次是抛开拖拽库不谈、说说h5 的 drag、如果不用drag，还有什么别的方式能够实现？追着问了很久）
WebAssembly 了解过吗？
代码考核，不难，但是写的不好、异常处理、边界处理的不好。（不严谨）

开发阶段，包含了技术选型、项目创建、模板化、脚手架工具等方面的工作

部署阶段，如何去做自动化的CI/CD、如何将项目部署到服务器

质量保证，尝试使用一些自动化测试框架进行项目测试，同时对项目配置进行收敛，减少配置的修改，以保证每个项目的基础设施统一

如何提效，通过脚手架工具来实现零配置启动部署项目，通过模板、组件以及对应的schema调用方式来降低开发门槛和效率提升

Vite本地启动时会创建一个WebSocket连接，同时去监听本地的文件变化

当用户修改了本地的文件时，WebSocket的服务端会拿到变化的文件的ID或者其他标识，并推送给客户端

客户端获取到变化的文件信息之后，便去请求最新的文件并刷新页面

小程序本身是双线程架构，渲染层和逻辑层相互独立，通过微信原生中的JSBridge进行通信，因此性能的损耗主要花费在通信过程中。而在通信过程中影响性能的点最主要的则是setData的频率和数据量。
所以主要做的优化手段就是去减少setData的次数，同时当setData数据量过大时对数据量进行拆分，分为多个setData去执行，从这两者中找到一个平衡。

除此之外，还利用了 Wxml 节点压缩，CSS样式合并，以及请求预加载等方式进行性能优化。

脚手架

提供前端脚手架工具，支持一行代码自动完成项目创建，同时调用gitlab的API完成远程仓库的创建，最后自动生成相应的CI/CD脚本实现自动化部署

将项目的配置项进行收敛，包含ESLint、Prettier、TSConfig、Vite的等，将标准的配置文件全部内置在脚手架当中，只提供部分配置项以单独的脚手架配置项透出

提供自动化命令，包含代码格式化、质量检测、本地开发、生产打包等

框架

前端框架部分主要是对一些公共模块和服务进行了单独的封装，包含请求模块、状态管理、路由等，所有的功能都由框架导出给开发者直接调用

提供了业务通用能力的封装，如PDF预览、统一图表展示、富文本编辑器等

组件

组件部分主要是基于Antd去做一些样式和改造以及更上层的组件封装

对常见的CRUD页面封装成模板，并提供JSON2Page的使用方式，以实现通过JSON配置直接生成页面


## 项目复盘

项目难点是什么，如何解决？(靠自己总结了)
性能优化指标相关
对自己写的项目一定要做出复盘总结，提取概要，关键技术点一定要知道
我的技术栈是Vue，但是招聘岗位的技术栈是React，微信小程序，问如果我能通过面试，如何快速融入工作中。



### 组件库

要说我的 UI 库有没有用，我觉得是鬼用都木有哇，仅仅是想看看实现出来是怎么样的。诶，就是玩儿~

### 可视化

### 性能优化

## 能够拿出手展示的东西

知名开源项目的贡献者
star很多那种个人仓库
自己平时总结记录的博客

只有静态资源才需要http缓存。业务数据如果要缓存，也不该依赖http。
有人问，那get缓存怎么办？缓存这种东西还是不要交给浏览器和http协议的好吧，太不好控制了。真正需要缓存的时候，我会在前端里搞类似apollo client或react query那样的缓存，或者在后端应用层或redis层搞，可以精确地控制何时把哪些过期的缓存干掉。人生苦短，单单为了一个http协议就维护一套管理query string和cache header的转换层，感觉不值得。都搞成跨协议通用的缓存管理代码，挺好。

第一层, 跨组件 A B 用到同个状态, 要尝试组件 A 存的状态跟随组件 B 存的状态更新, 可能是通过事件进行,
第二层, 提升一个状态到父组件当中反过来分发到多个子组件, 来保持状态一致,
第三层, 太多位置, 或者想个太远的位置用到同个状态, 单纯传递事件或者蹭蹭 props 费代码, 转而依赖全局的 message bus (或者其变种)来完成.
(此外再有个极端方案是类似游戏当中, 所有状态保存全局, 然后 60fps 直接整体刷新.)
