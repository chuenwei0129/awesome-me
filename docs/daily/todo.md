1. 浏览器的自动播放策略【渡一教育】

题主说到了setTimeout不准时的问题，我猜题主对这个不准时的原因理解可能有偏差。从我之前看过的一些资料来看，setTimeout不准时并不是因为定时器没有在指定的时间被触发，而是触发之后回调函数没有被立刻执行，这是两个完全不同的概念。比如 setTimeout(fn, 500) 这句代码会让 javascript 引擎在 500ms 后准时地将 fn 加入 EventLoop ，但是 EventLoop 是不是会立刻执行 fn 的内容就不好说了，这要看 fn 前面是不是还有别的什么任务。

作者：刘津玮
链接：https://www.zhihu.com/question/50911384/answer/123273682
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
如果主线程只干UI的活，更多的时候它就是空闲的，这样只要一有新的消息进来马上就可以处理

如果主线程除了UI什么都不干，应该不会出现过于忙碌的情况。有新的更新UI的消息进来，放到队列的最后面就完事了。然后对这些更新UI的消息一个一个来处理

webworker 就是真多线程。webworker 采用的消息传递模型是一个很好的多线程编程模型，不仅简单易懂，同样也可以达到很高的性能。erlang/go等也都是用类似的方式。

SharedArrayBuffer可以传递给Worker，与普通ArrayBuffer不同的是，它可以被多个Worker（以及主线程）共享。可以通过Atomics操作来实现加锁等待之类的语义。具体可以看

作者：Jim Liu
链接：https://www.zhihu.com/question/50911384/answer/123333876
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

JS本身是为GUI而生的语言，GUI生而是多线程的，但生而也是单线程的。因为竞争访问的问题，只有一个UI线程是一种安全的方式。比如C# WinForm中只允许一个线程访问GUI，其他线程需要以委托的形式来访问GUI。JS曾经在Web GUI中表现良好，因为过去的Web GUI规模小，只要注意一些写法问题，不太容易遇到阻塞UI线程的问题，直到应用程序变复杂了才开始注意到这些问题。浏览器变得更快一定程度上延缓了这些问题，但是终究还是对并发的需求越来越大。WebWorker是真多线程——当然我是说从实现上讲，它是多个线程，至于楼主所说的，没有共享全局变量、没有锁，我觉得没有必要太纠结。多线程是一种并发模型，并且也许是受众最广泛的一种。WebWorker用的是基于通讯的并发模型，类似于erlang、Go，用的是Share Nothing的哲学（虽然终究还是有SharedArrayBuffer），它们都是经过了工业级别考验的。有了share那么必然会有竞争访问，于是就有了锁，这些都是自然而然的。但是，很明显，JS的发展倾向于share nothing，不然就干脆把整个global对象share了算了。至于为什么留SharedArrayBuffer，我觉得这只能说是“给不给”这个东西，不是“要不要”这样用了。这就和Go有点像了，应为闭包的存在GoRoutine之间也可以share，于是它也提供了锁，提供了mutex，但是它所建议的哲学还是用channel，用CSP，于是大家通常也都还是这么用。用GoRoutine当线程用，让channel滚蛋，还是用锁，还是可以做并发编程啊，但是好像没人这么弄吧，哈哈。多线程只是手段，并发才是目的，只要能实现目的，手段就是个方法论而已。至于多线程和异步之间我感觉没有太直接的绑定关系吧，单线程可以异步，多线程也可以同步。如果JS一开始就具有多线程的话，现今JS程序员可能会少一半吧（笑

一个程序员碰到了一个问题，他决定用多线程来解决。现在两个他问题了有…
