# 浏览器 API 讲解

<!-- 注：Passive 翻译为被动，为 true 时，表示主动权为浏览器，开发者 preventDefault() 无效，本质是浏览器自我优化。 -->
<!-- - `passive`：布尔值，表示监听函数不会调用事件的 `preventDefault` 方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。 -->

<!-- 如果我们在 touchstart 事件调用 preventDefault 会怎样呢？这时页面会禁止，不会滚动或缩放。那么问题来了：浏览器无法预先知道一个监听器会不会调用 preventDefault()，它需要等监听器执行完后，再去执行默认行为，而监听器执行是要耗时的，这样就会导致页面卡顿。

这段翻译的太专业了，你可以这么理解：当你触摸滑动页面时，页面应该跟随手指一起滚动。而此时你绑定了一个 touchstart 事件，你的事件大概执行 200 毫秒。这时浏览器就犯迷糊了：如果你在事件绑定函数中调用了 preventDefault，那么页面就不应该滚动，如果你没有调用 preventDefault，页面就需要滚动。但是你到底调用了还是没有调用，浏览器不知道。只能先执行你的函数，等 200 毫秒后，绑定事件执行完了，浏览器才知道，“哦，原来你没有阻止默认行为，好的，我马上滚”。此时，页面开始滚。 -->

<!-- 我们可以通过传递 passive 为 true 来明确告诉浏览器，事件处理程序不会调用 preventDefault 来阻止默认滑动行为。 -->
- [移动 Web 滚动性能优化: Passive event listeners](https://zhuanlan.zhihu.com/p/24555031)

## 引言

好，接下来给大家讲解一下浏览器 API。浏览器 API 其实它分了很多不同的种类，DOM 就是其中最重要的一类，它重要到什么程度呢？以至于很多人会有一个误解，认为所有的浏览器 API 都叫 DOM API。当然了我觉得从重要性的角度来讲，百分之七八十我们的 API 都是 DOM API。

## BOM（浏览器对象模型）

另外还有一个特别容易混淆的词就是 BOM 浏览器对象模型。BOM 听起来是一个包含 DOM 的这样的一个词，其实不是。BOM 只是很小的一组 API，它最早也是一个浏览器私有的名称，所以最终其实并没有一个特别好的名字来指代所有的浏览器的 API。在这里我们采用的说法就叫 Browser API，浏览器的编程的所有的接口。所以我们先从 DOM 开始给大家学习。

## DOM API 的组成

那么 DOM API 它又分成了四个部分，其中有一部分是废的，就是 traversal 系列的这个 API，可以去访问这个 DOM 树的所有的节点的这样的一个自动的迭代工具。这个 API 你用了比不用还麻烦，所以基本上不推荐大家去用。

我们的 DOM API 里面，现在的这个节点部分是最重要的一部分。API 我们平时大部分的场景都在用节点部分。除了节点部分，还有事件部分，这个也是非常关键的。我们所有发生交互想用 JS 跟 HTML 元素做交互，这个都需要通过事件。

然后还有一部分是非常强大，但是理解起来也非常费劲，用起来也非常麻烦，叫做 Range API。它比起这个节点类的 API 来说，它能够更精确地操纵 DOM 树，往往性能也是更好的。但是因为它易用性很差，所以说只有少数专业人士，比如说咱们喜欢做 HTML 编辑器的一些专家，他们就会使用这部分。

## DOM 节点的基础

好，咱们先从最简单的节点类的 API 开始说起。大家都知道 DOM 有 DOM 树的概念，但是我不知道大家知不知道 DOM 树里到底存了多少种节点。下面我们从这个继承关系上，我们就可以给大家粗略地来了解一下。所有 DOM 树上能挂着的东西，它都是统一继承自一个叫做 Node 的类。所以 Node 是所有这些节点的基类，挂在 DOM 树上的一定叫 Node，但是它不一定是 Element。Element 跟 Node 有时候也常常被大家所混淆。当然了确实这个 Node 里面百分之八九十的节点也都是属于 Element，Element 就是元素，就是我们用一对起始和结束标签来表示的这个东西。除了 Element 可以作为节点的 Node 的还有 Document 节点，根节点就是我们的 Document 对象，它其实也继承了 Node。还有一类叫做 Character Data，我们熟悉的文本节点和注释节点，它们都属于 Character Data，这也是一个基类。

然后是 Document Fragment 文档片段，这个东西它没有办法挂到任何一棵 DOM 树上，但是它也继承了 Node 节点，它也可以执行这个挂到 DOM 树上的操作，只不过是它挂的时候，会把自己的所有子节点给它塞到上面。这个咱们留到跟 Range API 一起去讲，因为他们两个经常搭配去使用。然后就是 DocType，DocType 它也是一个节点，这个节点它也继承了 Node，DocType 只要咱们这个 HTML 的语法里面有的，其实它都有一个对应的 API 去操纵它。

### 节点的分类

然后我们来看一下这个 Node 下面直接的这个子节点，这个元素子节点叫 Element。它下边其实还有 HTML Element，这个也是很多同学不会去分清楚的一个概念。那 Element 不就都是 HTML Element 吗？

不是，咱们前面讲了，根据 XML namespace，咱们的 HTML 里面至少有三个比较常用的 namespace，分别是 HTML、SVG 和 XML。这些常用的 namespace，它们都会产生一个 Element 的这样的一个子类，HTML 的 Element 下面的这些子类，就是大家所特别熟悉的，比如说 A 标签，通常这个子类的命名都是一个标签名后边加个 Element，只有一个东西例外，就是 A 标签，它不叫 HTML A Element，它叫 HTML Anchor Element，写了个全名。所以这些边边角角的东西也是大家需要记住的。像 SVG，这个里面就是该是什么就是什么了。这个 SVG A Element，SVG 里 A 标签，它就叫 SVG A Element。这个也是一个不太好记的这样的一个地方。

然后说这个 Document 的节点其实没什么好说的。Character Data 节点其实有用的就是文本节点。Comment 其实是一个该去掉的东西。然后 Character Data 它也是文本节点的一种额外的语法的表示法，所以它是继承自 Text 节点了。Processing Instruction 这个东西根本就不应该最后出现在 DOM 树里面，如果出现了，说明你这个写错了。当然这个 DOM 树里面还是公平的，它还是把这种不应该出现的节点也做了 API 化，避免万一出现了你能不能把它找到，这就是我们 DOM 的节点的家族了。

## 节点的操作

接下来我们来看一下它上面有哪些操作。首先最重要的一类就是导航类的操作。导航类的操作又分为节点的导航和元素的导航。前面说了，这个节点很重要。另外咱们的写 HTML 的时候，因为会有什么回车，什么空格这些东西去保证代码的格式。可能大家还会用这个 tab，用了这些字符之后，就会产生很多空白的文本节点。

那么咱们 DOM 树上严格来说，所有的节点它都要 Node。所以说这个 DOM 树上的一类通用的导航操作，就是 parentNode 找到它的父节点，childNodes 找到它的子节点。firstChild 找到它第一个，lastChild 找到它最后一个，然后 nextSibling 和 previousSibling 分别表示它的下一个邻居和上一个邻居，但是它这个都是针对 Node 的。所以说如果正常地写 HTML 不压缩的话，你会发现根据 Node 进行导航，很明显找到的都是节点。它的 nextSibling、previousSibling 多半都是一个空白的文本节点，所以就有了后面的这一组 API，就是元素导航系列。其实在咱们很多同学的脑子里面，这个是只有元素的，这个 DOM 树里面是只有元素，所以说它会有 parentElement、children、firstElementChild、lastElementChild、nextElementSibling 和 previousElementSibling。这些就都是只找元素的，文本节点会被忽略。

这里面其实有一个重复的 API，因为 parentNode 和 parentElement 是百分之百没有任何可能性不相等的。但是从 API 设计的美感的角度，还是都有。因为一个非 Element 的 Node，它是不可能有子节点的，所以说这俩东西一定是同样的，它父节点一定是 Element。导航类的操作能允许我们在 DOM 树上自由地移动，上下左右。这样我们其实就可以根据节点之间的父子关系和连接关系轻易地找到一些我们想要的关键节点。

## 节点的增删改查

接下来我们看一下，找到了以后，它还有一系列的操作，其中这个 appendChild 和 insertBefore，它们两个是一组。很多同学可能都会觉得这个地方的这个 API 非常的难受。为什么我们有 insertBefore 而没有 insertAfter？那原因就是我们一个最小化的原则假如说我们有十个子节点，insertBefore 可以插十个位置，而 appendChild 可以插第 11 个位置。十个节点一共形成了 11 个空隙，所以这 2 个 API 就足够我们把节点插到任何一个位置。所以说 insertAfter 是可以用 appendChild 和 insertBefore 它们两个去实现出来的，所以就没有 insertAfter 这个 API。

接下来就是我们想要移除一个元素，它也是要 removeChild，就是我们只得到一个元素的引用的时候，我们是只能去找它的父节点，我们才可以把它移除的。这个移除的操作必须在它的父节点上进行，我没有办法直接把一个元素自身 remove 掉，就是这个 replaceChild。replaceChild 相当于一次 remove 加上一次 insert，那它的好处就是也许可以节省这个 DOM 操作。我们从 API 设计的角度来讲，它应该是一次性的替换掉。但是浏览器究竟会怎么实现呢？这个咱们也并不会特别清楚，因为不同的浏览器理论上它也可以实现成，并不是这样的。这就是咱们去讨论 API 设计的时候跟讨论浏览器实现的时候的区别。

其实我们 replaceChild 也是一个多余的 API，因为我们刚说完这个最小化 API 设计的原则，所以很多历史的 API 设计，它的原则在不断地变化。咱们也搞不清楚到底每个 API 它设计都是怎么出来的？反正很多 API 变成了历史上的财富，很多 API 变成了历史上的包袱。这就是 DOM 的基本操作，还有一系列的高级操作也给大家讲一下。

## 高级操作

compareDocumentPosition 是用于比较两个节点中关系的函数，可以得到一个前后的这样的关系。而 contains 是检查一个节点是否包含另一个节点的函数，这个也非常有用。如果你自己去写这个，还是非常的麻烦的，大家可以试一试。如果你想写一个 compareDocumentPosition，或者想写一个 contains 的这个函数，这个代码还是很难写的，这两个都非常的方便。

isEqualNode 检查两个节点是否相同，这个就是只要在 DOM 树的结构相同，这两个节点就相同了，这个也非常有用，用来检查我们节点的这种树形结构，我们就不需要把它进行序列化。isSameNode，这个是一个废的 API，这个 API 我们完全可以用 JS 中的三等号来代替。我想这个 API 的存在，可能是出于多语言存在考虑，如果说我们用的不是 JavaScript，那它这个 DOM API 也许没有一个合适的对象相等的比较法。所以说它加了这个 isSameNode 这个方法。

然后最后有一个 cloneNode，复制一个节点，如果传入参数是 true，它就会做深拷贝。这个 API 也是非常有用的。如果我们想做一些 HTML 的节点或者是做一些 HTML 模板，这样的场景都是非常有用的。我们可以用 cloneNode 去大量的复制，它的速度也非常快，尤其是深拷贝也非常有用。
