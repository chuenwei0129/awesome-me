作者：不在列表
链接：https://www.zhihu.com/question/458213150/answer/1912710130
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

以 WeakMap 为例给你解释一下。当我们使用 Map 来存储一种值到值的映射关系，并且自始至终只关心从一个值获得其映射值时，那么最好使用 WeakMap。因为它的这种使用方式的预设，使能了这样一件事：当作为键的对象消亡时，其键到值的映射关系也不复存在了，即使 WeakMap 对象引用还存在，但 runtime 知道 WeakMap 中的该映射关系已经消失，而且我们并不指望用 WeakMap 来干别的事（而你这里说的“获取元素的数量、迭代其中的元素” 就属于单纯的从键拿值以外的事，这些事造成了对键的“感知”，这种感知是在”从键拿值“这件事之外的，此时 Map 引用的存在会留存作为键的对象的内存，阻止 GC。），此时 runtime 可以认为作为键的对象可以被 GC。 定义下，WeakMap 只是作为映射取值使用，你使用 WeakMap 就相当于告诉了 runtime 这件事，这使得 WeakMap 对象的引用不会对键的内存造成留存。所以对 WeakMap 执行除”从键拿值“以外的操作是没有道理的，与这个概念是冲突的，所以是不被允许的。如果你对映射类型的使用有更多的期望，那么就使用 Map，它的身份更为强盛，map 对象本身会留存键的内存，而不仅仅是做字典供查询之用。
