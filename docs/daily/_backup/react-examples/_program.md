# 精确本身就是祛魅

## 数学

## 自然常数 e

## 微积分

<!-- 已知，圆周长 2 * pi * r
求圆面积？
分割三角形，足够小，三角形斜边等于 r，拼出的弧度等于 1/2 周长 -->
<!-- 切割圆环时想象一堆绳子围成圆 -->
![20230321102640](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230321102640.png)

![20230321102920](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230321102920.png)

<!-- 细节，切割多少份引出极值，割之弥细，失之弥少 -->
<!-- 极限，研究无穷小，无穷大 -->
<!-- 要多小有多小，无穷小，动态过程 -->
<!-- 求极限，画图，- 左移 + 右移 -->
![20230321103930](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230321103930.png)

<!-- 导数，变化，瞬时速度，平均数度，斜率，a点到b点的变化，为什么是乘法 -->
![20230321105640](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230321105640.png)

<!-- 点动成线，线动成面，导数微分，球是圆面积叠加，圆是圆环叠加，即矩形叠加，数学是对现实的抽象 -->
<!-- 极坐标，指路，笛卡尔坐标 -->
“一层有一层的抽象”，这个说得太好了，基本上软件设计记住这个原则就好了，而且每一层抽象都是有成本的，所以抽象要有用，不然就是脱裤子放屁。

## 一层有一层的抽象

> [为什么汇编语言的功能在高级语言中一部分成为了关键字，一部分封装成了函数？](https://www.zhihu.com/question/352289969/answer/1966540336)
>
> 简单说：设计高级语言的人才不理你汇编呢。
>
> 他关注的是他自己的抽象，至于硬件是 X86/X86_64 还是 ARM/RISC，关我屁事。
>
> 就好像设计 CPU 的只管我的 CPU 图灵完备、同时执行目标任务（标量、浮点）时性能达标 —— 你管我把这玩意儿设计成复杂指令集、精简指令集还是超标量或者超长指令字呢。
>
> 这就叫“一层有一层的抽象” —— **只要我的抽象能用、好用，随便你上层下层怎么折腾**。

## 面向对象

### [对象的基础知识](https://www.bilibili.com/video/BV11e4y1W7CF?p=10)

![20230319092851](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230319092851.png)

![20230319092933](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230319092933.png)

![20230319093005](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230319093005.png)

![20230306224432](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230306224432.png)

![20230306224306](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230306224306.png)

### [面向对象编程是否是从根本上反模块化且反并行的？为什么？](https://www.zhihu.com/question/19728806/answer/18575066)

> 这个问题的根本在于 OOP 是基于状态的。**每个对象都维护着自己的状态，暴露给外界的是一些可以改变对象状态的方法**。
>
> **一个对象的状态里可以有对其他对象的引用，一个对象的方法也可以调用其他对象的方法来改变其他对象的状态，所以这些状态还是关联的**。很多人提到的线程安全与效率的取舍之类其实都是细枝末节，即使是有办法把所有方法都能高效地实现并且全都是线程安全的，**只要状态存在，状态带来的问题就存在**。
>
> 在一个复杂的并发系统中，你调用 `foo.bar(42)`，几个指令之后再调用 `foo.bar(42)`，两次调用的结果很可能是不一样的，因为在这中间 `foo` 的状态可能已经改变了，或者 `foo` 引用的某个对象的状态可能改变了，不去看 `bar()` 的实现根本不知道结果依赖于什么。同样一段程序多次运行因为时序的不确定性可能结果也不一样。
>
> 而目前很多人因为并发的需求所崇尚的函数式编程是基于 Lambda Calculus 的计算模型。计算由层层嵌套的函数调用完成；每个函数调用的结果只依赖于函数和它的参数。如果 `f(4, 5) = 10`，那么无论你在什么时候调用 `f(4, 5)`，它的结果都是 10。相对而言，这是一个比较干净，比较容易推理和确保正确性的模型。**OOP 的程序通常有很多隐藏的数据依赖，函数式编程把这些数据依赖都明确化了**。
>
> 但函数式编程最大的一个问题是，函数是一个数学抽象，在现实世界中不存在，它必须被模拟出来。**目前为止被广泛使用的计算机还是基于图灵机模型，计算机的寄存器、缓存、内存就是用来记录状态的**。要真正懂得程序设计，必须知道没有状态的函数是如何在充满状态的计算机上实现的，所以还是绕不开非函数式的编程。另外绝大部分的函数式程序设计语言都不是纯函数式的，出于实用性考虑都夹杂着其他语言的一些特点，并没有完全排斥状态。Haskell 号称纯函数式语言，用 Monad 来抽象状态，理论上可以自圆其说，但在实际使用中其实还是带来了很多不便（于是又发明了 Monad Transformer...）。
>
> **从某种程度上说，状态是绕不过去的，毕竟人感知到的宏观世界就是由各种各样有各自状态的对象构成**。函数式编程可以帮我们避免很多用其他方式容易犯的错误，在很多情况下写出更高质量的程序，但并发带来的复杂度并不会从根本上消失。各种编程风格一定是互相影响推动程序设计语言的进化，没有绝对的好坏，从 C++ 和 Java 最新标准里引入的函数式方面的功能就很容易看出这一点。比较有意思的是，OOP 最早是在 LISP 里实现的，而 LISP 也被很多人看做函数式编程的起始。同样，好的程序员也会根据具体情况使用合适的编程风格。

### 拓展

<!-- 封装：接口，b 站视频，继承：归一化，抽象，多态：子类重写父类方法，面向对象：行为改变状态，狗咬人 -->
- [面向对象编程的弊端是什么？](https://www.zhihu.com/question/20275578/answer/26577791)
- [JavaScript 凭什么不是面向对象的语言？](https://www.zhihu.com/question/506559729/answer/2276185739)
- [设计模式描写的太局部，怎么用 OO 思维从头开发程序？](https://www.zhihu.com/question/482126550/answer/2083836303)
- [如何正确地使用设计模式？](https://www.zhihu.com/question/23757906/answer/25567356)
- [如何看待 Erlang 之父 Joe Armstrong 觉得 OO 编程很烂？](https://www.zhihu.com/question/29888990/answer/703226836)

## [状态机](https://www.bilibili.com/video/BV11e4y1W7CF?p=20)

> [什么是状态机？](https://zhuanlan.zhihu.com/p/47434856)
>
> 状态机是有限状态自动机的简称，是现实事物运行规则抽象而成的一个数学模型。
>
> 状态机的每一个状态都是一个机器，它有自己的状态、输入、输出，而且每个机器的输入都是一致的，输出也是一致的。
>
> 状态机的每一个机器本身没有状态，如果我们用函数来表示的话，它应该是纯函数（无副作用）。每一个机器知道下一个状态，每个机器都有确定的下一个状态 (Moore) 或者每个机器根据输入决定下一个状态 (Mealy)。
>
> ![20230319175049](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230319175049.png)

## 递归

### [递归思想为什么是编程的基本思想，它效率很高吗？](https://www.zhihu.com/question/271081962)

> 递归跟效率没关系，是解决可计算性问题的，**图灵可计算的问题都可以通过一些单步的操作加上递归完成，所以有递归就能表述出所有的程序**，而且比图灵机程序更直观。至于效率那是实现时候的问题。

### [通用的递归转循环方法](https://zhuanlan.zhihu.com/p/136511316)

> 为什么**递归能等效于栈 + 循环**
>
> CPU 就可以看成是一个循环，不断从 PC 指向的位置去执行代码，在函数调用的过程中用 PC 去改变接下来要去执行的位置，用栈来跟踪找到调用完一个函数再回来的路，避免迷路。
>
> 只要我们自己接管整个函数调用的过程，完全可以实现将函数调用全部转换成 `while(true)`。

```js
let pc: number = 0; // pc 寄存器，用来标记程序下一个指令执行的位置
let r0: number = 0; // r0 寄存器，用来储存函数返回的值
let stack: number[] = [];

const code: Command[];

function run(address: number) {
    const command = code[address];
    if (command.isCall) { // 如果是调用函数
        stack.push(pc); // 用栈记录回来的位置
        pc = command.callAddress; // 设置 pc 让 cpu 去执行调用的函数
    }
    if (command.isReturn) { // 当函数返回的时候
        pc = stack.pop(); // 出栈之前在函数调用时记录的返回位置，并设置 pc 让 cpu 执行回到的位置
    }
    // other...
}

while (true) { // cpu 执行指令的循环
    run(pc);
    pc++; // pc 自增自动执行下一条指令
}
```

## 尾递归

> [尾递归为啥能优化？](https://zhuanlan.zhihu.com/p/36587160)
>
> **尾递归本身就可以完全等效于一个无栈的循环**，写成尾递归除了强行炫技以外没有任何实际意义，除了是在一些没有循环的纯函数式语言。

<!-- js 不支持尾递归优化，所以写成尾递归还是会生成递归调用栈 -->
> **尾递归函数依然还是递归函数，如果不优化依然跟普通递归函数一样会爆栈**，该展开多少层依旧是展开多少层。
>
> 函数栈的作用 —— **保持入口环境**
>
> **尾递归为什么可以优化？**
>
> 函数栈的目的是啥？是保持入口环境。那么在什么情况下可以把这个入口环境给优化掉？答案不言而喻，入口环境没意义的情况下为啥要保持入口环境？尾递归，就恰好是这种情况。
>
> **手动优化尾递归**
>
> 假设我们的语言没有原生支持尾递归优化，那么要怎么在语言层面上手动实现一个尾递归优化呢？这**其实就是一个把递归变成循环的过程嘛**。

## 幂等（idempotent）

> 💡 [数学之美](https://zhuanlan.zhihu.com/p/55222212)
>
> **幂等是指被自己重复运算，结果还等于自己**。这个规则放在计算机世界里，稍微弱化成一个函数 `f(x)` 可以被调用任意多次，其副作用保持不变。注意，这里的不变并不意味着没有副作用 —— 比如删除数据库里的一条主键为 k 的记录，无论调用多少次，其副作用都是 k 这条记录不存在。从这个意义上讲，没有副作用的纯函数（pure function）一定是幂等的，幂等函数不一定是纯函数。
>
> **幂等的好处是带来（副作用的）确定性**。HTTP GET / PUT / DELETE 被设计成幂等的，是因为资源的获取，替换和删除无论被调用一次还是多次，资源的状态保持不变。这样，调用者可以多次调用（刷新页面）而不必担心引发错误。
>
> 在一个分布式的世界里，幂等是皇冠上的钻石。我们要尽可能（或者说不得不）将系统设计为幂等，来应对各种各样的不确定性。比如郭靖通过互联网给华筝转账 10 个金叶子，华筝可能没收到，也可能收到了但是给靖哥哥的回复在网络上丢了，两种情况郭靖都需要重传这笔交易，然而重传导致的后果可能是郭靖明明只需要给华筝转 10 个金叶子，却转了 20 个。如果设计成为幂等，我们可以在转账交易中加入一个唯一标识，这样重复的转账就会被丢弃，从而保证一致的副作用。

## 交换律（commutative）

> 💡 [数学之美](https://zhuanlan.zhihu.com/p/55222212)
>
> 交换律是说给定任意 `x`、`y`，对于运算 `*`，如果 `x * y = y * x`，那么我们就认为这个运算是可交换的。拿人话来说就是**我们可以改变处理的事件的顺序而不影响其最终的结果。**
>
> 在计算机的世界里，**交换律意味着我们可以打算指令（或者消息）的顺序，进行乱序执行**。在我们这个热力学第二定律统治的宇宙下，乱序执行一定比顺序执行更有能效。在一个消息系统里，如果消息要按照发送的序列严格处理，就意味着在接收端需要使用队列来存储和排序已经收到的消息，前一个消息没有处理，不能处理下一个消息，那么，这样的系统效率比较低；如果我们能够将其改进成为消息可以按照收到的顺序处理，也就是满足了交换律，那么，效率可以成量级地提高。

## 结合律（associative）

> 💡 [数学之美](https://zhuanlan.zhihu.com/p/55222212)
>
> 结合律是说给定任意的 `x`、`y`、`z`，对于运算 `*`，如果 `(x * y) * z = x * (y * z)`，那么我们就说这个运算是可结合的。拿人话来说就是，**只要参与计算的元素的顺序不变，我可以随意改变运算的顺序，而不会影响最终的结果**。
>
> 在计算机的世界里，**结合律意味着计算的顺序可以发生变化**。比如快排算法，在 partition 之后，先处理小于基准点的数组，还是先处理大于基准点的数组，并没有关系，所以它是满足结合律的。
>
>我们进一步思考，可以发现，**满足结合律意味着处理过程中的局部状态并不受全局状态的影响，或者说独立于全局状态**，于是，**结合律还意味着并发处理** —— 对于一个给定的列表，如果处理列表的算法是满足结合律的，那么就意味着我们可以对列表中的子列表进行并发计算，而并不影响最终的结果。反过来表述，一切可以分治的算法，都满足结合律。

## Y Combinator

- [重新发明 Y 组合子 JavaScript(ES6) 版](http://picasso250.github.io/2015/03/31/reinvent-y.html)
- [Y 不动点组合子用在哪里？](https://www.zhihu.com/question/21099081)
- [函数式编程的 Y Combinator 有哪些实用价值？](https://www.zhihu.com/question/20115649/answer/14029761)

## [回调函数是什么？](https://www.zhihu.com/question/19801131)

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220418-g6h.png)

## CPS

> [干货｜详解 Algebraic Effects 代数效应](https://zhuanlan.zhihu.com/p/380855727)

## CallBag

> [Staltz - Callback Heaven](https://zhuanlan.zhihu.com/p/38039481)

## Hash

![20230306165648](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230306165648.png)

## Stream

> [用 JS 代码解释 Java Stream](https://zhuanlan.zhihu.com/p/61456650)

## [时间复杂度 O(logN) 意味着什么？](https://juejin.cn/post/6844903481191432206)

![20230306034906](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/others/20230306034906.png)

## [P 问题、NP 问题、NP 完全问题和 NP 难问题](https://zhuanlan.zhihu.com/p/73953567)

复杂度被分为两种级别：一种是 `O(1)`，`O(logN)`，`O(N^2)` 等，我们把它叫做多项式级的复杂度，**因为它的规模 N 出现在底数的位置**；另一种是 `O(2^N)` 和 `O(N!)` 型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。

**P 问题**：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于 P 问题。

**NP 问题**： NP 问题不是非 P 类问题。NP 问题是指可以在多项式的时间里验证一个解的问题。NP 问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。

**NPC 问题**：同时满足下面两个条件的问题就是 NPC 问题。首先，它得是一个 NP 问题；然后，所有的 NP 问题都可以约化到它。NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。

**NP-Hard 问题**：它满足 NPC 问题定义的第二条但不一定要满足第一条。NP-Hard 问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是 NP 问题。即使 NPC 问题发现了多项式级的算法，NP-Hard 问题有可能仍然无法得到多项式级的算法 约化：(Reducibility，有的资料上叫“归约”)。简单地说，一个问题 A 可以约化为问题 B 的含义即是，可以用问题 B 的解法解决问题 A，或者说，问题 A 可以“变成”问题 B。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。

## DSL

> [前端 DSL 实践指南（上）—— 内部 DSL](https://zhuanlan.zhihu.com/p/107947462)

最强多态是「鸭子类型」但鸭子类型无法在编译时检查以优化性能，所以新兴语言普遍采用了protocol/trait等技术来实现接近鸭子类型的灵活度，并保留了编译型语言的性能。

之所以说继承是编译技术落后的产物，是因为早期软件复杂度不是那么高，所以科学家们出于直觉地进行了“在数据上添加操作(函数地址)，并复用这个操作”的设计，而后来随着软件规模的增长，才意识到继承带来的强耦合，转而使用组合，编程思想也转变为“为某一个struct实现某一个interface”而不是“用class来表示一个有某些操作的数据”。

新兴语言的基本组成都是 immutable struct + protocol/trait 了，相当于 没有继承的不可变的class + 独立在数据之外的interface的implements

duck type并不先进，这种类型系统往往会破坏封装破坏整体架构逻辑，而且不够sound，很多问题编译期发现不了，特别对于不能轻易表达对duck type语法约束的语言如c++，代码报错都不看懂。反之面向接口仍是目前组织大型软件的不二法门。

面向对象真的就是一个无比糟糕的编程概念。其实对象这个玩意唯一解决的问题是把数据和相关的逻辑统一了起来。
polyfill 标准 API 运行时补丁这种修改内置对象原型的库，在原有对象方法前后加新标准逻辑，就是装饰模式。推而广之，所有函数式编程当中的高阶函数，其实都是在原函数前后加特定逻辑的装饰模式应用。自然 React 常说的高阶组件也是装饰模式；在面向对象层面，装饰器语法就是这个模式的直接实现。

面向对象不是银弹，就像函数式编程也不是银弹一样。其实前端现在最常用的模式也就是装饰模式，代码量大了自然就学到那里了。

面向对象抽象的是数据和操作，声明式抽象的是过程

oop的特征是封装，继承，多态，是实现高度抽象和个性化这些目标的一种编程方法。FP是另一种编程方法，同样可以实现高度抽象和个性化这些目标。oop与FP有异曲同工之妙！
fp和oop都是编程的核心思想，fp是pipe的思想，只关系输入输出，确定的输入有着确定的输出。fp并不是编程风格这么简单
函数一等公民，也和面向对象不矛盾。在没有class的年代，js的函数一等公民加上词法作用域，带来的闭包特性，也是一种经典的面向对象的手段，所谓“闭包是穷人的对象”嘛。访问限定、封装、隔离，都可以用闭包搞定。而多态这种特性。。。JS这种鸭子类型的动态语言难道不是天然支持多态吗？多态搞起来比TS方便多了。
那。。不用组合用啥。。？总不能用继承这种大坑吧。。而且说白了依赖注入和AOP不就是组合吗。？还是说你发现了更好的办法。？愿闻其详
composition api和hooks容易乱，根本原因是把本应该放在model层的逻辑放在view层了。这是人的问题。
vue和react的绝大多数用户不知道严格区分mvvm的重要性，也没有设计领域模型的经验。
框架其实是用来帮我们解决数据绑定和局部/临时状态的。承担的是vm层和部分v层内部自己的mvc体系(这个v内部可以是一个mvc)。所以我觉得这不能说是这两个框架的设计缺陷，而是没能阻止用户的不良实践。
UI开发的主要工作量其实在model的设计，但是实际情况是太多人把东西一股脑都写到组件里了
回答里既然都说了 hooks 在 mental model 上只是组件函数的参数的另一种写法，那 hooks 不能放 if 里面就是自然而然的了——一个函数有多少个参数、各个参数的顺序是什么，这应当是永远不会变的，不能允许它在每次调用时都可能不同。如果你真的想要一个“不是组件函数参数的另一种写法”的东西，那可以试试 SolidJS，它没有 hooks，只有 signal。只不过它的那种设计又带来了另一个问题：不能按条件 return。

nice，和我理解的一样。我一直认为hooks不过是参数的语法糖而已，所以函数组件就变成了一个接受参数（props + hooks）然后返回jsx的纯函数。
所以hooks不能用在分支或者循环里是理所当然的，函数怎么可能在运行时决定参数的个数和含义呢？
但是网上很多的文章都在从实现的角度分析原因，还有很多人去自己实现可以放进分支的hook，就很搞笑
模仿比自己瞎琢磨高效的多
没必要太多地去纠结这些东西，看不懂代码就去问写这个代码的人。
（暴论）
