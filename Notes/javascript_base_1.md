## JavaScript 基础知识梳理（一）

### 数据类型

JavaScript 中有八种基本的数据类型（前七种为基本数据类型，也称为原始类型，而 `object` 为复杂数据类型）。

- `number` 用于任何类型的数字：整数或浮点数，在 ±(2^53-1) 范围内的整数。
- `bigint` 用于任意长度的整数。
- `string` 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。
- `boolean` 用于 `true` 和 `false`。
- `null` 用于未知的值 —— 只有一个 `null` 值的独立类型。
- `undefined` 用于未定义的值 —— 只有一个 `undefined` 值的独立类型。
- `symbol` 用于唯一的标识符。
- `object` 用于更复杂的数据结构。

### 类型判断

`typeof` 运算符返回参数的类型。

它支持两种语法形式：

- 作为运算符：`typeof x`。
- 函数形式：`typeof(x)`。

```js
console.log(typeof null) // 'object'
console.log(typeof Array.isArray) // 'function'
console.log(typeof typeof Array.isArray) // 'string'
```
### 类型转换
// TODO

### 运算符

#### 二元运算符 + 连接字符串

通常，加号 + 用于求和。但是如果加号 + 被应用于字符串，它将合并（连接）各个字符串：

```js
console.log('2' + 2) // "22"
console.log(2 + '1') // "21"
console.log(2 + 2 + '1') // "41"，不是 "221"
```

注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。

**二元 + 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。**

#### 数字转化，一元运算符 +

一元运算符加号，或者说，加号 + 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字。

例如：

```js
// 对数字无效
let x = 1
console.log(+x) // 1

// 转化非数字
console.log(+true) // 1
console.log(+"")   // 0
```
它的效果和 `Number(...)` 相同。

#### 运算符优先级
// TODO
#### 原地修改/自增/自减
我们经常需要对一个变量做运算，并将新的结果存储在同一个变量中。

例如：

```js
let n = 2;
n = n + 5;
n = n * 2;
```

可以使用运算符 += 和 *= 来缩写这种表示。

```js
let n = 2;
n += 5; // 现在 n = 7（等同于 n = n + 5）
n *= 2; // 现在 n = 14（等同于 n = n * 2）

console.log( n ); // 14
```

这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：

```js
let n = 2;
n *= 3 + 5;

alert( n ); // 16 （右边部分先被计算，等同于 n *= 8）
```

对一个数进行加一、减一是最常见的数学运算符之一。

所以，对此有一些专门的运算符：

**自增 ++ 将变量与 1 相加、自减 -- 将变量与 1 相减：**

```js
let counter = 2
console.log(counter++) // 2
console.log(counter) // 3
console.log(++counter) // 4
console.log(counter) // 4
```
#### 位运算符
// TODO
#### 逗号运算符
逗号运算符 , 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码，因此为了能够理解代码，我们需要了解它。

```js
let a = (1 + 2, 3 + 4);
console.log( a ); // 7（3 + 4 的结果）

// 一行上有三个运算符
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
```

逗号运算符能让我们处理多个语句，使用 , 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。

#### 逻辑运算符

JavaScript 中有三个逻辑运算符：||（或），&&（与），!（非）。

> 非运算符 ! 的优先级在所有逻辑运算符里面最高，所以它总是在 && 和 || 之前执行。
> 与运算 && 在或运算 || 之前进行
> 与运算 && 的优先级比或运算 || 要高。

所以代码 `a && b || c && d` 跟 && 表达式加了括号完全一样：`(a && b) || (c && d)`。

##### 或运算寻找第一个真值

或运算符 || 做了如下的事情：

- 从左到右依次计算操作数。
- 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。
- 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。
- 返回的值是操作数的初始形式，不会做布尔转换。

换句话说，**一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。**

例如：
```js
console.log( 1 || 0 ); // 1（1 是真值）
console.log( null || 1 ); // 1（1 是第一个真值）
console.log( null || 0 || 1 ); // 1（第一个真值）
console.log( undefined || null || 0 ); // 0（都是假值，返回最后一个值）
```

##### 与运算寻找第一个假值
与运算 && 做了如下的事：

- 从左到右依次计算操作数。
- 在处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。
- 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。
- 
换句话说，**与运算返回第一个假值，如果没有假值就返回最后一个值。**

上面的规则和或运算很像。区别就是与运算返回第一个假值，而或运算返回第一个真值。

例如：
```js
// 如果第一个操作数是真值，
// 与运算返回第二个操作数：
console.log( 1 && 0 ); // 0
console.log( 1 && 5 ); // 5

// 如果第一个操作数是假值，
// 与运算将直接返回它。第二个操作数会被忽略
console.log( null && 5 ); // null
console.log( 0 && "no matter what" ); // 0
```

#### 感叹符号 ! 表示布尔非运算符。

逻辑非运算符接受一个参数，并按如下运作：
- 将操作数转化为布尔类型：true/false。
- 返回相反的值。

例如：
```js
console.log( !true ); // false
console.log( !0 ); // true
```

两个非运算 !! 有时候用来将某个值转化为布尔类型，等同于内置的 Boolean 函数：

```js
console.log( !!"non-empty string" ); // true
console.log( !!null ); // false
console.log( Boolean("non-empty string") ); // true
console.log( Boolean(null) ); // false
```

也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。

#### 空值合并运算符 '??'

如果第一个参数不是 `null/undefined`，则 ?? 返回第一个参数。否则，返回第二个参数。
```js
let user1;
console.log(user1 ?? "Anonymous"); // Anonymous
let user2 = "John";
console.log(user2 ?? "Anonymous"); // John
```

总结：
- 与 || 相比，|| 无法区分 false、0、空字符串 "" 和 null/undefined。它们都一样 —— 假值（falsy values）。如果其中任何一个是 || 的第一个参数，那么我们将得到第二个参数作为结果。
- ?? 运算符的优先级非常低，仅略高于 ? 和 =，因此在表达式中使用它时请考虑添加括号。
- 如果没有明确添加括号，不能将其与 || 或 && 一起使用。

### 循环

- 通常条件为假时，循环会终止。但我们随时都可以使用 break 指令强制退出。
- `continue` 指令是 `break` 的“轻量版”。它不会停掉整个循环。而是停止当前这一次迭代，并强制启动新一轮循环（如果条件允许的话）。
- `switch` 语句有至少一个 `case` 代码块和一个可选的 `default` 代码块。如果没有 `break`，程序将不经过任何检查就会继续执行下一个 `case`。
- `switch/case` 有通过 `case` 进行“分组”的能力，其实是 `switch `语句没有 `break` 时的副作用。
