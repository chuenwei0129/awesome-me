JavaScript 在设计阶段为了保证线程安全并且保证引擎不会被 IO 等待所阻塞导致页面失去响应，于是就向其他 GUI 程序学习了“异步事件模型”，

这种 “异步事件模型” 有两个核心的特性： 1，只有主线程有权利改变环境。2，主线程不允许被阻塞。这样就非常好得把线程和环境之间的矛盾解决了。我们的 JavaScript 也遵循了这样的设计。
数据结构
https://www.zhihu.com/question/394945080/answer/1679201062

https://github.com/justjavac/proxy-www

如果没有遇到性能瓶颈，就不要做性能优化。

谁会喜欢「寄生混合继承」这种费解的东西呢？

手里有了锤子看什么都是钉子

设计模式硬套

而且对象字面量又非常方便（从这个语法衍生出的 JSON，说不定是 JS 对整个计算机产业最大的贡献了）

class 很容易作为工厂模式的语法糖，new 出长期存在的对象实例来用。
在为 JS 环境扩展各种平台基础能力的时候，class 是一种建构「有状态对象」的基本原语，很适合 1:1 地把 C++ 的 class 和 JS 的 class 映射起来，也有 N-API 的现成支持。
class 有良好的 IDE 支持，如果设计得当，你在开发新需求时并不需要修改散落在项目四处的细粒度函数逻辑，而是只需集中修改内聚在 class 中的代码，亦即数据和行为。
最重要的是，class 代表了一种工业界开发语言中最普遍的思维模型。它就像英语一样，可以把「类、实例、生命周期」这些概念拿来和几乎所有具备正常技能水平的程序员沟通。作为反例，其实 Objective-C 老师傅更加面向对象，更加「组合优于继承」呢。语言最终要靠人去使用，小众的概念设定（比如 OC 的 protocol 和 delegate）哪怕实际上闪烁着创新的光芒，也会存在难学难招人难培育生态的问题，这是种马太效应式的社会现象。
每个人都只会用到软件的某个 10% 功能子集一样，你常用的语言特性或许也只有全部语言特性的 10%。那么，你用不到的这 90% 就都是鸡肋吗？

https://www.zhihu.com/question/432832293

https://www.zhihu.com/question/324992717?rf=312070160

关于 prefer-const 下的一个小技巧

浏览器进程

setTimout 本质上就是一个注册一个延时触发的事件。并不是所有的状态改变都可以注册事件，有些场景不直接/间接使用 setTimeout/setInterval 就做不了。

超级复杂的 JS 底层。事件循环和事件队列的关系。宏任务、微任务和 raf 回调这 3 个事件队列的关系。任务队列和执行栈的关系。dom 点击事件和 js 调用函数对执行栈的不同影响。事件循环和 dom 渲染之家 raf 回调函数的执行。附带要理解函数调用过程词法环境和执行上下文

红任务出战才能执行为人物

为人物会阻塞渲染是应为为人物执行是一队列
事件是一个一个执行

raf

是谁动了我的代码
是谁动了我的代码？

又是谁的 bug 指到了我的头上？

团队合作时，这样的问题相信大家已经家常便饭司空见惯屡见不鲜了。这时候可以祭出杀器 blame: 使用 git blame <file> 来定位代码的最后一次修改。

但是，此时有一个问题，这只能查看本行代码的上体提交，而无法定位本行代码的提交历史。比如项目合作中某人对全部代码进行了格式化，git blame 就失去了作用。此时，可以与另一个有用的命令 git log -p <file> 结合使用，可以查看文件的更改历史与明细，最终找到这个锅究竟应该由谁来背。

git blame -L 10,12 package.json
git log -p -L 10,12:package.json #快速切换合并分支
当你经常工作于 A 与 B 两个分支，需要来回切。这时命令应该是 git checkout A，但这里有一个更简单的命令，git checkout -，表示切到最近的一次分支。如果你需要把 B 分支的内容合并过来，可以使用 git merge -。

git checkout -
git merge -
而 - 往往代表最近一次，如 cd - 代表进入最近目录，也相当实用。

#统计项目
统计项目各个成员 commit 的情况，比如你可以查看你自己的项目的 commit 数以及他人对你项目的贡献数

git shortlog -sn
git shortlog -sn --no-merges # 不包含 merge commit #快速定位提交
如果你的 commit message 比较规范，比如会关联 issuse 或者当前任务或者 bug 的编号，此时根据 commit message 快速定位： git log --grep "Add"。

如果你的 commit message 不太规范，只记得改了哪几行代码，此时也可以根据每次提交的信息查找关键字，是 git log -S "setTimeout"。

同时，也可以根据作者，时间来辅助快速定位。

git log --since="0 am" 　　　 # 查看今日的提交
git log --author="shfshanyue" # 查看 shfshanyue 的提交
git log --grep="#12" # 查找提交信息中包含关键字的提交
git log -S "setTimeout" # 查看提交内容中包含关键字的提交 #快速定位字符串
如何查找包换关键字的全部文件？

使用 VS Code 可以全局搜索，使用 grep 也可以通过 grep -rn <keyword> 来全局搜索。

不过，它们也会连带搜索忽略文件，比如前端著名的两个文件夹 node_modules 和 public(dist/build)。虽然 grep 可以指定 --exclude 来忽略文件，不过 git 来的更方便一些。

这时，可以使用 git grep <keyword> 来解决这个问题，另外 ag 也可以解决这个问题。

grep -rn <keyword>
grep -rn <keyword> --exclude config.js --exclude-dir node_modules
git grep <keyword>
ag <keyword>

内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。

客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。
服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。

优点：首屏渲染快，SEO 好。
缺点：配置麻烦，增加了服务器的计算压力。

下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。
客户端渲染过程

访问客户端渲染的网站。
服务器返回一个包含了引入资源语句和 <div id="app"></div> 的 HTML 文件。
客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面。

服务端渲染过程

访问服务端渲染的网站。
服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。
当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面。

从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。
这样做的好处是什么？是更快的内容到达时间 (time-to-content)。
假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。
这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百 K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。这就是服务端渲染更快的原因。

作者：谭光志
链接：https://juejin.cn/post/6892994632968306702
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

单例模式
对象字面

它没法共享实力的属性方法

<!-- vue 一对多 -->

<!-- 多个观察者模式并存 -->

<!-- 每个属性都有一个观察者模式 -->

<!-- 一个属性 可能有多个watcher -->

<!-- 试图驱动数据 -->

数组队列

渲染节流 nextTick
组件及更新

用户调用也会进队列
[watcher, ...]
promise.then90

vue1 属性一边就更新

计算属性默认不执行
lazyfn

取之时才执行

computed 函数会比渲染优先，废话

vnode 是对象不是 vue 的实力

携程对象会有应用类型问题
函数返回醒的
组件复用。
两个一摸一样标签

组件是不同构造函数的实力

merge 的是 vue

// 复杂的项目不仅要状态管理，还要组件管理、逻辑管理、
// 异步带来的协程管理。状态也是分层的：持久化数据状态、全局页面状态、区块状态、组件内部状态。

// React router hooks

// 阶梯规则，List 形式
// 每一层阶梯内的同级字段之间有动态联动，比如：字段 A 变化，会控制字段 B 的显示隐藏
// 每一层阶梯内的同级字段之间有联动校验，比如：字段 B 的值必须大于等于字段 A 的值
// 层级与层级之间的字段有联动校验，比如第二阶梯的字段 A 的值要大于第一阶梯字段 B 的值

// TODO：表单，query，拖拽，组件，长列表，toolkit，优先级，

// 所以，很多表单解决方案就开始放任 React 全局 rerender，就像只要满足官方推荐的单向数据流方式就是一种政治正确一样
// 这个我这里小 demo 有体会

// 如果你用 Antd Form 或者 Fusion Next Form，你肯定会发现你的组件内部到处都是 FormItem 组件

// 动态化渲染表单 联动 校验

// 表单的动态渲染协议最好是标准而且完备的

// 比如字段状态分布式管理，基于 pub/sub 的方式做字段间通讯，

// 副作用独立管理，主要是对表单字段状态管理逻辑，独立带来的收益是 View 层的可维护性提升，同时统一收敛到一处维护，对用户而言更加友好
// 嵌套数据结构路径自动拼接
// 更加优雅的组件内外通讯方式，外部也能精确控制字段的更新
// 基于标准 JSON Schema 数据结构做扩展，构建动态表单渲染引擎
// 最终，我们可以推导出解决方案的雏形：JSON Schema + 字段分布式管理 + 面向复杂通用组件的通讯管理方案

// 单向数据流总结一句话就是：数据同步靠根组件重绘来驱动，子组件重绘受根组件控制

// 状态分布式管理就是：数据同步靠根组件广播需要更新的子组件重绘，根组件只负责消息分发，就是 selector，vue 也是这个模型类似

// 还是一个中心化的管理数据流

// get set 自己实现 this.setState({data})，发布订阅

// reducer 容器

// 我们完全可以共享同一个 actions 引用与一个 effects 处理器，更进一步，我们可以把 actions 与 effects 以独立 js 文件做管理，这样一来，effects 就像 redux 的 reducer 一样了，但是，它比 redux 能力更加强大，因为结合 rxjs，它天然具有解决各种时序型异步问题的能力。相反 redux 则得借助 redux-saga 之类的方案来处理。

// React 几个大热点：状态管理、表单操作、性能优化。。。所以
