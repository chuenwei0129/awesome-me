// https://www.zhihu.com/people/599-75-63/posts
//? satisfies 操作符

// 但在这种时候，由于我们是从值推导得到类型，而不是使用类型约束值，那么在我们提供了错误的值时，推导得到的类型信息也将出现问题，比如在这里我不小心打错了字：
// 这样推导出来的类型信息就有问题了，而为了避免这种问题，我们通常会使用显式地类型标注：
// 也就是说，我们现在是让值完全符合类型，然后使用我们提供的类型信息。而我们实际需要的效果则是，让值符合类型的前提下，结合使用值推导出的类型信息，
// 推导得到的类型实际上是我们标注类型的子类型
// 而更可怕的一点是，类型断言是允许你把不正确的值断言成提供的类型信息的
// 使用类型断言的本质还是让显式提供的类型信息完全覆盖推导得到的类型信息，
// 我们调用的 eat 方法，实际上来自于 Animal 类型，这个时候其实我们就是隐式地执行了 upcast ，将其类型向上转换到了 Animal 类型，也就是将猫狗都视为动物。这实际上也符合抽象原则和 SOLID 原则中的里氏替换原则——在某些时候，我并不需要知道这个动物到底是什么物种，只需要知道它是动物而不是植物就行了。同时，只要你这个地方需要的是 Animal 类型，那我只要给的是其子类型，不管是什么动物，都能确保其工作正常。
// 但如果我们想要执行 downcast，比如从 Animal 类型向下转换到其子类型，这个时候就可能出现问题，因为我们无法确定此时它是否真的是对应的子类型，所以通常需要配合类型守卫：
type Colors = 'red' | 'green' | 'blue'
type RGB = [number, number, number]

const palette = {
  red: [255, 0, 0],
  green: '#00ff00',
  blue: [0, 0, 255],
} satisfies Record<Colors, string | RGB>

// 推导得到的类型实际上是我们标注类型的子类型
// 抽象，具体，向上断言，向下断言，向上自动，向下类型守护

// in 约束
