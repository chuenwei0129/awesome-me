# 浮点数之迷<!-- omit in toc -->

- [浮点数](#浮点数)
- [IEEE754 简述](#ieee754-简述)
- [32 位单精度浮点数在内存中的存储方式](#32-位单精度浮点数在内存中的存储方式)
- [实例：表示十进制浮点数 20.5](#实例表示十进制浮点数-205)
- [32 位浮点数的取值范围](#32-位浮点数的取值范围)
  - [前置知识](#前置知识)
  - [计算取值范围](#计算取值范围)
- [为什么说 32 位浮点数的精度是"7位有效数"](#为什么说-32-位浮点数的精度是7位有效数)
- [其他](#其他)
  - [其他导致浮点数存储不精确的原因](#其他导致浮点数存储不精确的原因)
  - [32 位浮点数能存储很大的整数](#32-位浮点数能存储很大的整数)
  - [32 位浮点数能存储很精确的小数](#32-位浮点数能存储很精确的小数)
  - [浮点数运算三步骤](#浮点数运算三步骤)
    - [对阶](#对阶)
    - [尾数求和](#尾数求和)
  - [规格化和舍入](#规格化和舍入)
- [参考资料](#参考资料)

## 浮点数

> [为什么叫浮点数?](https://www.zhihu.com/question/19848808/answer/120393769)

**小数点在数制中代表一种对齐方式**，比如说你要比较 `1000` 和 `200` 哪个比较大你应该怎么做呢？你必须把他们**右对齐**：

```sh
1000
0200
```

然后发现 `1` 比 `0`（前面补零）大，所以 `1000` 比较大。那么如果是比较 `1000` 和 `200.01` 呢？这时候就不是右对齐了，而是对应位对齐，也就是**小数点对齐**：

```sh
1000
 200.01
```

**小数点位置在进制表示中是至关重要的，位置差一位整体就要差进制倍**（十进制就是十倍）。在计算机中也是这样，虽然计算机使用二进制，但在处理非整数时，也需要考虑小数点位置的问题，**无法对齐小数点就无法做加法、减法比较这样的操作**。我们说小数点位置，永远是说相对于我们存储的数位来说的，比如说我们存储了 `01001001`，然后小数点在第三位之后，也就是 `010.01001了`。

在计算机中处理小数点位置有**浮点**和**定点**两种，定点就是小数点永远在固定的位置上，比如说我们约定一种 `32` 位无符号定点数，它的小数点永远在第 `5` 位后面，这样最大能表示的数就是 `11111.111111111111111111111111111`，它是 `32` - `2^-27`，最小非零数是 `2^-27`。定点数是提前对齐好的小数，整数是一种特殊情况，小数点永远在最后一位之后。

**定点数的优点是很简单**，大部分运算实现起来和整数一样或者略有变化，**但是缺点则是表示范围**，比如我们刚才的例子中，最大只能表示32；而且在表示很小的数的时候，大部分位都是 `0`，精度很差，不能充分运用存储单元。浮点数就是设计来克服这个缺点的，它相当于一个定点数加上一个阶码，**阶码表示将这个定点数的小数点移动若干位**。由于可以用阶码移动小数点，因此称为浮点数。

## IEEE754 简述

IEEE754 提供了四种精度规范, 其中最常用的是 **单精度浮点型** 和 **双精度浮点型** ， 但 IEEE754 并没有规定 32 位浮点数类型需要叫做 `float`，或 64 位浮点数需要叫做 `double`。 它只是提供了一些关于如何存储不同精度浮点数的规范和标准。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-441507575baadbf6fec51d35612778f4_1440w.jpg)

## 32 位单精度浮点数在内存中的存储方式

想要存储一个 32 位浮点数, 比如 `20.5`, 在内存或硬盘中要占用 32 个二进制位。

这 32 个二进制位被划分为 3 部分, 用途各不相同:

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-32e425cdb908c47586267e59228fcd22_1440w.png)

这 32 个二进制位的内存编号从高到低 (从 31 到 0), 共包含如下几个部分:

- **sign**：符号位, 即图中蓝色的方块
- **biased exponent**：偏移后的指数位, 即图中绿色的方块
- **fraction**：尾数位, 即图中红色的方块

下面会依次介绍这三个部分的概念，用途。

**符号位：**

占据最高位(第 31 位)这一位，用于表示这个浮点数是正数还是负数，为 0 表示正数，为 1 表示负数。

**偏移后的指数位：**

用于表示以 2 位底的指数。8 位二进制可以表示 256 种状态，IEEE754 规定，指数位用于表示 `[-127, 128]` 范围内的指数。

不过为了表示起来更方便，浮点型的指数位都有一个固定的**偏移量( bias )**, 用于使 **指数 + 这个偏移量 = 一个非负整数**。有了偏移量, **指数位中始终都是一个非负整数**。

> **规定：** 在 32 位单精度类型中, 这个偏移量是 **127**。 在 64 位双精度类型中，偏移量是 **1023**。

**尾数位：**

在以二进制格式存储十进制浮点数时，首先需要把十进制浮点数表示为二进制格式，拿十进制数 20.5 举例：

十进制浮点数 20.5 = 二进制 10100.1

然后，把这个二进制数转换为以 2 为底的指数形式：

二进制 `10100.1 = 1.01001 * 2^4`

> 用二进制数表示十进制浮点数 时,，表示为**尾数*指数**的形式，并把尾数的小数点放在第一位和第二位之间，然后保证第一位数非 0，这个处理过程叫做**规范化**( normalized )

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-e319c25ffdd4b40f34096dde45ced77b_1440w.png)

我们再来看看规范化之后的这个数： `1.01001 * 2^4`

`1.01001` 是尾数，4 是偏移前的指数( unbiased exponent )，偏移后指数( biased exponent )就是 `4 + 127 = 131`，131 转换为二进制就是 1000 0011

现在还需要对尾数做一些特殊处理：

1. 隐藏高位 1

    规范化之后，尾数部分的最高位始终为 `1.` 所以在存储尾数时，可以省略前面的 1 和小数点，只记录尾数中小数点之后的部分，这样就节约了一位内存。

2. 低位补 0

    有时候尾数会不够填满尾数位，需要在低位补零, 补齐 23 位。之所以在低位补 0, 是因为尾数中存储的本质上是二进制的小数部分，所以如果想要在不影响原数值的情况下, 填满 23位，就需要在低位补零。

## 实例：表示十进制浮点数 20.5

十进制浮点数 20.5 的：

- 符号位是: `0`
- 偏移后指数位是: `1000 0011`
- 补零后尾数位是: `0100 1000 0000 0000 000`

现在，把这三部分按顺序放在 32 位浮点数容器中，就是 `0 1000 0011 0100 1000 0000 0000 000`

这里有一个可以[在线浮点数转二进制](https://tooltt.com/floatconverter/)的网站，我们来验证一下：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/SCR-20220508-f5y.png)

## 32 位浮点数的取值范围

这里先直接给出[维基](https://en.wikipedia.org/wiki/IEEE_754-1985)上的取值范围：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-63bf64dd03a14e22e04e300aaeee871d_1440w.png)

32 位浮点数的取值范围直观表示的话就是：

```js
[-340000000000000000000000000000000000000, -0.0000000000000000000000000000000000000118] ∪ [0.0000000000000000000000000000000000000118, 340000000000000000000000000000000000000]
```

### 前置知识

根据 IEEE754 的规定，按照尾数位隐藏的整数部分是 `1.` 还是 `0.` 可以将浮点数划分为两类：**normal number**(规格数) 和 **subnormal number**(非规格数)

引入 `subnormal number` 这个概念，是为了在浮点数下溢时，可以逐位的损失精度，**以尽可能精确的表达 0 附近的极小数**。

 IEEE754 规定：**如果将指数位全部填充为 0**，则表示这个数是个 `subnormal number`

和 `subnormal number` 类似，IEEE754 对于指数位全为 1 的状态也做了特殊规定：

当指数位全部被 1 填充，即指数位表示的值为 255 时，用于表示这个浮点数处在一种非正常数( non-number )的状态：即这个数可能是 `±infinity` 或 `NaN` 。

### 计算取值范围

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-ca78d279de4682dcd42f8ec28da27637_1440w.jpg)

当我们讨论浮点数的取值范围时，实际上讨论的是：`normal number` (上图中绿色部分)的范围。

可以看出，32 位浮点数的指数部分其实是无法取到 -127 和 128 的，因为：

- 用于表示 -127 的 `0000 0000` 被用来表示 `subnormal number` 了,
- 用于表示 128 的 `1111 1111` 被用来表示 `non-number` 了。

所以实际上 32 位浮点数的指数部分只能取到只能取到 `[-126, 127]`

所以尾数(含隐藏的整数部分)所表示的值的范围其实是 `[1.00...00, 1.11...11]`，这个二进制数，约等于十进制的 `[1, 2)`, 因为 `1.11..11` 非常逼近十进制的 `2`

取值范围：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-c82c3c4e76fe6e06033725ca45513633_1440w.png)

然后为了看着顺眼，我们把上式的以 2 为底, 替换为以 10 为底：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-cee80bc27473d527996851211ce1af1e_1440w.png)

从上面这个集合中，取一个更容易表示的子集, 就是我们常见的 32 位 float 的取值范围了：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-2aa6357d0b54287ab43ac3a4365a2794_1440w.png)

## 为什么说 32 位浮点数的精度是"7位有效数"

打开 IEEE754 的维基百科，可以看到其中标注着，单精度浮点数的精度是 "Approximately 7 decimal digits"。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-28e38af53fd59e0cfc058667e97bc4b0_1440w.png)

> [IEEE754 标准: 三, 为什么说32位浮点数的精度是"7位十进制数"](https://zhuanlan.zhihu.com/p/343040291)

## 其他

### 其他导致浮点数存储不精确的原因

**数学中的小数是连续的**，而计算机中的小数(准确来说是 IEEE754 标准中的小数)是离散的。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-886f0c2a7559e2cd66ab4d4c917a7a95_1440w.png)

这就会引发精度问题：图中的绿色指针只能指向蓝点，不能指向蓝点之间的数。比如上面最右边的图，绿色指针其实无法指向 0.3，当你想要指向 0.3 时, 实际上会被舍入为 0.234，即舍入到离它最近的蓝点对应的值。

**而除此之外，进制问题也会导致 IEEE754 浮点数存储不精确**。

简单来说就是：有限长度编码下，每种进制都有他们不能精确表示的值。

比如：10 进制不能精确的表示 1/3 (0.3333333.....)

十进制可以精确表示 1/5 (0.2)，但二进制无法精确表示 1/5

不能精确表示时，只能进行近似。编码长度越长，近似程度越高。

### 32 位浮点数能存储很大的整数

如果把 IEEE754 所表示的浮点数想象成一个表盘的话，那表盘上的蓝点不是均匀分布的,，而是越来间隔越大，越来越稀疏：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-d46932f28c9c5078cf22993d5985cb16_1440w.png)

32 位浮点型确实最大可以存储到 `3.4 * 10^38` 这么大的数，但精度很低。

根据 wiki 中给出的间隔，对于 `1.70141e38` 到 `3.40282e38` 范围中的数，间隔是 `2.02824e31`

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-83d9de0f5c6394fcbd347ff755621d7d_1440w.png)

也就是说，大体上：32 位浮点数中，能精确存储 `1.70141e38`

下一个能精确存储的数是：`1.70141e38 + 20282400000000000000000000000000` (即加上间隔)

所以无法精确存储 `1.70141e38 + 1`

也无法精确存储 `1.70141e38 + 2`,

也无法精确存储 `1.70141e38 + 100000000000`

### 32 位浮点数能存储很精确的小数

> 浮点数只能存储蓝点位置对应的值

正如前文所说，32 位浮点数会形成一个表盘，表盘上的蓝点逐渐稀疏。绿色指针只能指向某个蓝点，不能指向两个蓝点之间的位置。或者换句话说: **32 位浮点数只能保存蓝点对应的值**。

**如果你要保存的值不是蓝点对应的值，就会被自动舍入到离该数最近的蓝点对应的值**。

举例：

在 `0.5 ~ 1` 这个范围内, 间隔**约为** `5.96046e-8`, 即**约为** `0.00000005.96046`

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-35faa10130c724ab52b88fcf5d006020_1440w.png)

也就是说：表盘上有一个蓝点是 0.5

下一个蓝点应该是：`当前蓝点 + 间隔 ≈ 0.5 + 0.00000005.96046 ≈ 0.5000000596046`

那，如果我们要保存 **0.50000006**，也就是我们要保存的这个值，稍大于下一个蓝点:

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-6a03627668b34c78ff9452fe6df42ccb_1440w.png)

因为绿色指针必须指向蓝点，不能指向蓝点之间的位置，所以绿色指针会被"校准"到**0.5000000596046**，或者说我们要保存的**0.50000006，** 会被**舍入**为**0.5000000596046**。

事实上，每个 32 位浮点数容器中，存储的必然是一个蓝点值。

验证一下，首先求出从 0.5 开始的蓝点值：

```js
const gap = 0.0000000596046
let ret = 0.5
let i = 0

while (i < 10) {
  ret = ret + gap
  console.log(ret)
  i++
}

// 0.5000000596046
// 0.5000001192092001
// 0.5000001788138001
// 0.5000002384184001
// 0.5000002980230002
// 0.5000003576276002
// 0.5000004172322002
// 0.5000004768368003
// 0.5000005364414003
// 0.5000005960460003
// 这样 0.5000001 在内存中就可以对应不止一个蓝点了，也就是 0.5000001 是可以表示精确的，是可以唯一对应一个内存变量。
// 比如 0.50000011 在内存中可以找到，0.50000012 在内存中就找不到了，所以精度丢失了。
// 本质上就是想以无限表达有限
```

### 浮点数运算三步骤

- 对阶
- 求和
- 规格化

#### 对阶

浮点数加减首先要判断两数的**指数位**是否相同（**小数点位置是否对齐**），若两数指数位不同，需要对阶保证指数位相同。

对阶时遵守**小阶向大阶看齐原则**，尾数向右移位，每移动一位，**指数位加 1 直到指数位相同**，即完成对阶。

示例，`0.1` 的阶码为 `-4` 小于 `0.2` 的阶码 `-3`，故对 `0.1` 做移码操作

```js
// 0.1 移动之前
0 01111111011 1001100110011001100110011001100110011001100110011010

// 0.1 右移 1 位之后尾数最高位空出一位，（0 舍 1 入，此处舍去末尾 0，如果是 1 需要舍弃 1，并且整体做 +1 操作）
0  01111111100 [最高位]100110011001100110011001100110011001100110011001101(-0)

// 0.1 右移 1 位完成
0  01111111100  1100110011001100110011001100110011001100110011001101
```

尾数右移 1 位之后最高位空出来了，如何填补呢？涉及两个概念：

- 逻辑右移：最高位永远补 `0`
- 算术右移：**不改变最高位值**，是 `1` 补 `1`，是 `0` 补 `0`（最高位为 `1.` 或 `0.`）。

#### 尾数求和

两个尾数直接求和

```js
// 0.1 => 1.10011... * 2^-4
// 0.2 => 1.10011... * 2^-3
// 对其小数点
// 0.110011... * 2 ^-3 + 1.10011... * 2^-3
  0  01111111100   1100110011001100110011001100110011001100110011001101 // 0.1
+ 0  01111111100   1001100110011001100110011001100110011001100110011010 // 0.2
= 0  01111111100 100110011001100110011001100110011001100110011001100111 // 产生进位，待处理
```

### 规格化和舍入

由于产生进位，阶码需要 `+1` 未偏移指数为 `-2`，此时符号位、指数位如下所示：

尾部进位 `2` 位，去除最高位默认的 `1`，因最低位为 `1` 需进行舍入操作（在二进制中是以 0 结尾的），舍入的方法就是在最低有效位上加 1，若为 0 则直接舍去，若为 1 继续加 1

```js
  100110011001100110011001100110011001100110011001100111 // + 1
=  00110011001100110011001100110011001100110011001101000 // 去除最高位默认的 1
=  00110011001100110011001100110011001100110011001101000 // 最后一位 0 舍去
=  0011001100110011001100110011001100110011001100110100  // 尾数最后结果
```

IEEE 754 中最终存储如下：

```js
// 2^-2 * 1.0011001100110011001100110011001100110011001100110100
0  01111111101 0011001100110011001100110011001100110011001100110100
```

## 参考资料

- [IEEE754标准: 一 , 浮点数在内存中的存储方式](https://zhuanlan.zhihu.com/p/343033661)
- [IEEE754标准: 二, 32位浮点数的取值范围](https://zhuanlan.zhihu.com/p/343037540)
- [JavaScript 浮点数之迷：0.1 + 0.2 为什么不等于 0.3？](https://github.com/qufei1993/blog/issues/9)
- [JavaScript 浮点数之迷下：大数危机](https://github.com/qufei1993/blog/issues/10)
