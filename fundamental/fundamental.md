# 计算机知识图谱

## 计算机系统 64 位 32 位指的是什么

<https://www.youtube.com/watch?v=Wu2A4fpFzgs>

## 复杂指令集 CISC 和精简指令集 RISC

我们可以继续举个例子，比如说我们要命令一个人吃饭，那么我们应该怎么命令呢？我们可以直接对他下达“吃饭”的命令，也可以命令他“先拿勺子，然后舀起一勺饭，然后张嘴，然后送到嘴里，最后咽下去”。

从这里可以看到，对于命令别人做事这样一件事情，不同的人有不同的理解，有人认为，如果我首先给接受命令的人以足够的训练，让他掌握各种复杂技能（即在硬件中实现对应的复杂功能），那么以后就可以用非常简单的命令让他去做很复杂的事情——比如只要说一句“吃饭”，他就会吃饭。

但是也有人认为这样会让事情变的太复杂，毕竟接受命令的人要做的事情很复杂，如果你这时候想让他吃菜怎么办？难道继续训练他吃菜的方法？我们为什么不可以把事情分为许多非常基本的步骤，这样只需要接受命令的人懂得很少的基本技能，就可以完成同样的工作，无非是下达命令的人稍微累一点——比如现在我要他吃菜，只需要把刚刚吃饭命令里的“舀起一勺饭”改成“舀起一勺菜”，问题就解决了，多么简单。这就是“复杂指令集”和“精简指令集”的逻辑区别。

> [分不清ARM和X86架构，别跟我说你懂CPU！](https://zhuanlan.zhihu.com/p/21266987)

## 基于 IEEE 754 标准的双精度 64 位的浮点数

> [从科学记数法到浮点数标准 IEEE 754](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)

## 位运算

### 进制转换

![二进制与十进制转换方法](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/terminal/SCR-20220408-acz.png)

### 原码、反码、补码

> 参考

- [JavaScript 中的位运算和权限设计](https://juejin.cn/post/6844903988945485837)
- [一文搞明白位运算、补码、反码、原码](https://juejin.cn/post/6844903912425259022)

## 进程、线程

不请自来。
看见上面几位的回答我真的是醉了。说几句我的理解。
首先来一句概括的总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述。是运行中的程序指令的一种描述，这需要与程序中的代码区别开来。

另外注意这里我说的进程线程概念，和编程语言中的API接口对应的进程/线程是有差异的。

下面细说背景：
CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备则难以望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。而且因为速度差异，CPU实际的执行时间和等待执行的时间是数量级的差异。比如工作1秒钟，休息一个月。所以多个任务，轮流着来，让CPU不那么无聊，给流逝的时间增加再多一点点的意义。这些任务，在外在表现上就仿佛是同时在执行。

一个必须知道的事实：执行一段程序代码，实现一个功能的过程之前 ，当得到CPU的时候，相关的资源必须也已经就位，就是万事俱备只欠CPU这个东风。所有这些任务都处于就绪队列，然后由操作系统的调度算法，选出某个任务，让CPU来执行。然后就是PC指针指向该任务的代码开始，由CPU开始取指令，然后执行。

这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了的进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。

串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载进程A的上下文，然后开始执行A，保存进程A的上下文，调入下一个要执行的进程B的进程上下文，然后开始执行B,保存进程B的上下文。。。。

========= 重要的东西出现了========
进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。

进程就是上下文切换之间的程序执行的部分。是运行中的程序的描述，也是对应于该段CPU执行时间的描述。
在软件编码方面，我们说的进程，其实是稍不同的，编程语言中创建的进程是一个无限loop，对应的是tcb块。这个是操作系统进行调度的单位。所以和上面的cpu执行时间段还是不同的。
进程，与之相关的东东有寻址空间，寄存器组，堆栈空间等。即不同的进程，这些东东都不同，从而能相互区别。
线程是什么呢？
进程的颗粒度太大，每次的执行都要进行进程上下文的切换。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：

程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。

这里a，b，c的执行是共享了A进程的上下文，CPU在执行的时候仅仅切换线程的上下文，而没有进行进程上下文切换的。进程的上下文切换的时间开销是远远大于线程上下文时间的开销。这样就让CPU的有效使用率得到提高。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。线程主要共享的是进程的地址空间。

到此全文结束，再一个总结：

进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。

注意这里描述的进程线程概念和实际代码中所说的进程线程是有区别的。编程语言中的定义方式仅仅是语言的实现方式，是对进程线程概念的物化。

我们先来做一个思维实验. 想象一下我们有一台最简单的计算机.

我们先完全不考虑什么操作系统什么虚拟内存, 就当这些东西完全不存在.

这台 "计算机" 的全部功能就是每秒钟神奇地从 "磁盘" 找到一条指令, 送入 "CPU" , 让 "CPU" 按顺序执行.

假设磁盘上有个程序A, 里面包含17条指令, 那么我们的计算机就需要17秒去完成这个程序. 而这17秒之内, 我们的计算机无法做别的事情. 这看起来很蠢不是么? 想象一下一台电脑无法边打字边听音乐.

所以我们要对计算机做出改进, 让他能够交替的执行程序A程序B程序C程序D.

再一次假设全知全能的我们完成了对计算机的改造, 现在我们的计算机可以做到同时执行多个程序.

还是那个拥有17条指令的程序A和一个拥有42条指令的程序B. 我们可以先执行一秒钟程序A, 再执行一秒钟程序B, 再执行一秒钟程序A. 看上去在同时执行两条程序似的.

那程序A对应的进程到底是什么? 是那17条指令? 是那17秒钟? 好像都不是.

进程A就是处理这17条指令的过程; 而进程B就是处理这42条指令的过程.

什么? 进程就是过程? process is process? 这说了和没说有什么区别?

没错, 很遗憾的说, 对于一个还未入门的人来说, 这就是最低程度的抽象了.

你看, 哪怕是最最简单的计算机, 我们依旧无法说清「进程到底是什么」.

因为进程这个概念本身就是抽象的.

关于「进程是什么」的回答在网络上到处都是, 而你却特地跑来知乎问, 说明你对那些文章都不满意, 你希望得到一个很漂亮的回答, 一个让人一眼看过去就茅塞顿开的回答. 实际上这是很难的. 就好比人们总是希望一句话就说清楚生活的意义是什么. 实际上也是很难的.

费曼在<The Feynman Lectures on Physics>里说过微观世界无论是对新手还是物理学家都是抽象的. 而我们的教科书却还是试图用行星绕着太阳这样的模型去描述电子绕着质子.

Things on a very small scale behave like nothing that you have any direct experience about. They do not behave like waves, they do not behave like particles, they do not behave like clouds, or billiard balls, or weights on springs, or like anything that you have ever seen. (...)
Because atomic behavior is so unlike ordinary experience, it is very difficult to get used to, and it appears peculiar and mysterious to everyone--both to the novice and the experienced physicist.
所以我到底想要表达什么呢?

大概就是: 怀揣着这种不确定感继续学习, 不要有智识包袱, 不要假装自己很聪明. 这个世界本身就是抽象又复杂的. 这没什么大不了.
