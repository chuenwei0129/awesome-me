大概是因为青春时对美好的悸动与希望吧，年与时驰，意与日去，只能从回忆中捕捉一些心脏鲜活跳动过的痕迹。曾经紧实的肌肤，笑成月芽样的天真，最幼稚却又最无所畏惧的付出，那是生命中最融融的春和最辉煌的夏一起肆意挥洒，还以为天地间一个我，是多么畅快和恣意。终于淹没在尘世烟火之中，才知道天地间一个我，是多么渺小和卑微。

要说我的 UI 库有没有用，我觉得是鬼用都木有哇，仅仅是想看看实现出来是怎么样的。诶，就是玩儿~

不冗余。写代码写多了就能体会，一个不可变的东西往往比一个可变的类似物要更有用。

四种常见的基本复合数据结构：最基本的就是tuple，数字下标，不可变tuple加上literal下标，就是record，也就是python里的namedtupletuple加上可变性，就是array，或者python里的listrecord加上可变性，或者list加上literal下标，就是dict基本原则是，要使用满足要求的前提下功能最少的东西，也就是当你不需要可变性的时候下，就用tuple record，避免用list dict，否则可变性将成为你维护的负担，bug的来源。你看比如js里面语言层面不支持不可变的array和object，结果大家只能自己造各种immutable的轮子。。。

只有静态资源才需要http缓存。业务数据如果要缓存，也不该依赖http。
有人问，那get缓存怎么办？缓存这种东西还是不要交给浏览器和http协议的好吧，太不好控制了。真正需要缓存的时候，我会在前端里搞类似apollo client或react query那样的缓存，或者在后端应用层或redis层搞，可以精确地控制何时把哪些过期的缓存干掉。人生苦短，单单为了一个http协议就维护一套管理query string和cache header的转换层，感觉不值得。都搞成跨协议通用的缓存管理代码，挺好。

作者：beeplin
链接：https://www.zhihu.com/question/336797348/answer/2199428816
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

有人问，那get缓存怎么办？缓存这种东西还是不要交给浏览器和http协议的好吧，太不好控制了。真正需要缓存的时候，我会在前端里搞类似apollo client或react query那样的缓存，或者在后端应用层或redis层搞，可以精确地控制何时把哪些过期的缓存干掉。人生苦短，单单为了一个http协议就维护一套管理query string和cache header的转换层，感觉不值得。都搞成跨协议通用的缓存管理代码，挺好。

作者：beeplin
链接：https://www.zhihu.com/question/336797348/answer/2199428816
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

最后，react和vue都支持jsx，这个jsx就是个哲学问题了，看你是信仰三分离，还是信仰all in js


<!-- 🥤 原汁原味 TypeScript  
○ 直接基于 TypeScript type 和 interface 定义协议  
○ 无需额外注释，无需 Decorator，无需第三方 IDL 语言  
👓 自动类型检查  
○ 在编译时刻和运行时刻，自动进行输入输出的类型检查  
○ 总是类型安全，放心编写业务代码  
🔥 史上最强大的 TypeScript 二进制序列化  
○ 无需任何注解，直接实现将 TypeScript 源码中的类型定义序列化（设置支持 Union Type、Intersection Type 这样的复杂动态类型，ProtoBuf也无法做到）  
○ 比 JSON 更小的传输体积、更多的数据类型：如 Date, ArrayBuffer, Uint8Array 等  
○ 方便地实现二进制加密  
☎ 多协议  
○ 同时支持 HTTP / WebSocket  
💻 多平台  
○ NodeJS / 浏览器 / App / 小程序  
⚡️ 高性能  
○ 单核单进程 5000+ QPS 吞吐量（测试于 Macbook Air M1, 2020) -->

前端~api~后端~数据库

面向对象
感觉树形结构在复杂需求面前不堪一击
应该说是声明式不够用

第一层, 跨组件 A B 用到同个状态, 要尝试组件 A 存的状态跟随组件 B 存的状态更新, 可能是通过事件进行,
第二层, 提升一个状态到父组件当中反过来分发到多个子组件, 来保持状态一致,
第三层, 太多位置, 或者想个太远的位置用到同个状态, 单纯传递事件或者蹭蹭 props 费代码, 转而依赖全局的 message bus (或者其变种)来完成.
(此外再有个极端方案是类似游戏当中, 所有状态保存全局, 然后 60fps 直接整体刷新.)

以我有限的经验来看，编程语言的各种特性中，唯一可以说是明确有害的是「继承」这个早期科学家拍脑袋想出来的方案。(拍脑袋想出来继承，本质上也是受当时硬件能力和编译技术所限，如今内存白菜价，人类对编译技术有深入理解之后，新兴语言基本上都摒弃了继承)

最强多态是「鸭子类型」但鸭子类型无法在编译时检查以优化性能，所以新兴语言普遍采用了protocol/trait等技术来实现接近鸭子类型的灵活度，并保留了编译型语言的性能。

之所以说继承是编译技术落后的产物，是因为早期软件复杂度不是那么高，所以科学家们出于直觉地进行了“在数据上添加操作(函数地址)，并复用这个操作”的设计，而后来随着软件规模的增长，才意识到继承带来的强耦合，转而使用组合，编程思想也转变为“为某一个struct实现某一个interface”而不是“用class来表示一个有某些操作的数据”。

新兴语言的基本组成都是 immutable struct + protocol/trait 了，相当于 没有继承的不可变的class + 独立在数据之外的interface的implements

duck type并不先进，这种类型系统往往会破坏封装破坏整体架构逻辑，而且不够sound，很多问题编译期发现不了，特别对于不能轻易表达对duck type语法约束的语言如c++，代码报错都不看懂。反之面向接口仍是目前组织大型软件的不二法门。

懂了，组合

<!-- 以前的 react -->
继承复用，一层套一层，那么如何保证数据方法绑定呢，面向类 class 就是约束
组合，闭包，在组合函数外面包上一层，闭包保存数据


复用，逻辑没有绑定 state，

我有一个问题，没想清楚。我有一个小狗的Class组件，如果要修改eat这个方法，我继承覆写一下就行了。
现在换成了hook，我把所有的逻辑和数据封装到hook里了。
那么我要做一个新组件，就要把所有hook，整起来，拼成一个新的函数组件。这样的操作简单么？封装，继承体现在哪里了？
05-16
·
IP 属地北京
​回复
​赞
Ryou ikonn
Ryou ikonn
hooks实现相当于狗 你要重新把狗的组成元素引进来 而不是只重写eat。hooks本身对于组织形式的复用就不如class的

业务层本来就不需要继承，就是获取数据，转换数据结构，数据流转，渲染数据，导出数据等等。归根到底就是对数据的处理，这一层还是函数简单一点

面向对象真的就是一个无比糟糕的编程概念。其实对象这个玩意唯一解决的问题是把数据和相关的逻辑统一了起来。

polyfill 标准 API 运行时补丁这种修改内置对象原型的库，在原有对象方法前后加新标准逻辑，就是装饰模式。推而广之，所有函数式编程当中的高阶函数，其实都是在原函数前后加特定逻辑的装饰模式应用。自然 React 常说的高阶组件也是装饰模式；在面向对象层面，装饰器语法就是这个模式的直接实现。

面向对象不是银弹，就像函数式编程也不是银弹一样。其实前端现在最常用的模式也就是装饰模式，代码量大了自然就学到那里了。

人类一直就是用分类思维的。（所以叫人类啊。）
但是，只有"上帝"才能驾驭好分类呀

面向对象抽象的是数据和操作，声明式抽象的是过程

自然界中的任何事物都可以被分类，但同时可以在不同的领域和场景下分成不同的类。面向类的编程不能很好地解决一个人物有多种能力和角色的问题。go的interface对面向对象的实现，更符合事物的多重分类的特征。而js的对象动态改变，更符合自然界中事物可变化的规律。

面向对象抽象是向上一层的，共同逻辑，操作某一数据的方法相同，写里面写外面

oop的特征是封装，继承，多态，是实现高度抽象和个性化这些目标的一种编程方法。FP是另一种编程方法，同样可以实现高度抽象和个性化这些目标。oop与FP有异曲同工之妙！
fp和oop都是编程的核心思想，fp是pipe的思想，只关系输入输出，确定的输入有着确定的输出。fp并不是编程风格这么简单

挖坑填坑，本来就是常态，不是问题，技术进步最大的问题是，不会反思。

gui 应用的本质确实不是静止的 f(x)，而是运动的 f(observable)。如果按照这样的方法来理解 gui，现在的 react 没有问题。如果按照 widget 组合的方式来理解 gui，可能推导出 oop 才是最适合。
实际上 gui 有两种常见的 api 风格，保留模式 和 立即模式。前者接近 oop，后者接近 fp。

存函数，波里状态

mark一个吧。UI是系统状态的展示器，也是用户行为的接收器。前者是离散的，而后者是连续的。不能用状态机范式一概而论

我不清楚vue和React，但我清楚c++里面的变迁。

在某些业务，继承是极不常用的。因为类和类之间很少能找到共性，反而需要一个类中携带其他类的信息。one loop per thread这种reactor模型中也是组合聚合用得比较多。

函数一等公民，也和面向对象不矛盾。在没有class的年代，js的函数一等公民加上词法作用域，带来的闭包特性，也是一种经典的面向对象的手段，所谓“闭包是穷人的对象”嘛。访问限定、封装、隔离，都可以用闭包搞定。而多态这种特性。。。JS这种鸭子类型的动态语言难道不是天然支持多态吗？多态搞起来比TS方便多了。

函数一等公民，也和面向对象不矛盾。在没有class的年代，js的函数一等公民加上词法作用域，带来的闭包特性，也是一种经典的面向对象的手段，所谓“闭包是穷人的对象”嘛。访问限定、封装、隔离，都可以用闭包搞定。而多态这种特性。。。JS这种鸭子类型的动态语言难道不是天然支持多态吗？多态搞起来比TS方便多了。

泻药，对于连自己去年拉的屎都认不出来，无法评判别人的shit

那。。不用组合用啥。。？总不能用继承这种大坑吧。。而且说白了依赖注入和AOP不就是组合吗。？还是说你发现了更好的办法。？愿闻其详

composition api和hooks容易乱，根本原因是把本应该放在model层的逻辑放在view层了。这是人的问题。
vue和react的绝大多数用户不知道严格区分mvvm的重要性，也没有设计领域模型的经验。
框架其实是用来帮我们解决数据绑定和局部/临时状态的。承担的是vm层和部分v层内部自己的mvc体系(这个v内部可以是一个mvc)。所以我觉得这不能说是这两个框架的设计缺陷，而是没能阻止用户的不良实践。
UI开发的主要工作量其实在model的设计，但是实际情况是太多人把东西一股脑都写到组件里了。

只要在使用层 逻辑上 是immutable 的就可以，忽略掉细节。

类是封装的，添加属性不影响对象操作(除非你要对新属性操作)，但更改操作就略复杂，多态，接口神马的……
函数式编程对数据的加工是链式的，你可以对一个参数用多个方法(函数，过程)处理，还可以任意增删，但是参数个数变化的时候……

编程说穿了就是两个方面，data和这些data上的operation,

oop, 就是让operation 围绕data， 这样的好处是，当你要添加新的data type的时候，好方便! 原来写的代码都不用改。 但是你要给已经写好的data type添加方法怎么办？ 比如我要你给java自带的string 加个 python那种乘法。

functional programming采取的是另一种思路，data更多的围绕operation， 所以添加新的方法很容易。

这就是著名的the expression problem. 谁优谁劣，要看应用场景，写GUI用oop好不畅快，写interpreter我更喜欢函数式的。

在我看来这些都是idiom， 不是宗教，具体问题具体分析。 但是学习functional programming绝对大有裨益，因为国内的计算机教育太强调图灵模型（也就是C语言一脉）了，而对lambda calculus涉及太少，造成了很多偏见和误解，我不只一次在知乎上看到，学好C语言，其他高级语言都很容易理解的论调，明显就是受了这种教育的荼毒。
