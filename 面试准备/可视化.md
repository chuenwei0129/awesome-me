
![20240311222911](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240311222911.png)

<!-- 但d3是数据驱动文档，而threejs是3D图形库，它们的作用是不一样的。 -->

1. 可视化是将数据组织成易于为人所理解 和认知的结构，然后用图形的方式形象地呈现出来的理论、方法和技术。
2. 实现可视化有两个 关键要素，一个是数据，另一个是图形。如果要考虑在计算机上呈现，那还要加上交互。
3. 这是因为，Web 开发以呈现块状内容为 主，所以 HTML 是更合适的技术。而可视化开发因为需要呈现各种各样的形状、结构，所 以，形状更丰富的 SVG 以及更底层的 Canvas2D 和 WebGL 就是更合适的技术了。
4. 其一，可视化与 Web 前端一样，最终都是以图像呈现在浏览器上，因此有许多通用的方法 论。比如，两者都要涉及 DOM、都要处理浏览器事件、都采用同样的颜色表达方式和同样 的资源请求方法等等。
其二，二者都使用 JavaScript，而且都是浏览器端的 JavaScript。所以，就 JavaScript 的应用而言，这一块差别并不大。不过，可视化应用面对的数据和渲染的图形元素都比传统 的 Web 应用更复杂一些，所以也就更加依赖 JavaScript 一些。
可视化领域经过多年的发展，有非常多丰富的工具。我们可以把这些工具大体上分为四类， 分别是:专业呈现各种类型图表的图表库;专业处理地图、地理位置的可视化地理库;专业 处理视觉呈现的渲染库;以及处理数据的数据驱动框架。

社区中有许多优秀的开源图表库，比如我们前面说的 ECharts，或者类似的chartlist、  chart.js等等，它们都属于图表库。

社区中比较成熟的 GIS 库也不 少，比较常见的像  Mapbox、  Leaflet、  Deck.gl、  CesiumJS等等。

除了这些库之外，还有一类比较特殊的库，比如  D3.js，它属于数据驱动框架。那什么是 数据驱动框架呢?这是一种特殊的库，它们更专注于处理数据的组织形式，而将数据呈现交

给更底层的图形系统(DOM、SVG、Canvas)或通用图形库(SpriteJS、ThreeJS)去完 成。

ECharts 等大部分图表库会提供封装好的图表类型，我们只需要简单配置一下参数就可以使 用。但正因为如此，图表能够表现的形式也会被预设的图表类型和封装好的参数所固定了。 如果我们想做一些非常个性化的视觉呈现形式，用图表库来做，相对就比较困难。而 D3.js 因为只关注数据的组织形式，将具体的渲染交给底层去做，所以更加灵活，扩展起来也很方 便。但相对地，就不像其他的图表库一样，拥有完整的封装了，使用的门槛也就相对高一 些。

最近做一个需求是将很多小的病理切片拼成一个大图，能放大缩小倍数还能在图片上做标 记的需求。老师有没有推荐的现成的库可以使用?
展开
作者回复: 这个似乎类似于瓦片地图，用leaflet这样的地图的库是不是可以，你可以研究下

上一节课我们了解了什么是可视化。可视化用一句话来说，本质上就是将数据信息组织起来 后，以图形的方式呈现出来。在 Web 上，图形通常是通过浏览器绘制的。现代浏览器是一 个复杂的系统，其中负责绘制图形的部分是渲染引擎。渲染引擎绘制图形的方式，我总结了 一下，大体上有 4 种。
第 1 种是传统的 HTML+CSS。这种方式通常用来呈现普通的 Web 网页。

 第 2 种是使用 SVG。SVG 和传统的 HTML+CSS 的绘图方式差别不大。只不过，HTML 元素在绘制矢量图形方面的能力有些不足(我们后面会讲到)，而 SVG 恰好弥补了这方面 的缺陷。
第 3 种是使用 Canvas2D。这是浏览器提供的 Canvas API 中的其中一种上下文，使用它 可以非常方便地绘制出基础的几何图形。在可视化中，Canvas 比较常用，下一节课我们会 学习它的基本用法。
第 4 种是使用 WebGL。这是浏览器提供的 Canvas API 中的另一种上下文，它是 OpenGL ES 规范在 Web 端的实现。我们可以通过它，用 GPU 渲染各种复杂的 2D 和 3D 图形。值得一提的是，WebGL 利用了 GPU 并行处理的特性，这让它在处理大量数据展现 的时候，性能大大优于前 3 种绘图方式。因此，在可视化的应用中，一些数据量大、视觉 效果要求高的特殊场景，使用 WebGL 渲染是一种比较合适的选择。

用 CSS 实现柱状图其实很简单，原理就是使用网格布局(Grid Layout)加上线性渐变 (Linear-gradient)，我就不多说了，你可以直接看我这里给出的 CSS 代码。

首先，HTML 和 CSS 主要还是为网页布局而创造的，使用它们虽然能绘制可视化图表，但 是绘制的方式并不简洁。这是因为，从 CSS 代码里，我们很难看出数据与图形的对应关 系，有很多换算也需要开发人员自己来做。这样一来，一旦图表或数据发生改动，就需要我 们重新计算，维护起来会很麻烦。
其次，HTML 和 CSS 作为浏览器渲染引擎的一部分，为了完成页面渲染的工作，除了绘制 图形外，还要做很多额外的工作。比如说，浏览器的渲染引擎在工作时，要先解析 HTML、SVG、CSS，构建 DOM 树、RenderObject 树和 RenderLayer 树，然后用 HTML(或 SVG)绘图。当图形发生变化时，我们很可能要重新执行全部的工作，这样的 性能开销是非常大的。

而可视化与传统网页不同，它不太需要复杂的布局，更多的工作是在绘图和数 据计算。所以，对于可视化来说，这些额外的工作反而相当于白白消耗了性能。

![20240311230200](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240311230200.png)

svg
现代浏览器支持 SVG(Scalable Vector Graphics，可缩放矢量图)，SVG 是一种基于 XML 语法的图像格 式，可以用图片(img 元素)的 src 属性加载。而且，浏览器更强大的是，它还可以内嵌 SVG 标签，并且像操作普通的 HTML 元素一样，利用 DOM API 操作 SVG 元素。甚至， CSS 也可以作用于内嵌的 SVG 元素。

从上面的 SVG 代码中，我们可以一目了然地看出，数据 total 和 current 分别对应 SVG 中 两个 g 元素下的 rect 元素的高度。也就是说，元素的属性和数值可以直接对应起来。而 CSS 代码并不能直观体现出数据的数值，需要进行 CSS 规则转换。

但是，SVG 图表也有缺点。在渲染引擎中，SVG 元素和 HTML 元素一样，在输出图形前 都需要经过引擎的解析、布局计算和渲染树生成。而且，一个 SVG 元素只表示一种基本图 形，如果展示的数据很复杂，生成图形的 SVG 元素就会很多。这样一来，大量的 SVG 元 素不仅会占用很多内存空间，还会增加引擎、布局计算和渲染树生成的开销，降低性能，减 慢渲染速度。这也就注定了 SVG 只适合应用于元素较少的简单可视化场景。

无论是使用 HTML/CSS 还是 SVG，它们都属于声明式绘图系统，也就是我们根据数据创建 各种不同的图形元素(或者 CSS 规则)，然后利用浏览器渲染引擎解析它们并渲染出来。 但是 Canvas2D 不同，它是浏览器提供的一种可以直接用代码在一块平面的“画布”上绘 制图形的 API，使用它来绘图更像是传统的“编写代码”，简单来说就是调用绘图指令，然 后引擎直接在页面上绘制图形。这是一种指令式的绘图系统。

总结来说，Canvas 能够直接操作绘图上下文，不需要经过 HTML、CSS 解析、构建渲染 树、布局等一系列操作。因此单纯绘图的话，Canvas 比 HTML/CSS 和 SVG 要快得多。

但是，因为 HTML 和 SVG 一个元素对应一个基本图形，所以我们可以很方便地操作它 们，比如在柱状图的某个柱子上注册点击事件。而同样的功能在 Canvas 上就比较难实现 了，因为对于 Canvas 来说，绘制整个柱状图的过程就是一系列指令的执行过程，其中并没 有区分“A 柱子”、“B 柱子”，这让我们很难单独对 Canvas 绘图的局部进行控制。不 过，这并不代表我们就不能控制 Canvas 的局部了。实际上，通过数学计算我们是可以通过 定位的方式来获取局部图形的，在后续的课程中我们会解决这个问题。

这里有一点需要你注意，Canvas 和 SVG 的使用也不是非此即彼的，它们可以结合使用。 因为 SVG 作为一种图形格式，也可以作为 image 元素绘制到 Canvas 中。举个例子，我 们可以先使用 SVG 生成某些图形，然后用 Canvas 来渲染。这样，我们就既可以享受 SVG 的便利性，又可以享受 Canvas 的高性能了。

今天，我们介绍了四种可视化实现方式和它们的优缺点。
HTML+CSS 的优点是方便，不需要第三方依赖，甚至不需要 JavaScript 代码。如果我们 要绘制少量常见的图表，可以直接采用 HTML 和 CSS。它的缺点是 CSS 属性不能直观体现 数据，绘制起来也相对麻烦，图形复杂会导致 HTML 元素多，而消耗性能。
SVG 是对 HTML/CSS 的增强，弥补了 HTML 绘制不规则图形的能力。它通过属性设置图 形，可以直观地体现数据，使用起来非常方便。但是 SVG 也有和 HTML/CSS 同样的问 题，图形复杂时需要的 SVG 元素太多，也非常消耗性能。
Canvas2D 是浏览器提供的简便快捷的指令式图形系统，它通过一些简单的指令就能快速 绘制出复杂的图形。由于它直接操作绘图上下文，因此没有 HTML/CSS 和 SVG 绘图因为 元素多导致消耗性能的问题，性能要比前两者快得多。但是如果要绘制的图形太多，或者处 理大量的像素计算时，Canvas2D 依然会遇到性能瓶颈。
WebGL 是浏览器提供的功能强大的绘图系统，它使用比较复杂，但是功能强大，能够充分 利用 GPU 并行计算的能力，来快速、精准地操作图像的像素，在同一时间完成数十万或数 百万次计算。另外，它还内置了对 3D 物体的投影、深度检测等处理，这让它更适合绘制 3D 场景。

![20240311231433](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240311231433.png)

这里有一点需要特别注意，Canvas 元素上的 width 和 height 属性不等同于 Canvas 元素 的 CSS 样式的属性。这是因为，CSS 属性中的宽高影响 Canvas 在页面上呈现的大小，而 HTML 属性中的宽高则决定了 Canvas 的坐标系。为了区分它们，我们称 Canvas 的 HTML 属性宽高为画布宽高，CSS 样式宽高为样式宽高。

在实际绘制的时候，如果我们不设置 Canvas 元素的样式，那么 Canvas 元素的画布宽高就 会等于它的样式宽高的像素值，也就是 512px。

因为画布宽高决定了可视区域的坐标范围，所以 Canvas 将画布宽高和样式宽高分开的做

![20240311233830](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240311233830.png)

Canvas 的坐标系和浏览器窗口的坐标系类似，它们都默认左上角为坐标原点，x 轴水平向 右，y 轴垂直向下

![20240311234338](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240311234338.png)

另外，如果我们再考虑旋转或者三维运动，这个坐标系就会变成“左手系”。而左手系的平
面法向量的方向和旋转方向，和我们熟悉的右手系相反。如果你现在还不能完全理解它们的
区别，那也没关系，在实际应用的时候，我会再讲的，这里你只需要有一个大体印象就可以
了。

我们拿到的 context 对象上会有许多 API，它们大体上可以分为两类:一类是设置状态的 API，可以设置或改变当前的绘图状态，比如，改变要绘制图形的颜色、线宽、坐标变换等 等;另一类是绘制指令 API，用来绘制不同形状的几何图形。


其中，context.rect 是绘制矩形的 Canvas 指令，它的四个参数分别表示要绘制的矩形的 x、y 坐标和宽高。在这里我们要绘制的正方形宽高都是 100，所以后两个参数是 100 和 100。

第一种方式很简单，它直接改变了我们要绘制的图形顶点的坐标位置，但如果我们绘制的不
是矩形，而是很多顶点的多边形，我们就需要在绘图前重新计算出每个顶点的位置，这会非
常麻烦。
第二种方式是对 Canvas 画布的整体做一个平移操作，这样我们只需要获取中心点与左上角 的偏移，然后对画布设置 translate 变换就可以了，不需要再去改变图形的顶点位置。不 过，这样一来我们就改变了画布的状态。如果后续还有其他的图形需要绘制，我们一定要记 得把画布状态给恢复回来。好在，这也不会影响到我们已经画好的图形。

除了使用反向平移的恢复方式以外，Canvas 上下文还提供了 save 和 restore 方法，可以 暂存和恢复画布某个时刻的状态。其中，save 指令不仅可以保存当前的 translate 状态， 还可以保存其他的信息，比如，fillStyle 等颜色信息。 而 restore 指令则可以将状态指令 恢复成 save 指令前的设置。操作代码如下:


首先，Canvas 是一个非常简单易用的图形系统。结合刚才的例子你也能感受到，Canvas 通过一组简单的绘图指令，就能够方便快捷地绘制出各种复杂的几何图形。
另外，Canvas 渲染起来相当高效。即使是绘制大量轮廓非常复杂的几何图形，Canvas 也 只需要调用一组简单的绘图指令就能高性能地完成渲染。这个呀，其实和 Canvas 更偏向于 渲染层，能够提供底层的图形渲染 API 有关。那在实际实现可视化业务的时候，Canvas 出 色的渲染能力正是它的优势所在。
不过 Canvas 也有缺点，因为 Canvas 在 HTML 层面上是一个独立的画布元素，所以所有 的绘制内容都是在内部通过绘图指令来完成的，绘制出的图形对于浏览器来说，只是 Canvas 中的一个个像素点，我们很难直接抽取其中的图形对象进行操作。
比如说，在 HTML 或 SVG 中绘制一系列图形的时候，我们可以一一获取这些图形的元素 对象，然后给它们绑定用户事件。但同样的操作在 Canvas 中没有可以实现的简单方法(但 是我们仍然可以和 Canvas 图形交互，在后续课程中我们会有专门讨论)。下一节课中，我 们会详细讲解 SVG 图形系统，到时你就会更加明白它们的差异具体是什么了。

1. 在 HTML 中建立画布时，我们要分别设置画布宽高和样式宽高;
2. 在建立坐标系时，我们要注意 canvas 的坐标系和笛卡尔坐标系在 y 轴上是相反的;
3. 如果要把图形绘制在画布中心，我们不能直接让 x、y 的坐标等于画布中心坐标，而是要 让图形中心和画布中心的位置重叠。这个操作，我们可以通过计算顶点坐标或者 平移变 换来实现。
接着，我们讲了利用 Canvas 展示数据的层级关系。在这个过程中，我们应当先处理数据， 将数据内容与绘图指令建立映射关系，然后遍历数据，通过映射关系将代表数据内容的参数 传给绘图指令，最后将图形绘制到 Canvas 上。
另外，我们还讲了 Canvas 的优缺点。在实际实现可视化业务的时候，Canvas 的简单易操 作和高效的渲染能力是它的优势，但是它的缺点是不能方便地控制它内部的图形元素。
最后，我还有一点想要补充一下。我们今天绘制的图形都是静态的，如果要使用 Canvas 绘 制动态的图形也很简单，我们可以通过 clearRect 指令，将之前的图形擦除，再把新的图形 绘制上去即可。在后续课程中，我们有专门的章节来介绍动画。
在第 1 节课我们讲过，SVG 属于声明式绘图系统，它的绘制方式和 Canvas 不同，它不需
要用 JavaScript 操作绘图指令，只需要和 HTML 一样，声明一些标签就可以实现绘图了。

因为 SVG 坐标系和 Canvas 坐标系完全一样，都是以图像左上角为原点，x 轴向右，y 轴 向下的左手坐标系。而且在默认情况下，SVG 坐标与浏览器像素对应，所以 100、50、40 的单位就是 px，也就是像素，不需要特别设置。
说到这，你还记得吗?在 Canvas 中，为了让绘制出来的图形适配不同的显示设备，我们要 设置 Canvas 画布坐标。同理，我们也可以通过给 svg 元素设置 viewBox 属性，来改变 SVG 的坐标系。如果设置了 viewBox 属性，那 SVG 内部的绘制就都是相对于 SVG 坐标系 的了。

就比如说，在绘制如上的层次关系图时，我们只需要绘制数十个节点。但是如果是更复杂的 应用，比如我们要绘制数百上千甚至上万个节点，这个时候，DOM 树渲染就会成为性能瓶 颈。事实上，在一般情况下，当 SVG 节点超过一千个的时候，你就能很明显感觉到性能问 题了。
幸运的是，对于 SVG 的性能问题，我们也是有解决方案的。比如说，我们可以使用虚拟 DOM 方案来尽可能地减少重绘，这样就可以优化 SVG 的渲染。但是这些方案只能解决一 部分问题，当节点数太多时，这些方案也无能为力。这个时候，我们还是得依靠 Canvas 和 WebGL 来绘图，才能彻底解决问题。

因为 SVG 可以作为一种图像格式使用，所以我们可以将生成的 SVG 作为图像，然后绘 制到 Canvas 上。那如果我们先用 SVG 生成层级关系图，再用 Canvas 来完成绘制的 话，和我们单独使用它们来绘图有什么不同?为什么?

使用 CSS 设置样式的好处:可以将样式和节点解耦，有利于样式的模块化和复用，比如 多种主题色，一键换色等。
2. 先用 SVG 生成层级关系图，再用 Canvas 来完成绘制，此时 SVG 将作为一张静态图片 被绘制在 Canvas 中。和单独使用 Canvas 绘图相比，这种混合方式代码量更少，代码更 加可读，易维护。
将 SVG 渲染到 Canvas 上：

如果先用 SVG 生成层级关系图，再将其内容“绘制”到 Canvas 上，这样做通常是为了利用 SVG 的矢量化优势和良好组织性来设计和构建图形，然后利用 Canvas 的性能和特定功能（如混合模式、像素操作等）来进一步处理或展示这个图形。
不同之处在于，SVG 图形在 Canvas 上会失去一些原有的交互性和可编辑性，因为 Canvas 只保存最终的像素结果，而不是原始的矢量信息。
这种做法可能在需要同时利用 SVG 矢量特性和 Canvas 动态渲染能力的场景下有其价值，例如结合了矢量和位图特效的混合应用。

最近也遇到过用svg绘制元素太多导致渲染卡顿问题，后来改用使用一条 path 绘制所有元 素，但是 path 一长也同样存在渲染卡顿问题，不知道老师有没有遇到过类似的问题

因为，不管是 HTML/CSS、SVG 还是 Canvas，都主要是使用其 API 来绘制图形的

但是，要使用 WebGL 绘图，我们必须要深入细节里。换句话 说就是，我们必须要和内存、GPU 打交道，真正控制图形输出的每一个细节。

![20240312002004](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240312002004.png)
首先，数据经过 CPU 处理，成为具有特定结构的几何信息。然后，这些信息会被送到 GPU 中进行处理。在 GPU 中要经过两个步骤生成光栅信息。这些光栅信息会输出到帧缓 存中，最后渲染到屏幕上。
这个绘图过程是现代计算机中任意一种图形系统处理图形的通用过程。它主要做了两件事， 一是对给定的数据结合绘图的场景要素(例如相机、光源、遮挡物体等等)进行计算，最终 将图形变为屏幕空间的 2D 坐标。二是为屏幕空间的每个像素点进行着色，把最终完成的图
 防止断更 请务必加 首发微信:1716143665
形输出到显示设备上。这整个过程是一步一步进行的，前一步的输出就是后一步的输入，所 以我们也把这个过程叫做渲染管线(RenderPipelines)

1. 创建 WebGL 上下文
2. 创建 WebGL 程序(WebGL Program) 3. 将数据存入缓冲区
4. 将缓冲区数据读取到 GPU
5. GPU 执行 WebGL 程序，输出结果
6.  const gl = canvas.getContext('webgl');
7.  
那我们为什么要创建两个着色器呢?这就需要我们先来理解顶点和图元这两个基本概念了。 在绘图的时候，WebGL 是以顶点和图元来描述图形几何信息的。顶点就是几何图形的顶 点，比如，三角形有三个顶点，四边形有四个顶点。图元是 WebGL 可直接处理的图形单 元，由 WebGL 的绘图模式决定，有点、线、三角形等等。
所以，顶点和图元是绘图过程中必不可少的。因此，WebGL 绘制一个图形的过程，一般需 要用到两段着色器，一段叫顶点着色器(Vertex Shader)负责处理图形的顶点信息，另一 段叫片元着色器(Fragment Shader)负责处理图形的像素信息。

好了，那让我们回到片元着色器对像素点着色的过程。你还要注意，这个过程是并行的。也 就是说，无论有多少个像素点，片元着色器都可以同时处理。这也是片元着色器一大特点。

更具体点来说，我们可以把顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点 的信息(如顶点的坐标、法线方向、材质等等)，从而改变我们绘制出来的图形的形状或者 大小等等。
顶点处理完成之后，WebGL 就会根据顶点和绘图模式指定的图元，计算出需要着色的像素 点，然后对它们执行片元着色器程序。简单来说，就是对指定图元中的像素点着色。
WebGL 从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是我们前面说的 生成光栅信息的过程，我们也叫它光栅化过程。所以，片元着色器的作用，就是处理光栅化 后的像素信息。
这么说可能比较抽象，我 来举个例子。我们可以将图元设为线段，那么片元着色器就会处 理顶点之间的线段上的像素点信息，这样画出来的图形就是空心的。而如果我们把图元设为

18
三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心
的。


我们要记住，不论这个三角形是大还是小，有几十个像素点还是上百万个像素点，GPU 都 是同时处理每个像素点的。也就是说，图形中有多少个像素点，着色器程序在 GPU 中就会 被同时执行多少次

![20240312003232](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240312003232.png)

HTML 采用的是窗口坐标系，以参考对象(参考对象通常是最接近图形元素的 position 非 static 的元素)的元素盒子左上角为坐标原点，x 轴向右，y 轴向下，坐标值对应像素值。
SVG 采用的是视区盒子(viewBox)坐标系。这个坐标系在默认情况下，是以 svg 根元素 左上角为坐标原点，x 轴向右，y 轴向下，svg 根元素右下角坐标为它的像素宽高值。如果 我们设置了 viewBox 属性，那么 svg 根元素左上角为 viewBox 的前两个值，右下角为 viewBox 的后两个值。

为了方便处理图形，我们经常需要对坐标系进行转换。转换坐标系可以说是一个非常基础 且重要的操作了。正因为这四个坐标系都是直角坐标系，所以它们可以很方便地相互转 化。其中，HTML、SVG 和 Canvas 都提供了 transform 的 API 能够帮助我们很方便地转 换坐标系。而 WebGL 本身不提供 tranform 的 API，但我们可以在 shader 里做矩阵运算 来实现坐标转换，WebGL 的问题我们在后续课程会有专门讨论，今天我们先来说说其他三 种。那接下来我们就以 Canvas 为例，来看看用 transform API 怎样进行坐标转换。

Rough.js 手绘

算量会非常大，很麻烦。那采用坐标变换的方式就是一个很好的优化思路，它能够简化计 算量，这不仅让代码更容易理解，也可以节省 CPU 运算的时间。
理解直角坐标系的坐标变换之后，我们再来说说直角坐标系里绘制图形的方法。那不管我 们用什么绘图系统绘制图形，一般的几何图形都是由点、线段和面构成。其中，点和线段 是基础的图元信息，因此，如何描述它们是绘图的关键。

所以我今天想和你聊的是，可视化方面特殊的性能问题。它们在我们熟悉的 Web 前端工作 中并不常见，通常只在可视化中绘制复杂图形的时候，我们才需要重点考虑。这些问题大 体上可以分为两类，一类是渲染效率问题，另一类是计算问题。
我们先来看它们的定义，渲染效率问题指的是图形系统在绘图部分所花费的时间，而计算 问题则是指绘图之外的其他处理所花费的时间，包括图形数据的计算、正常的程序逻辑处 理等等。
我们知道，在浏览器上渲染动画，每一秒钟最高达到 60 帧左右。也就是说，我们可以在 1 秒钟内完成 60 次图像的绘制，那么完成一次图像绘制的时间就是 1000/60(1 秒 =1000 毫秒)，约等于 16 毫秒。
换句话说，如果我们能在 16 毫秒内完成图像的计算与渲染过程，那视觉呈现就可以达到完 美的 60fps(即 60 帧每秒，fps 全称是 frame per second，是帧率单位)。但是，在复 杂的图形渲染时，我们的帧率很可能达不到 60fps。
所以，我们只能退而求其次，最低可以选择 24fps，就相当于图形系统要在大约 42 毫秒内 完成一帧图像的绘制。这是在我们的感知里，达到比较流畅的动画效果的最低帧率了。要 保证这个帧率，我们就必须保证计算加上渲染的时间不能超过 42 毫秒。

我们知道，Canvas 是指令式绘图系统，它通过绘图指令来完成图形的绘制。那么我们很容 易就会想到 2 个影响因素，首先绘制图形的数量越多，我们需要的绘图指令就越多，花费 的渲染时间也会越多。其次，画布上绘制的图形越大，绘图指令执行的时间也会增多，那 么花费的渲染时间也会越多。

影响 Canvas 的渲染性能的主要因素有两点，一是绘制图形 的数量，二是绘制图形的大小。这正好验证了我们开头的结论。


总的来说，Canvas2D 绘制图形的性能还是比较高的。在普通的个人电脑上，我们要绘制 的图形不太大时，只要不超过 500 个都可以达到 60fps，1000 个左右其实也能达到 50fps，就算要绘制大约 3000 个图形，也能够保持在可以接受的 24fps 以上。

最终，我们能得到的结论与 Canvas 类似，影响 SVG 的性能因素也是相同的两点，一是绘 制图形的数量，二是绘制图形的大小。但与 Canvas 不同的是，图形数量增多的时候， SVG 的帧率下降会更明显，因此，一般来说，在图形数量小于 1000 时，我们可以考虑使 用 SVG，当图形数量大于 1000 但不超过 3000 时，我们考虑使用 Canvas2D。

![20240312201504](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240312201504.png)

比如说，产品经理经常会提出一些需求，可能是要我们实现某种复杂的可视化大屏，或者 指定一些竞品中的图表形式让我们模仿，有时候甚至会在数据给到我们之前先完成 UI 设 计。可是，等到我们最终拿到数据之后，却发现数据的信息不足以支撑这些图表的展现形 式，或者数据的内容在这些图表上表现得不好。
其实这不是产品经理能力不足、也不是可视化工程师能力不足，而是我们一开始就搞错了
步骤，我们应该先分析真实数据，找到数据的特点，比如我们可以按照时间、地点、性别
对数据进行分类。然后，我们再研究具体的数据呈现形式。因此，做可视化项目的第一
步，就是要先了解自己掌握的数据，而不同的数据要了解的内容不同，我们要根据实际情
况来具体分析。

可视化数据之后，我们需要从中挖掘出一些有价值的信息，包括但不限于数据信息的规律
(增加、减少、离群值等)，以及数据信息的异常(明显差异、规律改变)等等，然后将
这些规律和异常归因，帮助我们真正了解数据背后有价值的内容。这些正是可视化的意义
所在。

最后，我还想再强调一下，从本质上来说，可视化过程是对数据进行分析、提取有效信
息、设计展现形式的不断迭代过程，今天我们讲的例子虽然简单，但更加复杂的例子，也
无外乎是同样的处理过程，只不过那个时候，我们可能需要处理更多的数据，经过更多轮
迭代。

在实际的可视化项目中，我们经常会遇到一种情况:用户期望所有的可视化图表都是简单
明了的。实际上，这是不现实的。
因为我们拿到原始数据之后，第一步是分析数据，也就是从各种不同的角度尝试去观察数
据，确定我们希望用户了解的信息。这些信息如果是简单清晰的，那么可视化结果就是简
单直观的。如果用户想要了解的数据规律本身就很复杂，那么可视化图表所能做的事情，

也只能是尽可能清晰地展现用户关注的重要信息，屏蔽干扰信息，来降低用户理解数据的
难度。

在实际的可视化项目中，我们经常会遇到一种情况:用户期望所有的可视化图表都是简单
明了的。实际上，这是不现实的。
因为我们拿到原始数据之后，第一步是分析数据，也就是从各种不同的角度尝试去观察数
据，确定我们希望用户了解的信息。这些信息如果是简单清晰的，那么可视化结果就是简
单直观的。如果用户想要了解的数据规律本身就很复杂，那么可视化图表所能做的事情，

 也只能是尽可能清晰地展现用户关注的重要信息，屏蔽干扰信息，来降低用户理解数据的
难度。
https://time.geekbang.org/column/article/288323?utm_source=time_web&utm_medium=menu&utm_term=timewebmenu 1/16
2020/10/12 35| 设计(一):如何让可视化设计更加清晰?
因此，我们要明白，在任何时候，制作可视化图表都是为了帮助人们理解抽象的数据，不
管这些数据多复杂，都要尽可能让读者快速理解。如何才能做到这一点呢?简单来说，就
是你要学会了解人们是怎样看数据的，然后将数据呈现得符合人们的思维和理解习惯。
接下来，我们就通过几个例子来学习一下，都有哪些方法可以轻松地把人们的注意力集中
在数据信息上。
分清信息主次，建立视觉层次
我们可以先想这么一个问题:第一次看图表的时候，你都会注意哪些信息?如果是我的
话，我总会试图在图表上找到什么有趣的东西。实际上，在看任何东西的时候，我们的眼
睛总是倾向于识别那些引人注目的东西，比如，明亮的颜色，较大的物体，有特点的符号
等等。因此，我们做可视化的时候，应当用醒目的颜色突出显示数据，把被淡化的其他视
觉元素当作背景。其实，这就是我们今天要讲的第一个方法，建立视觉层次。

具体的方法讲完了，我们做个总结。使用南丁格尔玫瑰图，我们能把人群在公园区域的分
布和性别分布规律显示在一张图上，让更多的信息呈现在一张图表上。这既能节省空间，
也便于人们高效率地获取更多信息。但是，太多的信息聚集也会显著增加图表复杂度，减
少图表的直观程度。就像这张南丁格尔图一样，它虽然简单，但直观性仍然不如之前用四
个饼图和一个嵌套饼图的表达形式。所以在我们实际可视化项目中，需要根据实际情况选
择合适的解决方案，大部分情况下，我们需要在直观性和信息聚集程度上做一个取舍。

简单清晰原则是可视化设计中最重要的一条基本原则。

![20240312203936](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240312203936.png)

这是因为纯函数与非纯函数相比，有三个非常大的优点，分别是易于测试 (上下文无关)、可并行计算(时序无关)、有良好的 Bug 自限性。下面，我一一来解释 一下。
最后，纯函数有良好的 Bug 自限性。这是什么意思呢?因为纯函数不会依赖和改变外部环 境，所以它产生的 Bug 不会扩散到系统的其他部分。

如上面代码所示，parametric 是一个高阶函数，它比上面的函数装饰器更加复杂一点的 是，它的输入是两个函数 xFunc 和 yFunc，输出也是一个函数，返回的这个函数实际上是 一个过程，这个过程是对 x、y 的参数方程根据变量 t 的值进行采样。
所以，实际上 parametric 函数封装的是一个过程，这种封装过程的思路，叫做过程抽象。 前面的函数装饰器，还有 batch 方法，实际上也是过程抽象。对应的一般程序设计中我们 不是封装过程，而是封装数据，所以叫做数据抽象。
过程抽象是函数式编程的基础，函数式编程对待函数就像对待数据一样，都会进行封装和
抽象，这样能够设计出非常通用的功能模块。

如果输入参数和返回值都是函数，这样的高阶函数又叫做函数装饰器(Function Decorators)。当一个高阶函数是用来修饰函数本身的，它就是函数装饰器。也就是说， 它是在原始函数上增加了某些带有辅助功能的函数。
这么说你可能不太理解，我们再来看一个例子。
假设，我们的代码库要进行大版本升级，在未来最新的版本中我们想要废弃掉某些 API， 由于很多业务中使用了老版本的库，不可能一次升级完，因此我们需要做一个平缓过渡。 具体来说就是在当前这个版本中，先不取消这些旧的 API，而是给它们增加一个提示信 息，告诉调用它们的用户，这些 API 将会在下一次升级中被废弃。
如果我们手工修改要废弃的 API 代码，这会是一件非常繁琐的事情。而且，我们很容易遗 漏或者弄错些什么，从而产生不可预料的 Bug。
2 el.style.color = color;
3}
4
5 let setColors = batch(setColor);
2020/10/12 加餐四 | 一篇文章，带你快速理解函数式编程
https://time.geekbang.org/column/article/287296?utm_source=time_web&utm_medium=menu&utm_term=timewebmenu 8/11
所以，一个比较聪明的办法是，我们实现一个通用的函数装饰器。
1
2
3
4
5
6
7 8} 9}
function deprecate(fn, oldApi, newApi) {
  const message = `The ${oldApi} is deprecated.
Please use the ${newApi} instead.`;
return function(...args) {
  console.warn(message);
  return fn.apply(this, args);
 复制代码
然后，在模块导出 API 的时候，对需要废弃的方法统一应用这个装饰器。
1 // deprecation.js
2 // 引入要废弃的 API
3 import {foo, bar} from './foo';
4 ...
5 // 用高阶函数修饰
6 const _foo = deprecate(foo, 'foo', 'newFoo');
7 const _bar = deprecate(bar, 'bar', 'newBar');
8 9
10 // 重新导出修饰过的API
11 export {
12 foo: _foo,
13 bar: _bar,
14 ...
15 }
 复制代码
这样，我们就利用函数装饰器，无侵入地修改了模块的 API，将要废弃的模块用 deprecate 包装之后再输出，就实现了我们想要的效果。这里，我们实现的 deprecate 就 是一个纯函数，它的维护和使用都非常简单。

