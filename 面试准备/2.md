让我们按照上述三步演进顺序思考。首先，React的开发理念践行了如下公式（即：UI是数据快照经过函数映射而来）：UI = fn(snapshot)
要落地这个理念，有两个要素需要实现：数据快照 函数映射 在这里，FP中「不可变数据」更适合作为「数据快照」的载体，所以React中状态是不可变的，因为状态的本质是快照。而「函数映射」的载体则没有特殊要求。在React中，每次触发更新，所有组件都会重新render，render的过程就是「函数映射」的过程，输入是props与state，输出是JSX。

组件的setup方法只会在初始化时执行一次，后续触发更新时操作的都是同一个闭包中的数据。这里面的闭包就是OOP思想中的实例。

既然React对「函数映射」的载体没有特殊要求，那么类组件、函数组件都是可以的。那为什么函数组件最终替代了类组件成为React开发的主流呢？很多同学认为「函数组件的Hooks可以更好的复用逻辑」这一点，是函数组件优于类组件的主要原因。但实际上，基于装饰器的类开发模式早已被验证是优秀的逻辑复用模式，类组件配合TS装饰器的模式是行得通的。主要原因还是 —— 函数组件能够更好的落地UI = fn(snapshot)这一理念

主要原因还是 —— 函数组件能够更好的落地UI = fn(snapshot)这一理念。
但状态更新也可能触发「副作用」，比如请求数据、操作DOM...
在类组件中，这些「副作用」逻辑被分散在各个生命周期钩子函数中，React无法掌控。
副作用受限在useEffect中。每次render，React都会保证上次的副作用效果已经被清除（通过useEffect回调的返回值函数） ref的传播也需要借由forwardRef，这进一步限制了ref可能的影响范围 数据请求的副作用被交给Suspense处理，

总而言之，使用函数组件时，所有副作用都处于一种「受到管控」的状态，可以尽可能保证每次更新时「相同的快照输入，获得相同的JSX输出」，所以函数组件在React中才会发扬光大。

同时，这也契合了FP中的纯函数思想。

函数本身没状态。
函数改变的底层事物有状态，或者说函数的产物，函数的依赖物有状态。
那么对于有状态的函数式组件来说，为什么还能称之为“纯函数”呢？这是因为组件的状态只影响组件本身，不会对外部环境产生任何改变。每次状态发生变化时，React会重新计算并更新组件的DOM结构，但这些变化仍然只局限于组件内部。因此，虽然组件具有状态，但在React的渲染和更新过程中，它们仍然符合纯函数的基本特征。

vue 的 computed(() => service.property) 本身也可以当做一个通知模式的订阅器，而把一个组件去掉订阅器、增加 props ，一个组件也可以变得纯纯的，即使它有很多 props ：只要它是来自外部的（而不是自己的 state ），按照纯函数的说法：它把输入值们照章显示出来，近乎于将一个输入值简单映射到模板，或者说将一个输入值转发到模板，这就是纯纯的。 —— 可见， “纯” 是一个完全生造出来的概念。越纯越好，纯函数组件越多越好，是指什么呢？

实现上是用 js 的闭包上下文在隐式传参，把代码全部展开打平的话确实是个纯函数。但由于抽象，看起来就不那么纯了。

第一次执行时相当于传进来一个 [undefined, setX]，所以 x 是 0，以后就是传进来比如 [1, setX] 了。 而 setX 产生的状态变更呢，则是更外层的一个纯函数 (states: State[]) => State[]  （render 过程的一部分）的结果。最后补充一下为什么要把 state 置外由 React 管理 —— 因为这样的话在并发渲染时 React 可以决定是丢弃还是 commit，这个和软件事务内存（Software Transactional Memory）的原理是一样得。

只要调用组件多次是安全的，并且不会影响其他组件的渲染，React 并不关心你的代码是否像严格的函数式编程一样百分百纯净。在 React 中，幂等性比纯净性更加重要。也就是说，在 React 组件中不允许有用户可以直接看到的副作用。换句话说，仅调用函数式组件时不应该在屏幕上产生任何变化。

其次函数组件并不会调用setXXX啊，调用setXXX的明明是用户行为触发的回调函数，它已经脱离了函数组件本身的作用域了。

function pure() { return () => console.log(XXX) }

你不能说因为pure返回的回调函数有副作用，所以pure本身有副作用吧

虽然但是，函数组件并没有直接依赖react这个可变的context啊（比如从context里去直接取值），而是通过hook来进行某种形式上的依赖注入，目前的hook应该可以完全等价于传递参数吧。

所以从形式上看组件是依赖了一个全局变量，但是从最终的效果看我觉得仍然可以认为函数组件是纯的[思考]
