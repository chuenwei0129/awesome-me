# 探索 JavaScript 中的数字世界

## 浮点数

### [什么是浮点数](https://www.zhihu.com/question/19848808/answer/120393769)

**小数点在数制中代表一种对齐方式**，比如说你要比较 `1000` 和 `200` 哪个比较大你应该怎么做呢？你必须把他们**右对齐**：

```js
1000
0200
```

然后发现 `1` 比 `0`（前面补零）大，所以 `1000` 比较大。那么如果是比较 `1000` 和 `200.01` 呢？这时候就不是右对齐了，而是对应位对齐，也就是**小数点对齐**：

```js
1000.00
0200.01
```

**小数点位置在进制表示中是至关重要的，位置差一位整体就要差进制倍**（十进制就是十倍）。在计算机中也是这样，虽然计算机使用二进制，但在处理非整数时，也需要考虑小数点位置的问题，**无法对齐小数点就无法做加法、减法比较这样的操作**。

在计算机中处理小数点位置有**浮点**和**定点**两种，**定点就是小数点永远在固定的位置上**，比如说我们约定一种 32 位无符号定点数，它的小数点永远在第 `5` 位后面，这样最大能表示的数就是 `11111.111111111111111111111111111`，最小非零数是 `(2^-27)`。**定点数是提前对齐好的小数，整数是一种特殊情况，小数点永远在最后一位之后。**

**定点数的优点是很简单**，大部分运算实现起来和整数一样或者略有变化，**但是缺点则是表示范围**，比如我们刚才的例子中，最大只能表示 `32`；而且在表示很小的数的时候，大部分位都是 `0`，精度很差，不能充分运用存储单元。浮点数就是设计来克服这个缺点的，它相当于一个定点数加上一个阶码，**阶码表示将这个定点数的小数点移动若干位**。**由于可以用阶码移动小数点，因此称为浮点数。**

### 浮点数是怎么存储的？

> [从科学记数法到浮点数标准 IEEE 754](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)

### 举例说明：十进制 32 位浮点数 20.25 的存储

想要存储一个 32 位浮点数，比如 20.25，在内存或硬盘中要占用 32 个二进制位。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/js/v2-32e425cdb908c47586267e59228fcd22_1440w.png)

这 32 个二进制位的内存编号从高到低 (从 31 到 0), 共包含如下 3 个部分：

- **sign**：符号位，即图中蓝色的方块。
- **biased exponent**：偏移后的指数位，即图中绿色的方块。
- **fraction**：尾数位，即图中红色的方块。

**步骤：**

1. 将十进制数值转换为二进制数值。

    ![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220408-acz.png)

    ```js
    // 遇到小数转换时，需要把整数和小数两部分分别进行处理

    // 整数 20 除以 2 直到商是 0 为止，取每次除 2 得到的余数结果

    20 / 2 = 10     ...... 0
    10 / 2 = 5      ...... 0
    5  / 2 = 2      ...... 1
    2  / 2 = 1      ...... 0
    1  / 2 = 0      ...... 1
    // 结果为得到的余数按照从下往上排列 10100

    // 小数 0.25 乘以 2 直到不存在小数位为止，并计下每次乘后的整数位结果
    0.25 * 2 = 0.5  ...... 0
    0.5 * 2 = 1     ...... 1
    // 结果为得到的整数位按照从上往下排列 01

    // 将计算后的 0 1 序列拼在一起就得到转换的二进制 10100.01
    ```

2. 将二进制数值转换为科学记数法。其中，二进制表示采用原码表示。`10100.01` 用科学计数法表示为 $1.010001 \times 2^4$

3. 确定符号位：如果是正数，符号位为 `0`；如果是负数，符号位为 `1`。20.25 是正数，所以符号位为 `0`。

4. 计算阶码：将科学记数法的指数值加上偏移值（单精度为 `127`，双精度为 `1023`），再转换为 `8` 位二进制。指数值为 `4`，加上偏移值后为 `131`，转换为二进制为 `1000 0011`。

5. 计算尾数：由于尾数只存储有效数字的**小数部分**，所以尾数为 `010001`。最高位 `1` 规定不显式存储，以隐含方式存在，计算或恢复数值时再把这个 `1` 补上。如果尾数不足 23 位则右边用 `0` 填充至 23 位。

**总结：**

最终得到的 32 位浮点数表示为（分段显示方便阅读）

- 符号位是: `0`
- 偏移后指数位（阶码）是: `1000 0011`
- 补零后尾数位是: `0100 0100 0000 0000 0000 000`

现在，把这三部分按顺序放在 32 位浮点数容器中，就是 `0-1000 0011-0100 0100 0000 0000 0000 000`

这里有一个可以[在线浮点数转二进制](https://tooltt.com/floatconverter/)的网站，我们来验证一下：

![20240307200242](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/me/20240307200242.png)

**逆向分析：**

现在，将浮点数 `0-1000 0011-0100 0100 0000 0000 0000 000` 恢复为十进制数

1. 符号位为 `0`，说明该数为正数。
2. 阶码为 `1000 0011`，因此实际指数值为 `131 - 127 = 4`。
3. 尾数 = 小数部分 `0100 0100 0000 0000 0000 000` + 隐含值 `1` = `1.0100 01`
4. 因此该浮点数所表示的实际数值为 $1.0100 01 \times 2^4$。
5. 小数点向右移动 4 位，得到二进制数 `10100.01` 转换为十进制就是 `20.25`。

### 浮点数精度

## 位运算


<!-- JavaScript 的 Number 其实是有分类型的，虽然我们说 JavaScript 表面只有双精度浮点数，但 JavaScript 引擎会自主优化。

举个粒子，42.0 妥妥地是一个小数。 但是我觉得，不代表机器也觉得。机器比我们笨多了。

```js
Number.isInteger(42.0) // true
42 === 42.0 // true
Object.is(42, 42.0) // true
```

如你所见，JS 认为 42.0 是一个整数。

IEEE 754, 最小的空间表示最多的数字范围

运算流程主要有以下几步：

•X 进制转二进制•二进制转科学计数法•转换为 JS 支持的存储方式（转换成 64 位二进制值）•进行运算•将结果转换为 X 进制

这里的安全，指的是双精度数和十进制数能够一一对应。超过这个范围，会有两个或更多整数的双精度表示是相同的；反过来说，超过这个范围，有的整数是无法精确表示的，只能 round 到与它相近的浮点数（说到底就是科学计数法）表示，这种情况下叫做不安全整数

所以这也说明了为什么安全范围不包括边界
•JS 中的位运算仅支持 32 位。按位运算符将其操作数视为一组 32 位的二进制数，而不是十进制、十六进制或八进制数•例如，十进制数 9 的二进制表示为 1001•整数字面量都默认存储为有符号整数，位运算也会强制转换结果为 32 位有符号整数•与其他按位运算符不同，无符号右移（ >>> ） 返回一个无符号的 32 位整数
### 什么是浮点数 -->

<!-- > [为什么叫浮点数?](https://www.zhihu.com/question/19848808/answer/120393769)

**小数点在数制中代表一种对齐方式**，比如说你要比较 `1000` 和 `200` 哪个比较大你应该怎么做呢？你必须把他们**右对齐**：

```sh
1000
0200
```

然后发现 `1` 比 `0`（前面补零）大，所以 `1000` 比较大。那么如果是比较 `1000` 和 `200.01` 呢？这时候就不是右对齐了，而是对应位对齐，也就是**小数点对齐**：

```sh
1000.00
0200.01
```

**小数点位置在进制表示中是至关重要的，位置差一位整体就要差进制倍**（十进制就是十倍）。在计算机中也是这样，虽然计算机使用二进制，但在处理非整数时，也需要考虑小数点位置的问题，**无法对齐小数点就无法做加法、减法比较这样的操作**。

在计算机中处理小数点位置有**浮点**和**定点**两种，**定点就是小数点永远在固定的位置上**，比如说我们约定一种 `32` 位无符号定点数，它的小数点永远在第 `5` 位后面，这样最大能表示的数就是 `11111.111111111111111111111111111`，最小非零数是 `(2^-27)`。**定点数是提前对齐好的小数，整数是一种特殊情况，小数点永远在最后一位之后。**

**定点数的优点是很简单**，大部分运算实现起来和整数一样或者略有变化，**但是缺点则是表示范围**，比如我们刚才的例子中，最大只能表示 32；而且在表示很小的数的时候，大部分位都是 `0`，精度很差，不能充分运用存储单元。浮点数就是设计来克服这个缺点的，它相当于一个定点数加上一个阶码，**阶码表示将这个定点数的小数点移动若干位**。**由于可以用阶码移动小数点，因此称为浮点数。**


按位操作符将其操作数当作 32 位的比特序列（由 0 和 1 组成）操作，返回值依然是标准的 JavaScript 数值。JavaScript 中的按位操作符有：

| 运算符             | 用法      | 描述                                                                                                      |
| ------------------ | --------- | --------------------------------------------------------------------------------------------------------- |
| 按位与（AND）      | `a & b`   | 对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。                             |
| 按位或（OR）       | `a \| b`  | 对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。                           |
| 按位异或（XOR）    | `a ^ b`   | 对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。                         |
| 按位非（NOT）      | `~a`      | 反转操作数的比特位，即 0 变成 1，1 变成 0。                                                               |
| 左移（Left shift） | `a << b`  | 将 a 的二进制形式向左移 b (< 32) 比特位，右边用 0 填充。                                                  |
| 有符号右移         | `a >> b`  | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。若值为正，则在左侧填充 0；若值为负，则在左侧填充 1。 |
| 无符号右移         | `a >>> b` | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，无论正负，都使用 0 在左侧填充。                      |

1. 所有的按位操作符的操作数都会被**转成补码**形式的有符号 `32` 位整数。
2. 运算符的优先级：~ 的优先级最高，其次是 <<、>> 和 >>>，再次是＆，然后是 ^，优先级最低的是 |。 -->

## 参考文章


- 



