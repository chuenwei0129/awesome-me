大概是因为青春时对美好的悸动与希望吧，年与时驰，意与日去，只能从回忆中捕捉一些心脏鲜活跳动过的痕迹。曾经紧实的肌肤，笑成月芽样的天真，最幼稚却又最无所畏惧的付出，那是生命中最融融的春和最辉煌的夏一起肆意挥洒，还以为天地间一个我，是多么畅快和恣意。终于淹没在尘世烟火之中，才知道天地间一个我，是多么渺小和卑微。

要说我的 UI 库有没有用，我觉得是鬼用都木有哇，仅仅是想看看实现出来是怎么样的。诶，就是玩儿~

不冗余。写代码写多了就能体会，一个不可变的东西往往比一个可变的类似物要更有用。

四种常见的基本复合数据结构：最基本的就是tuple，数字下标，不可变tuple加上literal下标，就是record，也就是python里的namedtupletuple加上可变性，就是array，或者python里的listrecord加上可变性，或者list加上literal下标，就是dict基本原则是，要使用满足要求的前提下功能最少的东西，也就是当你不需要可变性的时候下，就用tuple record，避免用list dict，否则可变性将成为你维护的负担，bug的来源。你看比如js里面语言层面不支持不可变的array和object，结果大家只能自己造各种immutable的轮子。。。

只有静态资源才需要http缓存。业务数据如果要缓存，也不该依赖http。
有人问，那get缓存怎么办？缓存这种东西还是不要交给浏览器和http协议的好吧，太不好控制了。真正需要缓存的时候，我会在前端里搞类似apollo client或react query那样的缓存，或者在后端应用层或redis层搞，可以精确地控制何时把哪些过期的缓存干掉。人生苦短，单单为了一个http协议就维护一套管理query string和cache header的转换层，感觉不值得。都搞成跨协议通用的缓存管理代码，挺好。

作者：beeplin
链接：https://www.zhihu.com/question/336797348/answer/2199428816
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

有人问，那get缓存怎么办？缓存这种东西还是不要交给浏览器和http协议的好吧，太不好控制了。真正需要缓存的时候，我会在前端里搞类似apollo client或react query那样的缓存，或者在后端应用层或redis层搞，可以精确地控制何时把哪些过期的缓存干掉。人生苦短，单单为了一个http协议就维护一套管理query string和cache header的转换层，感觉不值得。都搞成跨协议通用的缓存管理代码，挺好。

作者：beeplin
链接：https://www.zhihu.com/question/336797348/answer/2199428816
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

最后，react和vue都支持jsx，这个jsx就是个哲学问题了，看你是信仰三分离，还是信仰all in js


<!-- 🥤 原汁原味 TypeScript  
○ 直接基于 TypeScript type 和 interface 定义协议  
○ 无需额外注释，无需 Decorator，无需第三方 IDL 语言  
👓 自动类型检查  
○ 在编译时刻和运行时刻，自动进行输入输出的类型检查  
○ 总是类型安全，放心编写业务代码  
🔥 史上最强大的 TypeScript 二进制序列化  
○ 无需任何注解，直接实现将 TypeScript 源码中的类型定义序列化（设置支持 Union Type、Intersection Type 这样的复杂动态类型，ProtoBuf也无法做到）  
○ 比 JSON 更小的传输体积、更多的数据类型：如 Date, ArrayBuffer, Uint8Array 等  
○ 方便地实现二进制加密  
☎ 多协议  
○ 同时支持 HTTP / WebSocket  
💻 多平台  
○ NodeJS / 浏览器 / App / 小程序  
⚡️ 高性能  
○ 单核单进程 5000+ QPS 吞吐量（测试于 Macbook Air M1, 2020) -->

前端~api~后端~数据库

面向对象
感觉树形结构在复杂需求面前不堪一击
应该说是声明式不够用

第一层, 跨组件 A B 用到同个状态, 要尝试组件 A 存的状态跟随组件 B 存的状态更新, 可能是通过事件进行,
第二层, 提升一个状态到父组件当中反过来分发到多个子组件, 来保持状态一致,
第三层, 太多位置, 或者想个太远的位置用到同个状态, 单纯传递事件或者蹭蹭 props 费代码, 转而依赖全局的 message bus (或者其变种)来完成.
(此外再有个极端方案是类似游戏当中, 所有状态保存全局, 然后 60fps 直接整体刷新.)

以我有限的经验来看，编程语言的各种特性中，唯一可以说是明确有害的是「继承」这个早期科学家拍脑袋想出来的方案。(拍脑袋想出来继承，本质上也是受当时硬件能力和编译技术所限，如今内存白菜价，人类对编译技术有深入理解之后，新兴语言基本上都摒弃了继承)

最强多态是「鸭子类型」但鸭子类型无法在编译时检查以优化性能，所以新兴语言普遍采用了protocol/trait等技术来实现接近鸭子类型的灵活度，并保留了编译型语言的性能。

之所以说继承是编译技术落后的产物，是因为早期软件复杂度不是那么高，所以科学家们出于直觉地进行了“在数据上添加操作(函数地址)，并复用这个操作”的设计，而后来随着软件规模的增长，才意识到继承带来的强耦合，转而使用组合，编程思想也转变为“为某一个struct实现某一个interface”而不是“用class来表示一个有某些操作的数据”。

新兴语言的基本组成都是 immutable struct + protocol/trait 了，相当于 没有继承的不可变的class + 独立在数据之外的interface的implements

duck type并不先进，这种类型系统往往会破坏封装破坏整体架构逻辑，而且不够sound，很多问题编译期发现不了，特别对于不能轻易表达对duck type语法约束的语言如c++，代码报错都不看懂。反之面向接口仍是目前组织大型软件的不二法门。

懂了，组合

<!-- 以前的 react -->
继承复用，一层套一层，那么如何保证数据方法绑定呢，面向类 class 就是约束
组合，闭包，在组合函数外面包上一层，闭包保存数据


复用，逻辑没有绑定 state，

我有一个问题，没想清楚。我有一个小狗的Class组件，如果要修改eat这个方法，我继承覆写一下就行了。
现在换成了hook，我把所有的逻辑和数据封装到hook里了。
那么我要做一个新组件，就要把所有hook，整起来，拼成一个新的函数组件。这样的操作简单么？封装，继承体现在哪里了？
05-16
·
IP 属地北京
​回复
​赞
Ryou ikonn
Ryou ikonn
hooks实现相当于狗 你要重新把狗的组成元素引进来 而不是只重写eat。hooks本身对于组织形式的复用就不如class的

业务层本来就不需要继承，就是获取数据，转换数据结构，数据流转，渲染数据，导出数据等等。归根到底就是对数据的处理，这一层还是函数简单一点

面向对象真的就是一个无比糟糕的编程概念。其实对象这个玩意唯一解决的问题是把数据和相关的逻辑统一了起来。

polyfill 标准 API 运行时补丁这种修改内置对象原型的库，在原有对象方法前后加新标准逻辑，就是装饰模式。推而广之，所有函数式编程当中的高阶函数，其实都是在原函数前后加特定逻辑的装饰模式应用。自然 React 常说的高阶组件也是装饰模式；在面向对象层面，装饰器语法就是这个模式的直接实现。

面向对象不是银弹，就像函数式编程也不是银弹一样。其实前端现在最常用的模式也就是装饰模式，代码量大了自然就学到那里了。

人类一直就是用分类思维的。（所以叫人类啊。）
但是，只有"上帝"才能驾驭好分类呀

面向对象抽象的是数据和操作，声明式抽象的是过程

自然界中的任何事物都可以被分类，但同时可以在不同的领域和场景下分成不同的类。面向类的编程不能很好地解决一个人物有多种能力和角色的问题。go的interface对面向对象的实现，更符合事物的多重分类的特征。而js的对象动态改变，更符合自然界中事物可变化的规律。

面向对象抽象是向上一层的，共同逻辑，操作某一数据的方法相同，写里面写外面

oop的特征是封装，继承，多态，是实现高度抽象和个性化这些目标的一种编程方法。FP是另一种编程方法，同样可以实现高度抽象和个性化这些目标。oop与FP有异曲同工之妙！
fp和oop都是编程的核心思想，fp是pipe的思想，只关系输入输出，确定的输入有着确定的输出。fp并不是编程风格这么简单

挖坑填坑，本来就是常态，不是问题，技术进步最大的问题是，不会反思。

gui 应用的本质确实不是静止的 f(x)，而是运动的 f(observable)。如果按照这样的方法来理解 gui，现在的 react 没有问题。如果按照 widget 组合的方式来理解 gui，可能推导出 oop 才是最适合。
实际上 gui 有两种常见的 api 风格，保留模式 和 立即模式。前者接近 oop，后者接近 fp。

存函数，波里状态

mark一个吧。UI是系统状态的展示器，也是用户行为的接收器。前者是离散的，而后者是连续的。不能用状态机范式一概而论

我不清楚vue和React，但我清楚c++里面的变迁。

在某些业务，继承是极不常用的。因为类和类之间很少能找到共性，反而需要一个类中携带其他类的信息。one loop per thread这种reactor模型中也是组合聚合用得比较多。

函数一等公民，也和面向对象不矛盾。在没有class的年代，js的函数一等公民加上词法作用域，带来的闭包特性，也是一种经典的面向对象的手段，所谓“闭包是穷人的对象”嘛。访问限定、封装、隔离，都可以用闭包搞定。而多态这种特性。。。JS这种鸭子类型的动态语言难道不是天然支持多态吗？多态搞起来比TS方便多了。

函数一等公民，也和面向对象不矛盾。在没有class的年代，js的函数一等公民加上词法作用域，带来的闭包特性，也是一种经典的面向对象的手段，所谓“闭包是穷人的对象”嘛。访问限定、封装、隔离，都可以用闭包搞定。而多态这种特性。。。JS这种鸭子类型的动态语言难道不是天然支持多态吗？多态搞起来比TS方便多了。

泻药，对于连自己去年拉的屎都认不出来，无法评判别人的shit

那。。不用组合用啥。。？总不能用继承这种大坑吧。。而且说白了依赖注入和AOP不就是组合吗。？还是说你发现了更好的办法。？愿闻其详

composition api和hooks容易乱，根本原因是把本应该放在model层的逻辑放在view层了。这是人的问题。
vue和react的绝大多数用户不知道严格区分mvvm的重要性，也没有设计领域模型的经验。
框架其实是用来帮我们解决数据绑定和局部/临时状态的。承担的是vm层和部分v层内部自己的mvc体系(这个v内部可以是一个mvc)。所以我觉得这不能说是这两个框架的设计缺陷，而是没能阻止用户的不良实践。
UI开发的主要工作量其实在model的设计，但是实际情况是太多人把东西一股脑都写到组件里了。

只要在使用层 逻辑上 是immutable 的就可以，忽略掉细节。

类是封装的，添加属性不影响对象操作(除非你要对新属性操作)，但更改操作就略复杂，多态，接口神马的……
函数式编程对数据的加工是链式的，你可以对一个参数用多个方法(函数，过程)处理，还可以任意增删，但是参数个数变化的时候……

编程说穿了就是两个方面，data和这些data上的operation,

oop, 就是让operation 围绕data， 这样的好处是，当你要添加新的data type的时候，好方便! 原来写的代码都不用改。 但是你要给已经写好的data type添加方法怎么办？ 比如我要你给java自带的string 加个 python那种乘法。

functional programming采取的是另一种思路，data更多的围绕operation， 所以添加新的方法很容易。

这就是著名的the expression problem. 谁优谁劣，要看应用场景，写GUI用oop好不畅快，写interpreter我更喜欢函数式的。

在我看来这些都是idiom， 不是宗教，具体问题具体分析。 但是学习functional programming绝对大有裨益，因为国内的计算机教育太强调图灵模型（也就是C语言一脉）了，而对lambda calculus涉及太少，造成了很多偏见和误解，我不只一次在知乎上看到，学好C语言，其他高级语言都很容易理解的论调，明显就是受了这种教育的荼毒。


纯，raect 比较存，不存就四相的扎脚，不好理解，状态管理，全局

老法师，存oop，什么都抽象，抽疯了

理解了这一点，绝大多数编程语言都可以实现面向对象编程。

递归，循环，输入输出，存函数，mutable object，副作用

波里，我的理解

hooks 心智模型

回答里既然都说了 hooks 在 mental model 上只是组件函数的参数的另一种写法，那 hooks 不能放 if 里面就是自然而然的了——一个函数有多少个参数、各个参数的顺序是什么，这应当是永远不会变的，不能允许它在每次调用时都可能不同。如果你真的想要一个“不是组件函数参数的另一种写法”的东西，那可以试试 SolidJS，它没有 hooks，只有 signal。只不过它的那种设计又带来了另一个问题：不能按条件 return。

每次都是新的纯函数，

nice，和我理解的一样。我一直认为hooks不过是参数的语法糖而已，所以函数组件就变成了一个接受参数（props + hooks）然后返回jsx的纯函数。
所以hooks不能用在分支或者循环里是理所当然的，函数怎么可能在运行时决定参数的个数和含义呢？
但是网上很多的文章都在从实现的角度分析原因，还有很多人去自己实现可以放进分支的hook，就很搞笑

换个思维，这叫依赖注入

我也觉得是，依赖注入下，大部分函数的参数都可以去掉


第一次执行时相当于传进来一个 [undefined, setX]，所以 x 是 0，以后就是传进来比如 [1, setX] 了。

而 setX 产生的状态变更呢，则是更外层的一个纯函数 (states: State[]) => State[] （render 过程的一部分）的结果。

最后补充一下为什么要把 state 置外由 React 管理 —— 因为这样的话在并发渲染时 React 可以决定是丢弃还是 commit，这个和软件事务内存（Software Transactional Memory）的原理是一样得。

也就是说，你每点击一次 +1，就会创建一个函数组件，新的函数组件会替换旧的函数组件。

ref 把 val 暴露出来了，所以可以改变
onclick 是 副作用，不存了，所以油状泰勒，

并不是 state 参数，hooks 参数

编程里面没有啥纯的，表面纯的只是底层帮你干了脏活儿

也就是说，你每点击一次 +1，就会创建一个函数组件，新的函数组件会替换旧的函数组件。

每个函数组件本身并没有状态。（注意我并没有说这些函数组件就是纯的，只是说它没有状态）

你说，我把 useState 变成 useRef 呢？

export const App = () => {
  const n = useRef(0)
  return <div>{n.current} <button onClick={()=> n.current+=1}>+1</button></div>
}
确实，这个组件有状态了，所以就不纯了，而且也不会自动更新 UI 了。

ref 不是状态，状态是 UI 相关，ref 是 hooks 参数的产物

实现上是用 js 的闭包上下文在隐式传参，把代码全部展开打平的话确实是个纯函数。但由于抽象，看起来就不那么纯了。

useeffect是做数据同步的，你想把内部的状态同步到外部时才用。内部一般就是state和props，外部一般是dom，网络请求啥的

从class到hooks的转变可以看出react越来越纯粹，那就是把自己彻底的定义为view层。把自己自己的模式彻底的定义为 view=F(data)。

你说状态和业务逻辑? view为什么要关心这些呢？因此它的正确使用方式是必须搭配一个独立的业务+数据层，hooks更多的作用不是状态维护，而是组件内逻辑的共享，是mixin。

数据层用面向对象最佳，因为它是目前为止最适合表达业务逻辑的架构，如果再加上ddd，那就是高质量的项目了。

write react in angular way.
这个世界好像真的病了，把渣当荣誉，把丧当潮流，把欲望当做理所当然，把深情当舔狗，病的明明是世界，但为什么要医治的，却是我们
每个人都不是坏人，但世界还是变得这么操蛋，恰好说明支撑这个世界运转的系统烂透了。
不不不，组合优于继承是因为，你继承的那个东西它也会被创建城对象在内存中，你访问父类的方法其实就是透过内存中被创建的父类对象的中方法，所以能用组合不要用继承。

气宗算法: 大脑手淫，剑宗工程: 便池掏粪

春秋笔法有2法：笔和削。这不是我说的，这是司马迁说的。《史记》的原话是：至于为《春秋》，笔则笔，削则削。

削简单，就是删除。把你的好削了，你就更坏；把你的坏削了，你就更好。

笔就麻烦些，要添油加醋带节奏。你的好，我细笔，本来10个字添油加醋后变100个，你就显得更好。你的坏，我也细笔，也是10个字变100个字，你就显得更坏。
二叉树的存储常见的方式是数组和链表.
还可以二法相结合，效果更佳。

假设A干了10件好事1件坏事，B干了1件好事10件坏事。显然A是好人B是坏人。

但是别忙，看看春秋笔法的魔术是怎么变的。

对于A，先削，削A的10件好事，只剩下1件坏事不削，这样A就变成了坏人。然后再笔，细笔A的那件坏事，这样A就不仅是坏人而且是大坏人。

对于B，还是先削，削B的10件坏事事，只剩下1件好事不削，这样B就变成了好人。然后再笔，细笔B的那件好事，这样B就不仅是好人而且是大好人。

春秋笔法的理想状态是：弄虚而不做假。

火箭制造指南

什么快速重传什么闭包，归根结底都是一个“模糊”的原则，我们写程序时逢山开路遇水搭桥就是了。

模仿比自己瞎琢磨高效的多

我吃了一辈子的喜之郎果冻了，心早就在外太空了，但是为了你，我愿意回到地球

唉，我才十几岁，爱情可以来的晚一点，但是外卖不行

今日限定 本人全糖去冰～
飞行中，尚未找到降落点。
75.再热下去我是红豆抹茶牛奶冰的身份就不保了

我想写一些可以表达心情的代码

持续保冷中……

欢迎光临我的开心

我在煮月亮 你想往里面加点什么

月亮和星星会不会互道心事。

如果夜里不能吃东西，那冰箱里为什么会有灯呢？

因为冰箱里住着可乐蛋糕大西瓜、啤酒水饺冰激凌，没有灯的话，它们晚上睡觉会害怕的

可是门一关灯就灭了呀

你关上门之后，冰箱里的小家伙再偷偷开灯

<!-- 因为灯会让食物以为还是白天，不敢过期 -->
夏天

冒泡的汽水

黄昏的落日

经常趴在窗台上睡懒觉的猫咪

可爱的你

世人可爱，世事可戏

今天的心情是开口向上的抛物线，很okଘ(੭ˊᵕˋ)੭*

睡觉啦，帮我关一下月亮

6.“你笑起来真像好天气。”

清水煮玉是明月
天地苍生一瓮中？
明月倒映水中，伴着水面上隐隐升起的雾气。就像一块美玉丢进热水里煮一般。

道理在情绪面前一文不值

心里有光，慢食三餐

你啊 得清醒 得知趣

久违亦如初见，亲切又新鲜

不知所措的年纪，什么都不尽人意
开始考虑值不值得的时候，就是不值的。
自己满身灰暗，还总想给别人一些光。

总是在某个瞬间突然就丧了

像是积攒了几天的热情

拍的一声

就碎掉了

遗憾的是从来没感受过被人坚定选择的感觉。

去吹吹风吧 能醒的话 感冒也没关系

这世间本就是各自下雪，各人有各人的隐晦和皎洁。

我喜欢风的透彻，像能望穿的快乐。

缘分

可遇不可求

预设的期待

更加自在

四月的天空如果不肯裂帛，

五月的袷衣如何起头？

一定要文采斐然吗，我磕磕绊绊，叙意不清的语句也是爱；一定要娓娓道来吗 我词不达意 语未由衷的叙述也是爱；一定要妙语连珠吗 我支支吾吾 含糊其辞的言语也是爱啊。

我喜欢奋达为的可乐

脚下的影子从来不肯试着像谁

影子，投射，类，穿着

​“我生来就是高山而非溪流，我欲于群峰之巅俯视平庸的沟壑。我生来就是人杰而非草芥，我站在伟人之肩藐视卑微的懦夫！”​

如果将无意义表现为逻辑颠倒不通的话，那便是哲学上的自杀

明明脑子里面有很好的句子，写到纸上却感到词不达意


函数中不在参数中的

仅能通过函数式变更的（总是赋予新值）

变量
就是状态 state

状态是执行某些计算所需的一个或多个变量，但不在相关函数的参数中


子串/子数组/子序列

例如：长度最小的子数组

滑动窗使用思路（寻找最长）

——核心：左右双指针(L，R)在起始点，R向右逐位滑动循环

—每次滑动过程中

如果：窗内元素满足条件，R向右扩大窗口，井更新最优结果如果：窗内元素不满足条件，L向右缩小窗口

—R到达结尾

滑动窗使用思路（寻找最短）

——核心：左右双指针(L，R)在起始点，R向右逐位滑动循环

—每次滑动过程中

如果：窗内元素满足条件，L向右缩小窗口，井更新最优结果如果：窗内元素不满足条件，R向右扩大窗口

——R到达结尾

v2 与hooks区别，面向对象与fp区别，组合，原子css，继承，把方法从 class中抽出来，class出现是为了分类约束，而鸭子类型才是世界的本原，我们不应该本能的归类，分类只有上帝才能做到，依赖注入是把功用方法抽象除去在注入到类中，本质也是他妈的组合

世界是具体的，不是抽象的，二极管，面向对象，向上抽象

链表无序

递归遍历

render 就是存的
ref就相当于违背了存函数，也就是不存了

vue 好还是 react 好，我选 angular！
- vue、react、angular 选哪个？，我选 jQuery。
- umi这种到处都是约定，增加心智负担的，真不想用

我有特别的 DNS 配置和使用技巧

永远不要低估用户的智障程度 —— 编程术语祛魅

正确的，早该祛祛魅了
只许文科祛魅，不许计算机祛魅是吧，早该哥白尼式革命了
虽然人品不怎么样，但是话糙理不糙，以后就像汽车家电一样傻瓜化，路上要是车坏了有几个人会修，修理店也是模块化，都是换总成，没有人会给你去修集成电路修发动机某个零部件

设计模式的本质是为了弥补语言抽象能力不足产生的东西。比如 visitor 模式也就 OOP 在用，支持点 pattern matching / lambda 的 FP 向语言基本不用。

没必要太多地去纠结这些东西，看不懂代码就去问写这个代码的人。
（暴论）

涉及设计模式/面向对象，凡是说“以后如果有xxx需求，可以直接xxx，不需要xxx”，基本上可以认为是糟粕。

如果真有预测需求的能力，那就更不用考虑预留可扩展性了。

亲身经历，当我为了一个功能设计了一个可扩展机制/系统之后，大约80%的情况下，直到项目解散，这个系统都没有机会扩展出下一个功能。

我也是一样的洁癖，所以能够虚拟机伺候的一律虚拟机。或者旧的 Mac 不要全部卖掉，留一台专门用来干脏活。

<!-- 有业务系统架构设计和研发经验，有前端组件库建设经验。 -->
<!-- 文件管理系统 -->
这一次 彻底搞懂 CRDT
简单来说墓碑机制就是当 app 进入后台前将应用状态以某种形式持久化然后释放其正在使用的资源（包括内存、CPU 等）等待 app 再次进入前台时再将这个保存的状态恢复出来此时应用就跟没有被杀死继续运行了一样。

谁会喜欢「寄生混合继承」这种费解的东西呢？

如果没有遇到性能瓶颈，就不要做性能优化。

setTimout 本质上就是一个注册一个延时触发的事件。并不是所有的状态改变都可以注册事件，有些场景不直接/间接使用 setTimeout/setInterval 就做不了。

简单讲就是做选择题，从候选答案里验证很容易，是多项式的算法时间复杂度，但是没有给出解自己去算，还是不是多项式时间复杂度。

np问题

canvas 只有一个 dom 标签，所以速度快

svg 也是 dom🏷
