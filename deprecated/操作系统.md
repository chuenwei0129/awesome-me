# 计算机知识图谱（一）<!-- omit in toc -->

***👀 TIPS: 二级标题可返回目录***

---

> ## 目录

- [图灵机](#图灵机)
  - [💾 资料](#-资料)
  - [📒 笔记](#-笔记)
  - [💭 总结](#-总结)
  - [🌐 拓展：罗素悖论](#-拓展罗素悖论)
  - [🌐 拓展：停机问题](#-拓展停机问题)
- [计算机底层科普](#计算机底层科普)
- [操作系统基础知识扫盲](#操作系统基础知识扫盲)
  - [📚 基础知识](#-基础知识)
  - [📒 学习笔记](#-学习笔记)
    - [程序？进程？](#程序进程)
    - [程序员应如何理解内存](#程序员应如何理解内存)
    - [进程的内存模型](#进程的内存模型)
    - [程序员应如何理解 CPU](#程序员应如何理解-cpu)
    - [操作系统是如何看待进程的](#操作系统是如何看待进程的)
    - [进程切换与线程切换的区别](#进程切换与线程切换的区别)
- [计算机为什么需要十六进制？](#计算机为什么需要十六进制)

## [图灵机](#目录)

### 💾 资料

- [图灵机的解释](https://mp.weixin.qq.com/s/oKrsznBAumrNvz4_xtktXw)
- [什么是图灵完备？](https://www.zhihu.com/question/20115374/answer/288346717)
- [为什么所有编程语言都是数据+指令?](https://www.bilibili.com/video/BV1Za411t7c6)

### 📒 笔记

> **数学运算的本质特征**：

1. 在每一步中，只需要关注少数符号
2. 每一步采取的行动，仅仅取决于当前的运算符号、计算人当前的记忆状态

**运算行为过程中的人，是完全可以由机器取代的**。这就是图灵最初给出的，自动运算机器的抽象逻辑归纳，也是用来证明判定问题不存在算法的方法：**如果一个问题无法用图灵机来完成，那么可以说，没有任何算法程序可以解决这个问题。也就是说，凡是能用算法方法解决的问题，也一定能用图灵机解决。**

> **图灵完备**

在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。———— 维基百科

> **Brainfuck is fully Turing-complete.**

BF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。

语言里的 8 个有效字符分别是：

- `>` 指针向右移动一格
- `<` 指针向左移动一格
- `+` 使指针当前格数值加一
- `-` 使指针当前格数值减一
- `.` 把当前格数值按 ASCII 表输出到终端
- `,` 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格
- `[` 当指针当前值为 0 时，程序跳转至与之对应的 `]` 之后；否则程序正常执行
- `]` 程序跳转回与之对应的 `[` 处

有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 'A' 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 'A'。

```bf
+++++

[
>+++++++++++++
<-
]

>.
```

把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 'A'。

**🐟 拓展：** *brainfuck 还有一个用处，一门新语言功能语法很复杂，要用数学证明的方式确定性说明它图灵完备会很麻烦，但只要用这门新语言实现一个 brainfuck 的解释器，那么就必然证明了是图灵完备的*

### 💭 总结

图灵机解决了几个问题：

1. **可计算性问题**。一个数是否是可计算的，称为可计算数。可计算数只是实数的一部分，大多数实数都是不可计算的。（通用计算机）
2. **可判定性问题**。是否存在通用的过程，判断某个公式是可以证明的。（停机问题）
3. **人类计算者与计算机等价**。通过图灵测试判定计算机的智能。（人工智能）

### 🌐 拓展：罗素悖论

理发师悖论由哲学家罗素在 1903 年提出，也称为罗素悖论。有一个理发师打广告，说：“我只给本城所有不给自己刮脸的人刮脸。”

问题是：理发师能不能给他自己刮脸呢？如果他不给自己刮脸，他就属于“不给自己刮脸的人”；如果他给自己刮脸，他就属于“给自己刮脸的人”，他就不该给自己刮脸。

在理发师悖论的基础上，罗素构建了一个“集合” S： S 由一切不是自身元素的集合组成。然后，罗素问：S 是否属于 S 呢？根据排中律，一个元素或者属于某个集合，或者不属于某个集合。因此，对于一个给定的集合，某个元素或者属于该集合，或者不属于该集合。

但对罗素提出的这个“集合” S 是否属于 S，却没有那么容易判断：如果 S 属于 S，根据 S 的定义，S 就不属于 S；反之，如果 S 不属于 S，同样根据定义，S 就属于 S。

### 🌐 拓展：停机问题

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220412-h59.png)

## [计算机底层科普](#目录)

- [你管这破玩意叫 CPU ？](https://zhuanlan.zhihu.com/p/367927405)
- [你管这破玩意叫编程语言？](https://zhuanlan.zhihu.com/p/359941312)
- [编译器是如何工作的](https://zhuanlan.zhihu.com/p/188747765)
- [CPU 空闲时在干嘛？](https://zhuanlan.zhihu.com/p/356447262)
- [计算机是如何启动的？](https://www.zhihu.com/question/40831686)
- [申请内存时底层发生了什么？](https://zhuanlan.zhihu.com/p/367386292)
- [数据结构是如何装入CPU寄存器的？](https://zhuanlan.zhihu.com/p/401956825)
- [你管这破玩意叫精简指令集？](https://zhuanlan.zhihu.com/p/384606064)
- [不懂CPU如何读写内存还敢说自己是程序员？](https://zhuanlan.zhihu.com/p/390117048)
- [CPU 核数与线程数有什么关系？](https://zhuanlan.zhihu.com/p/391588682)

## [操作系统基础知识扫盲](#目录)

### 📚 基础知识

- [程序？进程？傻傻分不清](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485647&idx=1&sn=3336b441482736b4e9a2b32f9d272a5b&source=41#wechat_redirect)
- [进程切换与线程切换的区别？](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485646&idx=1&sn=ab57d6e2e66affefc104e04740356b39&chksm=cfe9944ef89e1d58a87c295cf1c54f78c39238214405b446c8bf4f4371fc29e0fd8d2b3cf9a6&cur_album_id=1923404049802985480&scene=190#rd)
- [程序员应如何理解内存：上篇](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485653&idx=1&sn=24a27455af32fdf97f6787e4a29e856a&chksm=cfe99455f89e1d439f17ad9861e37ed9e908cde24a4e96b50a3fefd72f252ef790b7718a75b6&cur_album_id=1923404049802985480&scene=189#wechat_redirect)
- [程序员应如何理解内存：中篇](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485654&idx=1&sn=78f9b5ab2de0bcafac16d377914ce32a&source=41#wechat_redirect)
- [程序员应如何理解内存：下篇](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485655&idx=1&sn=5d757e85565fdd61c58321eccf2dfb83&source=41#wechat_redirect)
- [程序员应如何理解CPU：上篇](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485656&idx=1&sn=1d5659355934d6ad5d4ea0a5be8b6573&chksm=cfe99458f89e1d4e14201dee281ef71c971cae46ea7e2e68bbc06a64fb22f962daa6aabc4988&scene=178&cur_album_id=1923404049802985480#rd)
- [程序员应如何理解CPU：下篇](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485657&idx=1&sn=16189b162f7bbc49934cb5561c34920f&chksm=cfe99459f89e1d4fb92ea732f8e9c2b4cf7e88ad2d5650d174266247a798bd622ae1461cda3d&scene=178&cur_album_id=1923404049802985480#rd)
- [操作系统是如何看待进程的](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485658&idx=1&sn=524b9e859824f49feea8bfd748c9aba9&chksm=cfe9945af89e1d4c0df92e5356b78451a43093841f25e26747fea44f755e00bb4a645f63db4f&scene=178&cur_album_id=1923404049802985480#rd)

### 📒 学习笔记

#### 程序？进程？

> **程序其实包含两部分内容，一部分是指令(代码)，另一部分是数据。**

比如 `int a = 100;` 这段代码在生成的可执行程序中是没有对应的机器指令的，为什么，因为这是数据。

那么什么样的代码才有对应的可执行程序呢？比如 `if... while... +-*/，return` 等语句才会有对应的机器指令。

编译器将源代码分成两类，一类是对数据的操作，这一部分就被编译器翻译成了机器指令，这些指令统一放在可执行文件的代码段；另一类是数据，这些数据被编译器收集后放到了可执行文件的数据段。

> **进程是如何生成的**

我们的程序实际上是被操作系统运行起来的，大体经过了以下几个阶段。

1. 当我们双击程序图标或者键入程序名字后，操作系统根据程序的名字去磁盘中找到可执行程序。
2. 操作系统在内存为即将要运行的程序划出一块区域。
3. 操作系统将找到的可执行程序从磁盘中 copy 到刚刚划分出的内存区域当中。
4. 操作系统在内存中找到可执行程序代码段的起始位置，假设这个地址是 A。
5. 操作系统告诉 CPU 从 A 这个位置开始执行。

#### 程序员应如何理解内存

内存本身其实非常简单，内存的作用就是用来装数字 0 和数字 1 的，内存由一大堆的“盒子”组成，每个盒子中要么是 0 要么是 1，其中 8 个盒子被称之为一个“字节”，每 8 个盒子也就是一个字节都有一个编号，这些编号就是简单的从 0 开始依次累加的，这个编号就被称之为“内存地址”。

> **C/C++ 内存模型**

对于 C/C++ 程序员来说，常用的 int，char 等变量都被装在盒子中，char 值只需要一排盒子就能装下(8bit)，一个 int 值一般需要四排盒子才能装得下。

连续几排装有同样类型变量的盒子就是数组(array)，连续几排装有不同类型变量的盒子就是结构体(struct)，C/C++ 语言中不管多么复杂的数据结构都是在此基础上构建出来的。

现在你已经知道了对于 C/C++ 程序员来说，我们使用的变量是直接放在内存中的(盒子)，每一排盒子的地址就是我们熟知的“指针”，请记住，**指针就是你使用的变量在内存中的地址**，仅此而已。

C/C++程序在被执行时，需要在内存中划出两段区域用于存放数据，这两个区域就是我们熟悉的堆(Heap)和栈(Stack)，也称堆区和栈区，如图所示，其中堆区紧邻数据段，在数据段之上，而栈在最上方，栈和堆之间是尚未被使用的内存，随着程序的运行，当程序申请内存时栈区和堆区之间的空隙会减小，当程序释放内存后空隙会扩大，这就是C/C++程序的内存模型。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220413-ap3.png)

每个函数运行时都会在栈区上占用一块内存，这块内存中保存的是调用函数的参数以及函数中的定义的局部变量，这些变量在函数调用完成后会被释放。从这里可以看出栈上的变量无需程序员关心其释放问题，当函数调用完毕后会自动释放所占用的空间。

和栈上的变量不同的是，堆上分配的内存不会像栈一样被自动释放，在堆上分配的内存需要程序员手动释放，**如果程序员在堆上分配了一块内存，但在使用完后忘记释放，这种情况就被称之为“内存泄漏”。**

栈区上的变量可以在函数执行完成后被自动释放掉，在堆区上的分配内存除非程序员手动调用 free, delete 明确的告知内存使用完毕，否则这块内存就会一直被占用而不能用作其它用途，这就是堆区。

你可能会问，什么样的变量在需要在堆上分配呢，我们知道，函数调用完成后栈上的分配的局部变量会因为栈帧被释放而不再可用，堆区的存在就是为了解决这个问题，堆区中申请的内存不会因为栈帧的释放而不再可用，使得变量的生命周期不再局限于某个函数，其生命周期是靠程序员用 malloc(new) 以及 free(delete) 来控制的，这样的变量在使用时可以跨越函数调用。

> **堆与栈的本质是什么**

在编程语言中，堆区和栈区本质上都是内存，因此二者在本质上没有任何区别，只不过这两块内存的使用方式是不一样的。

> **Java、Python等内存模型**

Java、Python 等程序的一大优点就是内存的自动化管理，而 C/C++ 程序员需要自己来管理从堆上分配的内存。内存管理这一项工作在 Java、Python 等程序中被解释器接管了，解释器的这项功能被称为“垃圾回收器”。

在用法上 Java 中的堆和栈和 C/C++ 是一样的，只不过 Java 程序员无需关心内存的释放问题

一般情况下，Java 中的栈和 Java 对象都是 JVM 在自己的堆上分配出来的

> **指针与引用**

- **指针：** 直接在内存中找到变量所在位置。所以指针是实实在在的内存地址。
- **引用：** 告诉解释器你想使用的变量，然后解释器再去内存中找到变量的位置。所以引用只是解释器的一个承诺，只要这个变量存在，解释器就承诺能找到这个变量，程序员就可以使用这个变量，至于这个变量在内存中的什么地方是不需要程序员关心的。

#### 进程的内存模型

不管什么语言，最后操作系统看到的都是 C 程序，C 程序在内存运行起来就是进程。接下里我们就来看一下，操作系统中的进程在内存中到底是什么样子的，如下图所示(注意这幅图描述的是 32 位操作系统下进程在内存中是什么样子的)，我们需要注意以下几点：

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220413-ayj.png)

1. 在上图中多出了一块内存，注意，这块内存就是操作系统在运行的时候所占用的内存。
2. 每个进程独占一个连续的 4G 大小的内存，从内存地址 0 开始，一直到 0xffffffff，其中最上方的 1G 留给了操作系统使用，下方的 3G 是留给进程自己使用的，其中程序员可以操作的区域就是图中的堆区和栈区。

**每个进程都认为真实的内存就是 4G，其中 1G 被操作系统使用，剩余部分被进程使用，也就是可以被程序员使用。注意这是不受真实物理内存限制的，也就是说，即使真实的物理只有 256MB，进程同样认为在内存是 4G，其中 1G 是操作系统的，剩余 3G 是进程自己独占的，程序员依然可以按照内存大小是 3G 来写程序。所以在大小 256MB 的真实物理内存上，程序员依然可以一次性申请超过 256MB 的内存而且可以申请成功，后续内存的使用也不受影响。**

#### 程序员应如何理解 CPU

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220412-g4a.png)

> **CPU 是如何工作的**

本质上 CPU 的工作非常简单，CPU 依次从内存中取出指令，然后对指令进行解码，所谓“解码”就是弄清楚这条指令要做些什么

比如对指令 `“01001000100000111110110100001000”` 解码后，发现这是一个进行减法操作的指令，得到这些信息后 CPU 开始执行这条指令，执行完成后继续取出下一条指令继续执行。因此你会发现 CPU 的工作过程就是这样的：

1. 从内存中取出机器指令
2. 对指令进行解码
3. 执行指令，执行完毕后回到 1

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/computer/SCR-20220413-b3r.png)

> **寄存器**

相对于 CPU 的速度来说，CPU 会觉得从内存读取和写入是很慢的。你可以把寄存器理解为放在 CPU 中的特殊内存，所谓特殊指的是读写速度非常快，速度快到足以匹配 CPU。也就是说你可把寄存器简单的理解为读写速度飞快的内存，注意寄存器是和 CPU 放在一起的。

> **程序计数器(Program Counter)**

CPU 是怎么知道从内存中的哪个位置取出指令呢？

原来，CPU 中有一个专门的寄存器用来存放下一条指令的内存地址。当 CPU 执行完一个指令后，就会根据这个寄存器中的内存地址取出下一条指令，取出指令后，该寄存器的内存地址 +1，然后指向 CPU 要执行的下一条指令。

这个寄存器在大部分教材中叫做 Program Counter，中文译作程序计数器。这个名字不是很贴切，因此也有人称之为指令地址寄存器 Instruction Address Register (IAR)，或者**指令指针**Instruction Pointer (IP)，后面这两个名字更形象一些。

CPU 中有一类跳转指令，比如：`jim rax`。其中 rax 中保存是要跳转的内存地址。CPU 会根据前面指令的结果来决定要不要跳转，如果计算出结果后需要跳转，那么程序计数器中的内存地址更改为 rax，这就是 C 语言中if是如何实现的。而如果要跳转的内存地址指令是 CPU 已经执行过的，那么就形成了循环，这就是 C 语言中 for 或 while 循环是如何实现的。

> **栈指针（Stack Pointer）**

跟踪调用栈是通过 CPU 中叫做栈指针 stack pointer 的寄存器来完成的，任何时候，只要通过查看CPU的栈指针，我们就能知道进程中当前正在被执行函数的栈帧在内存中的位置。

#### 操作系统是如何看待进程的

CPU 在执行指令时工作在两种模式下：“内核模式(Kernel mode)”以及“用户模式(User mode)”。

CPU 在用户模式下只能执行部分整个指令集的一部分，比如在用户模式下不能执行与 I/O 有关的指令，不能访问整个内存的地址空间，不可以执行特权指令。但是在内核模式下，CPU 可以执行其指令集架构允许的任何机器指令包括特权指令，可以访问所有的内存地址，可以执行 I/O 操作等等。

在操作系统眼里，用户程序是一个充满了 bug 随时会崩溃的定时炸弹（必须承认，我们写的代码里藏有很多bug :) ），或者干脆就是某些天才程序员用来恶意控制整个计算机的破坏者。

当我们的程序在访问硬件，比如读写文件(磁盘)、收发网络数据(网卡)、接收键盘按键、响应鼠标点击事件、又或者创建线程、创建进程、查看系统时间等操作时都需要依赖操作系统完成这些任务。操作系统对这些复杂的过程进行了很好的封装，在程序员看来这仅仅就是一个简单的函数调用。

那么所谓“操作系统来实现”指的是当用户程序进行文件读写调用比如 read 函数时，CPU 开始时执行的是 read 函数，但在调用过程中 CPU 跳转到操作系统的代码，这时操作系统替我们去进行文件读取，当操作系统完成文件读取后，CPU 跳转回来继续执行 read 函数的后半部分。因此在程序员看来 read 就是一个普通的函数调用，实际上 read 函数的执行必须依赖操作系统才能完成。

#### 进程切换与线程切换的区别

> **虚拟内存解放生产力**

作为程序员我们根本就不关心数据以及程序被放在了物理内存的哪个位置上(设计实现操作系统的程序员除外)，我们可以简单的认为我们的程序独占内存，比如在 32 位系统下我们的进程占用的内存空间为 4G；并且我们可以申请超过物理内存大小的空间，比如在只有 256MB 的系统上程序员可以申请 1G 大小的内存空间，这种假设极大的解放了程序员的生产力。

> **什么是虚拟内存**

虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的虚拟内存，当然我们知道最终进程的数据及代码必然要放到物理内存上，那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，这就是所谓的地址空间映射，也就是虚拟内存地址与物理内存地址的映射关系，那么操作系统是如何记住这种映射关系的呢，答案就是页表，页表中记录了虚拟内存地址到物理内存地址的映射关系。有了页表就可以将虚拟地址转换为物理内存地址了，这种机制就是虚拟内存。

每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。

> **进程切换与线程切换的区别**

进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用 cache 来缓存常用的地址映射，这样可以加速页表查找，这个 cache 就是TLB，Translation Lookaside Buffer，我们不需要关心这个名字只需要知道 TLB 本质上就是一个 cache，是用来加速页表查找的。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后 TLB 就失效了，cache 失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致 TLB 失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。

## [计算机为什么需要十六进制？](#目录)

**内存是按照字节粒度来寻址的**，因此采用的数字系统必须很好的表达一个字节，也就是 8 比特，从这个角度上看 256 进制 (2^8) 是最好的，因为一个 256 进制就是表达一个字节，但还是基于可读性的原因，256 进制对于人类来说记忆负担过重，而 16 进制则刚刚好，**一个 16 进制数字表示一个字节的一半( 4 个比特)**，两个 16 进制数字正好表示一个字节。

那为什么一个字节有 8 比特而不是 7 比特或者 9 比特呢？其实答案很简单：**历史原因**
