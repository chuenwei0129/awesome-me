# 计算机知识图谱

## 图灵机

### 图灵机的解释

> [图灵机的解释](https://mp.weixin.qq.com/s/oKrsznBAumrNvz4_xtktXw)

**数学运算的本质特征**：

1. 在每一步中，只需要关注少数符号
2. 每一步采取的行动，仅仅取决于当前的运算符号、计算人当前的记忆状态

**运算行为过程中的人，是完全可以由机器取代的**。这就是图灵最初给出的，自动运算机器的抽象逻辑归纳，也是用来证明判定问题不存在算法的方法：**如果一个问题无法用图灵机来完成，那么可以说，没有任何算法程序可以解决这个问题。也就是说，凡是能用算法方法解决的问题，也一定能用图灵机解决。**

### 图灵机的结构

> [什么是图灵完备？](https://www.zhihu.com/question/20115374/answer/288346717)

**图灵机的结构包括以下几个部分：**

- 一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。
- 一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。
- 一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。
- 一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解有限状态机，它便对应着有限状态机里的状态。
- 一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号 53 的格子并看到其内容为 0 时，擦除，改写为 1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/terminal/v2-6d57f9001041416d43e886f14fd43f84_1440w.png)

在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：

- 当前所处位置
- 当前格子内容

来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“...011001...”）便作为输出，由人来解码为自然语言。

### 图灵完备性

**图灵完备性**（Turing Completeness）是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。**当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性**。直白一点说，图灵完备性就是我给你一工具箱的东西，包括无限内存、if/else 控制流、while 循环……那么你现在图灵完备了吗？

> 在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。（维基百科）

<!-- 注释部份是结合评论区我的理解，brainfuck 的 8 种符号 `[]`：相当于 while 循环`<>`：相当于内存寻址； `+-`：相当于自增，自减； `,.`：相当于输入，输出。
指针左右移状态模拟 if else，if else不必需，本质是状换
含有 顺序连接 / 循环(WHILE) / 跳转(IF-ELSE) 这三种连接结构的计算机语言是完备的，-->

### 直观理解图灵完备 —— Brainfuck 语言

在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令。语言虽然极致轻量，它却是一门图灵完备的编程语言。如果能理解它的工作原理，那么对于理解图灵机是有很大帮助的。

> Brainfuck is fully Turing-complete.

先贴上一段 BF 的代码，体验一下它的画风：

```sh
++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++
.------.--------.>>+.>++.
```

这个程序编译运行后，控制台打印 "Hello World!"。

BF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。

语言里的 8 个有效字符分别是：

- `>` 指针向右移动一格
- `<` 指针向左移动一格
- `+` 使指针当前格数值加一
- `-` 使指针当前格数值减一
- `.` 把当前格数值按 ASCII 表输出到终端
- `,` 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格
- `[` 当指针当前值为 0 时，程序跳转至与之对应的 `]` 之后；否则程序正常执行
- `]` 程序跳转回与之对应的 `[` 处

有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 'A' 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 'A'。

```sh
+++++

[
>+++++++++++++
<-
]

>.
```

把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 'A'。

> brainfuck 还有一个用处，一门新语言功能语法很复杂，要用数学证明的方式确定性说明它图灵完备会很麻烦，但只要用这门新语言实现一个brainfuck 的解释器，那么就必然证明了是图灵完备的

<!-- 感觉图灵机的纸带就是内存，前后移动读写就是提供操作内存的必要方法，但是关键的head里的规则却是个黑盒，没有任何描述，包括最关键的if，规则都没定，怎么验证图灵完备
​
就是要有了规则才可以验证它是否是图灵完备。换句话说，图灵完备与否就是对于一套规则而言的。
比如我给你读写头和纸带，但给你的操作规则不允许你向内存写入除0以外的值，那不就是图灵不完备了嘛

是不是所有可计算的问题最后都归一成加法问题？

我也不是计算理论方面的专家，不能保证说的对。不过我觉得非数值的计算问题（比如命题取否）显然不能归一为加法问题。如果限定是数值计算问题的话（加减乘除指数阶乘什么的），倒是挺有可能归一成加法的
不是，是归一成状态01转换的逻辑问题。
十进制的计算归一成二进制计算
评论区有价值的问答
往下翻小狗图灵完备
-->

### 总结

图灵机解决了几个问题：

1. 可计算性问题。一个数是否是可计算的，称为可计算数。可计算数只是实数的一部分，大多数实数都是不可计算的。（通用计算机）
2. 可判定性问题。是否存在通用的过程，判断某个公式是可以证明的。（停机问题）
3. 人类计算者与计算机等价。通过图灵测试判定计算机的智能。（人工智能）

> [为什么所有编程语言都是数据+指令?](https://www.bilibili.com/video/BV1Za411t7c6)

## 拓展：罗素悖论

理发师悖论由哲学家罗素在 1903 年提出，也称为罗素悖论。有一个理发师打广告，说：“我只给本城所有不给自己刮脸的人刮脸。”问题是：理发师能不能给他自己刮脸呢？如果他不给自己刮脸，他就属于“不给自己刮脸的人”；如果他给自己刮脸，他就属于“给自己刮脸的人”，他就不该给自己刮脸。

在理发师悖论的基础上，罗素构建了一个“集合” S： S 由一切不是自身元素的集合组成。然后，罗素问：S 是否属于 S 呢？根据排中律，一个元素或者属于某个集合，或者不属于某个集合。因此，对于一个给定的集合，某个元素或者属于该集合，或者不属于该集合。但对罗素提出的这个“集合” S 是否属于 S，却没有那么容易判断：如果 S 属于 S，根据 S 的定义，S 就不属于 S；反之，如果 S 不属于 S，同样根据定义，S 就属于 S。

## 拓展：停机问题

我定义了一个函数，y=1/x，x 是输入，y 是输出，除法的本质是累减，6/3=2 表示 6 能减去 2 趟 3，故当我输入 0 时，1-0-0-0...，程序就傻了，愣在那里，称为停机。。

所以说停机的源头是非法的输入，一个很简单的解决思路——事先判断该输入是否非法，比如：限制 x≠0，伪代码：`if(x != 0) y=1/x`;

这是做法被称为提高程序的健壮性。。

但是，问题来了，y=1/x 只是某个程序，这世间的程序有千万种，甚至某一程序的非法输入也有千万种，你们可能听过一个笑话：**一个测试工程师进入一间酒吧点了一个汉堡。。**

<!-- 笑话指的是永远不要相信用户的输入 -->

所以，人们就希望，有这么一个程序，它能判断任何程序与任何输入之间是否是非法的，是否会停机（死循环）。。

假设这个程序叫 H，如果 H 存在，那太好了，世间很多难题都可以解决了，比如费马大定理，我就可以写一个穷举算法，然后让 H 来判断，这样菲尔兹奖就是我的了。。

所以显然 H 是不存在的，那 H 为什么不存在呢？

主要有两个麻烦点，①H 能否判断 H，类似于“理发师悖论”，②H 能判断任意程序，那我只要找出一个反例，便可证伪。。

我故意写一个 bug 程序，交给 H 来判断，而且这个 bug 程序还包含 H 自身，运用了自我干涉的方法。。

这个 bug 程序我们如此定义：`if( H 判断我不停机 ) 那我就停机; esle 否则我就不停机;`

诶，就跟你对着干，你看你解决不了我，那就说明你解决不了任意程序，毕竟我是任意中的一种。。

1936 年，在那个电子计算机还没诞生的年代，图灵提出了 The Halting Problem(停机问题)，并证明它是一个不可解问题。。

## 计算机系统 64 位 32 位指的是什么

<https://www.youtube.com/watch?v=Wu2A4fpFzgs>

## 复杂指令集 CISC 和精简指令集 RISC

我们可以继续举个例子，比如说我们要命令一个人吃饭，那么我们应该怎么命令呢？我们可以直接对他下达“吃饭”的命令，也可以命令他“先拿勺子，然后舀起一勺饭，然后张嘴，然后送到嘴里，最后咽下去”。

从这里可以看到，对于命令别人做事这样一件事情，不同的人有不同的理解，有人认为，如果我首先给接受命令的人以足够的训练，让他掌握各种复杂技能（即在硬件中实现对应的复杂功能），那么以后就可以用非常简单的命令让他去做很复杂的事情——比如只要说一句“吃饭”，他就会吃饭。

但是也有人认为这样会让事情变的太复杂，毕竟接受命令的人要做的事情很复杂，如果你这时候想让他吃菜怎么办？难道继续训练他吃菜的方法？我们为什么不可以把事情分为许多非常基本的步骤，这样只需要接受命令的人懂得很少的基本技能，就可以完成同样的工作，无非是下达命令的人稍微累一点——比如现在我要他吃菜，只需要把刚刚吃饭命令里的“舀起一勺饭”改成“舀起一勺菜”，问题就解决了，多么简单。这就是“复杂指令集”和“精简指令集”的逻辑区别。

> [分不清ARM和X86架构，别跟我说你懂CPU！](https://zhuanlan.zhihu.com/p/21266987)

## cpu

## 程序是怎么跑起来的



### cpu



## 基于 IEEE 754 标准的双精度 64 位的浮点数

> [从科学记数法到浮点数标准 IEEE 754](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)

## 位运算

### 进制转换

![二进制与十进制转换方法](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/terminal/SCR-20220408-acz.png)

### 原码、反码、补码

> 参考

- [JavaScript 中的位运算和权限设计](https://juejin.cn/post/6844903988945485837)
- [一文搞明白位运算、补码、反码、原码](https://juejin.cn/post/6844903912425259022)

## 进程、线程、线程

不请自来。
看见上面几位的回答我真的是醉了。说几句我的理解。
首先来一句概括的总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述。是运行中的程序指令的一种描述，这需要与程序中的代码区别开来。

另外注意这里我说的进程线程概念，和编程语言中的API接口对应的进程/线程是有差异的。

下面细说背景：
CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备则难以望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。而且因为速度差异，CPU实际的执行时间和等待执行的时间是数量级的差异。比如工作1秒钟，休息一个月。所以多个任务，轮流着来，让CPU不那么无聊，给流逝的时间增加再多一点点的意义。这些任务，在外在表现上就仿佛是同时在执行。

一个必须知道的事实：执行一段程序代码，实现一个功能的过程之前 ，当得到CPU的时候，相关的资源必须也已经就位，就是万事俱备只欠CPU这个东风。所有这些任务都处于就绪队列，然后由操作系统的调度算法，选出某个任务，让CPU来执行。然后就是PC指针指向该任务的代码开始，由CPU开始取指令，然后执行。

这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了的进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。

串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载进程A的上下文，然后开始执行A，保存进程A的上下文，调入下一个要执行的进程B的进程上下文，然后开始执行B,保存进程B的上下文。。。。

========= 重要的东西出现了========
进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。

进程就是上下文切换之间的程序执行的部分。是运行中的程序的描述，也是对应于该段CPU执行时间的描述。
在软件编码方面，我们说的进程，其实是稍不同的，编程语言中创建的进程是一个无限loop，对应的是tcb块。这个是操作系统进行调度的单位。所以和上面的cpu执行时间段还是不同的。
进程，与之相关的东东有寻址空间，寄存器组，堆栈空间等。即不同的进程，这些东东都不同，从而能相互区别。
线程是什么呢？
进程的颗粒度太大，每次的执行都要进行进程上下文的切换。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：

程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。

这里a，b，c的执行是共享了A进程的上下文，CPU在执行的时候仅仅切换线程的上下文，而没有进行进程上下文切换的。进程的上下文切换的时间开销是远远大于线程上下文时间的开销。这样就让CPU的有效使用率得到提高。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。线程主要共享的是进程的地址空间。

到此全文结束，再一个总结：

进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。

注意这里描述的进程线程概念和实际代码中所说的进程线程是有区别的。编程语言中的定义方式仅仅是语言的实现方式，是对进程线程概念的物化。

我们先来做一个思维实验. 想象一下我们有一台最简单的计算机.

我们先完全不考虑什么操作系统什么虚拟内存, 就当这些东西完全不存在.

这台 "计算机" 的全部功能就是每秒钟神奇地从 "磁盘" 找到一条指令, 送入 "CPU" , 让 "CPU" 按顺序执行.

假设磁盘上有个程序A, 里面包含17条指令, 那么我们的计算机就需要17秒去完成这个程序. 而这17秒之内, 我们的计算机无法做别的事情. 这看起来很蠢不是么? 想象一下一台电脑无法边打字边听音乐.

所以我们要对计算机做出改进, 让他能够交替的执行程序A程序B程序C程序D.

再一次假设全知全能的我们完成了对计算机的改造, 现在我们的计算机可以做到同时执行多个程序.

还是那个拥有17条指令的程序A和一个拥有42条指令的程序B. 我们可以先执行一秒钟程序A, 再执行一秒钟程序B, 再执行一秒钟程序A. 看上去在同时执行两条程序似的.

那程序A对应的进程到底是什么? 是那17条指令? 是那17秒钟? 好像都不是.

进程A就是处理这17条指令的过程; 而进程B就是处理这42条指令的过程.

什么? 进程就是过程? process is process? 这说了和没说有什么区别?

没错, 很遗憾的说, 对于一个还未入门的人来说, 这就是最低程度的抽象了.

你看, 哪怕是最最简单的计算机, 我们依旧无法说清「进程到底是什么」.

因为进程这个概念本身就是抽象的.

关于「进程是什么」的回答在网络上到处都是, 而你却特地跑来知乎问, 说明你对那些文章都不满意, 你希望得到一个很漂亮的回答, 一个让人一眼看过去就茅塞顿开的回答. 实际上这是很难的. 就好比人们总是希望一句话就说清楚生活的意义是什么. 实际上也是很难的.

费曼在<The Feynman Lectures on Physics>里说过微观世界无论是对新手还是物理学家都是抽象的. 而我们的教科书却还是试图用行星绕着太阳这样的模型去描述电子绕着质子.

Things on a very small scale behave like nothing that you have any direct experience about. They do not behave like waves, they do not behave like particles, they do not behave like clouds, or billiard balls, or weights on springs, or like anything that you have ever seen. (...)
Because atomic behavior is so unlike ordinary experience, it is very difficult to get used to, and it appears peculiar and mysterious to everyone--both to the novice and the experienced physicist.
所以我到底想要表达什么呢?

大概就是: 
