# 计算机知识图谱

回调函数的本质就是“只有我们才知道做些什么，但是我们并不清楚什么时候去做这些，只有其它模块才知道，因此我们必须把我们知道的封装成回调函数告诉其它模块”。

而之所以需要给第三方库指定回调函数，是因为第三方库的编写者并不清楚在某些特定节点，比如我们举的例子油条制作完成、接收到网络数据、文件读取完成等之后该做什么，这些只有库的使用方才知道，因此第三方库的编写者无法针对具体的实现来写代码，而只能对外提供一个回调函数，库的使用方来实现该函数，第三方库在特定的节点调用该回调函数就可以了。
另一点值得注意的是，从图中我们可以看出回调函数和我们的主程序位于同一层中，我们只负责编写该回调函数，但并不是我们来调用的。
最后值得注意的一点就是回调函数被调用的时间节点，回调函数只在某些特定的节点被调用，就像上面说的油条制作完成、接收到网络数据、文件读取完成等，这些都是事件，也就是event，本质上我们编写的回调函数就是用来处理event的，因此从这个角度看回调函数不过就是event handler，因此回调函数天然适用于事件驱动编程event-driven，我们将会在后续文章中再次回到这一主题。
chromium分为。浏览器进程
(1)，渲染进程(n)，GPU进程(1)，网络进程(1)，插件进程(n)。

chrome 本意是指浏览器中间的那个用户界面。之后 google 把自己的浏览器命名为 chrome 了。相当于有个人给自己取名字叫“人类”。
多核 CPU 和多个 CPU 有何区别？
某种程度来说，其实是一样的，都是SMP（对称多处理器，Symmetric MultiProcessing）,对于操作系统来说，每个核心都是作为单独的CPU对待的。所以在某个地方省事了，就必须在另外一个地方费劲。
不同的核心运行多个线程，总有需要交换数据的时候，根源为不同的核心需要访问同一个内存地址的数据——而核心Core0要访问这个地址的数据时，可能已经被核心Core2加载到缓存中并进行了修改。虽然理论上可以让Core2把缓存数据同步到内存后，Core0再从内存读取数据，但内存访问的速度比CPU速度慢很多，一般是直接访问Core2的缓存。
知乎真是伪科普圣地，看了大半页就这一个回答是靠谱的。单机多核/多CPU最重要区别就是在核间互连和数据共享的性能，多CPU的off-chip通信实在是不能忍的。其实即便是在板子上，总线的话布局布线倒也不是问题，crossbar什么的就成问题了。
何为多核CPU？简单理解就是，我们将多个核心装载一个封装里，让用户理解成这是一个处理器。这样好处就是原本运行在单机上跑的程序基本不需要更改就能够获得非常不错的性能。多核心发展趋势也是英特尔一直坚持的方式。

进程可以简单理解为一个容器有自己独立的地址空间。一个进程可由多个线程的执行单元组成，每个线程都运行在同一进程的上下文中，共享进程该地址空间以及其内的代码和全局数据等资源即线程之间共享进程中的数据


每个进程至少有一个主线程，它无需由用户主动创建，一般由系统自动创建。系统创建好进程后，实际上就启动了执行该进程的执行主线程，执行主线程以函数地址形式，即程序入口函数（如 main函数），将程序的启动点提供给操作系统。主执行线程终止或关闭，进程也就随之终止，操作系统会回收改进程所占用的资源


进程中的任意一线程执行出错，都会导致整个进程的崩溃。


进程之间的内容相互隔离。进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。


严格讲应该是线程能够获得CPU资源，进程对CPU资源的获取也是体现在线程上的。CPU内核数，和进程线程没直接关系。操作系统（OS）可以把某个进程部署在某个CPU核上，但这取决于系统设计。


进程、线程都是由操作系统调度的，线程只是由进程创建，但是进程本身不会负责调度线程。在操作系统看来，线程和进程其实差不多，不同点是线程是迷你的进程，并且进程可以包含多个线程


对于内存堆内存、代码区一般属于一个进程，但是栈(执行栈)却是属于一个线程的，且每个线程拥有一个独立的栈。


总结一下：
进程和线程都是CPU工作一个时间段的描述


进程就是上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文


线程是共享了进程的上下文环境，的更为细小的CPU时间段。


两者之间的详细区别可以参考下图：
程序与进程、线程的关系
程序 : 是一组指令的有序集合,是一个静态的实体，本身没有任何运行的含义。
进程 : 是程序在某个数据集上的执行， 即进程是程序的一次执行，是一个动态的实体，有自己的生命周期，因创建而产生、因调度而运行、因等待资源或事件而被处于等待状态、因任务完成而被撤销，反映的是一个程序在一定的数据集上运行的全部动态过程。
无论系统有几个CPU，每个进程运行在单个CPU上，如果单CPU有多个进程则多个进程并发执行。
线程 : 程序执行的最小单元，每个程序都至少有一个线程，若程序只有一个线程，那就是它程序本身。单线程的进程可以简单地理解为只有一个线程的进程，一个进程在同一时间只做一件事。多线程的进程可以理解为一个进程同一时间段做多件事，每个线程可以处理不同的事务，一个线程阻塞不会影响另一个线程。

作者：前端小小min
链接：https://juejin.cn/post/6936486914568486943
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 图灵机

### 图灵机的解释

> [图灵机的解释](https://mp.weixin.qq.com/s/oKrsznBAumrNvz4_xtktXw)

**数学运算的本质特征**：

1. 在每一步中，只需要关注少数符号
2. 每一步采取的行动，仅仅取决于当前的运算符号、计算人当前的记忆状态

**运算行为过程中的人，是完全可以由机器取代的**。这就是图灵最初给出的，自动运算机器的抽象逻辑归纳，也是用来证明判定问题不存在算法的方法：**如果一个问题无法用图灵机来完成，那么可以说，没有任何算法程序可以解决这个问题。也就是说，凡是能用算法方法解决的问题，也一定能用图灵机解决。**

### 图灵机的结构

> [什么是图灵完备？](https://www.zhihu.com/question/20115374/answer/288346717)

**图灵机的结构包括以下几个部分：**

- 一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。
- 一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。
- 一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。
- 一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解有限状态机，它便对应着有限状态机里的状态。
- 一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号 53 的格子并看到其内容为 0 时，擦除，改写为 1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。

![](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/terminal/v2-6d57f9001041416d43e886f14fd43f84_1440w.png)

在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：

- 当前所处位置
- 当前格子内容

来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“...011001...”）便作为输出，由人来解码为自然语言。

### 图灵完备性

**图灵完备性**（Turing Completeness）是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。**当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性**。直白一点说，图灵完备性就是我给你一工具箱的东西，包括无限内存、if/else 控制流、while 循环……那么你现在图灵完备了吗？

> 在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。（维基百科）

<!-- 注释部份是结合评论区我的理解，brainfuck 的 8 种符号 `[]`：相当于 while 循环`<>`：相当于内存寻址； `+-`：相当于自增，自减； `,.`：相当于输入，输出。
指针左右移状态模拟 if else，if else不必需，本质是状换
含有 顺序连接 / 循环(WHILE) / 跳转(IF-ELSE) 这三种连接结构的计算机语言是完备的，-->

### 直观理解图灵完备 —— Brainfuck 语言

在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令。语言虽然极致轻量，它却是一门图灵完备的编程语言。如果能理解它的工作原理，那么对于理解图灵机是有很大帮助的。

> Brainfuck is fully Turing-complete.

先贴上一段 BF 的代码，体验一下它的画风：

```sh
++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++
.------.--------.>>+.>++.
```

这个程序编译运行后，控制台打印 "Hello World!"。

BF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。

语言里的 8 个有效字符分别是：

- `>` 指针向右移动一格
- `<` 指针向左移动一格
- `+` 使指针当前格数值加一
- `-` 使指针当前格数值减一
- `.` 把当前格数值按 ASCII 表输出到终端
- `,` 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格
- `[` 当指针当前值为 0 时，程序跳转至与之对应的 `]` 之后；否则程序正常执行
- `]` 程序跳转回与之对应的 `[` 处

有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 'A' 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 'A'。

```sh
+++++

[
>+++++++++++++
<-
]

>.
```

把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 'A'。

> brainfuck 还有一个用处，一门新语言功能语法很复杂，要用数学证明的方式确定性说明它图灵完备会很麻烦，但只要用这门新语言实现一个brainfuck 的解释器，那么就必然证明了是图灵完备的

<!-- 感觉图灵机的纸带就是内存，前后移动读写就是提供操作内存的必要方法，但是关键的head里的规则却是个黑盒，没有任何描述，包括最关键的if，规则都没定，怎么验证图灵完备
​
就是要有了规则才可以验证它是否是图灵完备。换句话说，图灵完备与否就是对于一套规则而言的。
比如我给你读写头和纸带，但给你的操作规则不允许你向内存写入除0以外的值，那不就是图灵不完备了嘛

是不是所有可计算的问题最后都归一成加法问题？

我也不是计算理论方面的专家，不能保证说的对。不过我觉得非数值的计算问题（比如命题取否）显然不能归一为加法问题。如果限定是数值计算问题的话（加减乘除指数阶乘什么的），倒是挺有可能归一成加法的
不是，是归一成状态01转换的逻辑问题。
十进制的计算归一成二进制计算
评论区有价值的问答
往下翻小狗图灵完备
-->

### 总结

图灵机解决了几个问题：

1. 可计算性问题。一个数是否是可计算的，称为可计算数。可计算数只是实数的一部分，大多数实数都是不可计算的。（通用计算机）
2. 可判定性问题。是否存在通用的过程，判断某个公式是可以证明的。（停机问题）
3. 人类计算者与计算机等价。通过图灵测试判定计算机的智能。（人工智能）

> [为什么所有编程语言都是数据+指令?](https://www.bilibili.com/video/BV1Za411t7c6)

## 拓展：罗素悖论

理发师悖论由哲学家罗素在 1903 年提出，也称为罗素悖论。有一个理发师打广告，说：“我只给本城所有不给自己刮脸的人刮脸。”问题是：理发师能不能给他自己刮脸呢？如果他不给自己刮脸，他就属于“不给自己刮脸的人”；如果他给自己刮脸，他就属于“给自己刮脸的人”，他就不该给自己刮脸。

在理发师悖论的基础上，罗素构建了一个“集合” S： S 由一切不是自身元素的集合组成。然后，罗素问：S 是否属于 S 呢？根据排中律，一个元素或者属于某个集合，或者不属于某个集合。因此，对于一个给定的集合，某个元素或者属于该集合，或者不属于该集合。但对罗素提出的这个“集合” S 是否属于 S，却没有那么容易判断：如果 S 属于 S，根据 S 的定义，S 就不属于 S；反之，如果 S 不属于 S，同样根据定义，S 就属于 S。

## 拓展：停机问题

我定义了一个函数，y=1/x，x 是输入，y 是输出，除法的本质是累减，6/3=2 表示 6 能减去 2 趟 3，故当我输入 0 时，1-0-0-0...，程序就傻了，愣在那里，称为停机。。

所以说停机的源头是非法的输入，一个很简单的解决思路——事先判断该输入是否非法，比如：限制 x≠0，伪代码：`if(x != 0) y=1/x`;

这是做法被称为提高程序的健壮性。。

但是，问题来了，y=1/x 只是某个程序，这世间的程序有千万种，甚至某一程序的非法输入也有千万种，你们可能听过一个笑话：**一个测试工程师进入一间酒吧点了一个汉堡。。**

<!-- 笑话指的是永远不要相信用户的输入 -->

所以，人们就希望，有这么一个程序，它能判断任何程序与任何输入之间是否是非法的，是否会停机（死循环）。。

假设这个程序叫 H，如果 H 存在，那太好了，世间很多难题都可以解决了，比如费马大定理，我就可以写一个穷举算法，然后让 H 来判断，这样菲尔兹奖就是我的了。。

所以显然 H 是不存在的，那 H 为什么不存在呢？

主要有两个麻烦点，①H 能否判断 H，类似于“理发师悖论”，②H 能判断任意程序，那我只要找出一个反例，便可证伪。。

我故意写一个 bug 程序，交给 H 来判断，而且这个 bug 程序还包含 H 自身，运用了自我干涉的方法。。

这个 bug 程序我们如此定义：`if( H 判断我不停机 ) 那我就停机; esle 否则我就不停机;`

诶，就跟你对着干，你看你解决不了我，那就说明你解决不了任意程序，毕竟我是任意中的一种。。

1936 年，在那个电子计算机还没诞生的年代，图灵提出了 The Halting Problem(停机问题)，并证明它是一个不可解问题。。

## 计算机系统 64 位 32 位指的是什么

<https://www.youtube.com/watch?v=Wu2A4fpFzgs>

## 复杂指令集 CISC 和精简指令集 RISC

我们可以继续举个例子，比如说我们要命令一个人吃饭，那么我们应该怎么命令呢？我们可以直接对他下达“吃饭”的命令，也可以命令他“先拿勺子，然后舀起一勺饭，然后张嘴，然后送到嘴里，最后咽下去”。

从这里可以看到，对于命令别人做事这样一件事情，不同的人有不同的理解，有人认为，如果我首先给接受命令的人以足够的训练，让他掌握各种复杂技能（即在硬件中实现对应的复杂功能），那么以后就可以用非常简单的命令让他去做很复杂的事情——比如只要说一句“吃饭”，他就会吃饭。

但是也有人认为这样会让事情变的太复杂，毕竟接受命令的人要做的事情很复杂，如果你这时候想让他吃菜怎么办？难道继续训练他吃菜的方法？我们为什么不可以把事情分为许多非常基本的步骤，这样只需要接受命令的人懂得很少的基本技能，就可以完成同样的工作，无非是下达命令的人稍微累一点——比如现在我要他吃菜，只需要把刚刚吃饭命令里的“舀起一勺饭”改成“舀起一勺菜”，问题就解决了，多么简单。这就是“复杂指令集”和“精简指令集”的逻辑区别。

> [分不清ARM和X86架构，别跟我说你懂CPU！](https://zhuanlan.zhihu.com/p/21266987)

## cpu

## 程序是怎么跑起来的



### cpu



## 基于 IEEE 754 标准的双精度 64 位的浮点数

> [从科学记数法到浮点数标准 IEEE 754](https://mp.weixin.qq.com/s/mf1mH-aGWgcC6v2R8ijE8A)

## 位运算

### 进制转换

![二进制与十进制转换方法](https://raw.githubusercontent.com/chuenwei0129/my-picgo-repo/master/terminal/SCR-20220408-acz.png)

### 原码、反码、补码

> 参考

- [JavaScript 中的位运算和权限设计](https://juejin.cn/post/6844903988945485837)
- [一文搞明白位运算、补码、反码、原码](https://juejin.cn/post/6844903912425259022)

## 进程、线程、线程

不请自来。
看见上面几位的回答我真的是醉了。说几句我的理解。
首先来一句概括的总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述。是运行中的程序指令的一种描述，这需要与程序中的代码区别开来。

另外注意这里我说的进程线程概念，和编程语言中的API接口对应的进程/线程是有差异的。

下面细说背景：
CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备则难以望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。而且因为速度差异，CPU实际的执行时间和等待执行的时间是数量级的差异。比如工作1秒钟，休息一个月。所以多个任务，轮流着来，让CPU不那么无聊，给流逝的时间增加再多一点点的意义。这些任务，在外在表现上就仿佛是同时在执行。

一个必须知道的事实：执行一段程序代码，实现一个功能的过程之前 ，当得到CPU的时候，相关的资源必须也已经就位，就是万事俱备只欠CPU这个东风。所有这些任务都处于就绪队列，然后由操作系统的调度算法，选出某个任务，让CPU来执行。然后就是PC指针指向该任务的代码开始，由CPU开始取指令，然后执行。

这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了的进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。

串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载进程A的上下文，然后开始执行A，保存进程A的上下文，调入下一个要执行的进程B的进程上下文，然后开始执行B,保存进程B的上下文。。。。

========= 重要的东西出现了========
进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。

进程就是上下文切换之间的程序执行的部分。是运行中的程序的描述，也是对应于该段CPU执行时间的描述。
在软件编码方面，我们说的进程，其实是稍不同的，编程语言中创建的进程是一个无限loop，对应的是tcb块。这个是操作系统进行调度的单位。所以和上面的cpu执行时间段还是不同的。
进程，与之相关的东东有寻址空间，寄存器组，堆栈空间等。即不同的进程，这些东东都不同，从而能相互区别。
线程是什么呢？
进程的颗粒度太大，每次的执行都要进行进程上下文的切换。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：

程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。

这里a，b，c的执行是共享了A进程的上下文，CPU在执行的时候仅仅切换线程的上下文，而没有进行进程上下文切换的。进程的上下文切换的时间开销是远远大于线程上下文时间的开销。这样就让CPU的有效使用率得到提高。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。线程主要共享的是进程的地址空间。

到此全文结束，再一个总结：

进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。

注意这里描述的进程线程概念和实际代码中所说的进程线程是有区别的。编程语言中的定义方式仅仅是语言的实现方式，是对进程线程概念的物化。

我们先来做一个思维实验. 想象一下我们有一台最简单的计算机.

我们先完全不考虑什么操作系统什么虚拟内存, 就当这些东西完全不存在.

这台 "计算机" 的全部功能就是每秒钟神奇地从 "磁盘" 找到一条指令, 送入 "CPU" , 让 "CPU" 按顺序执行.

假设磁盘上有个程序A, 里面包含17条指令, 那么我们的计算机就需要17秒去完成这个程序. 而这17秒之内, 我们的计算机无法做别的事情. 这看起来很蠢不是么? 想象一下一台电脑无法边打字边听音乐.

所以我们要对计算机做出改进, 让他能够交替的执行程序A程序B程序C程序D.

再一次假设全知全能的我们完成了对计算机的改造, 现在我们的计算机可以做到同时执行多个程序.

还是那个拥有17条指令的程序A和一个拥有42条指令的程序B. 我们可以先执行一秒钟程序A, 再执行一秒钟程序B, 再执行一秒钟程序A. 看上去在同时执行两条程序似的.

那程序A对应的进程到底是什么? 是那17条指令? 是那17秒钟? 好像都不是.

进程A就是处理这17条指令的过程; 而进程B就是处理这42条指令的过程.

什么? 进程就是过程? process is process? 这说了和没说有什么区别?

没错, 很遗憾的说, 对于一个还未入门的人来说, 这就是最低程度的抽象了.

你看, 哪怕是最最简单的计算机, 我们依旧无法说清「进程到底是什么」.

因为进程这个概念本身就是抽象的.

关于「进程是什么」的回答在网络上到处都是, 而你却特地跑来知乎问, 说明你对那些文章都不满意, 你希望得到一个很漂亮的回答, 一个让人一眼看过去就茅塞顿开的回答. 实际上这是很难的. 就好比人们总是希望一句话就说清楚生活的意义是什么. 实际上也是很难的.

费曼在<The Feynman Lectures on Physics>里说过微观世界无论是对新手还是物理学家都是抽象的. 而我们的教科书却还是试图用行星绕着太阳这样的模型去描述电子绕着质子.

Things on a very small scale behave like nothing that you have any direct experience about. They do not behave like waves, they do not behave like particles, they do not behave like clouds, or billiard balls, or weights on springs, or like anything that you have ever seen. (...)
Because atomic behavior is so unlike ordinary experience, it is very difficult to get used to, and it appears peculiar and mysterious to everyone--both to the novice and the experienced physicist.
所以我到底想要表达什么呢?

大概就是: 
