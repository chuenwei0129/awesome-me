<!DOCTYPE html>
<html lang="en">

<body>
  <div id="app"></div>
  <button id="btn"> + </button>
  <button id="msg"> msg </button>

  <script>
    const el = document.querySelector('#app')

    const data = { num: 0, msg: 'hello world' }

    // 渲染页面，死数据
    // el.innerHTML = `<h1>${data.num}</h1>`

    let target

    function reactive(data) {
      for (let [k, v] of Object.entries(data)) {
        let dep = []
        if (typeof v === 'object' && v !== null) reactive(v)
        Object.defineProperty(data, k, {
          get() {
            // 取值只是把 watcher 添加到 dep 中
            // 发生取值操作就会把依赖值的函数传入 dep 中
            target && dep.push(target)
            return v
          },
          set(newV) {
            if (typeof newV === 'object' && newV !== null) reactive(newV)
            v = newV
            dep.forEach(watcher => watcher())
          }
        })
      }
      return data
    }

    // 响应式数据
    const vmData = reactive(data)

    const watcher = (fn) => {
      target = fn
      fn()
      target = null
    }

    // 期望响应式数据变化页面重新渲染，定义一个监控函数，数据一变化就执行页面重新渲染
    // 第一次 watcher 执行，fn依次执行，并且把 fn 都订阅到 dep 中
    watcher(() => {
      el.innerHTML = `<h1>${vmData.num}</h1>`
    })

    watcher(() => {
      console.log(`当前 msg 的值 ${vmData.msg}`)
    })

    watcher(() => {
      console.log(`当前 num 的值 ${vmData.num}`)
    })

    const btn = document.querySelector('#btn')

    // 用户点击 数据发生变化，fn 再次依次执行
    btn.addEventListener('click', () => {
      vmData.num++
    })

    const msg = document.querySelector('#msg')

    // 用户点击 数据发生变化，fn 再次依次执行
    msg.addEventListener('click', () => {
      // 非异步更新，每一次 set 都会执行 fn
      vmData.msg = '1'
      vmData.msg = '2'
      vmData.msg = '3'
      console.log(vmData);
      // 属于同一个 watcher 可以合并
      // 组件级更新，同一组件应该是同一watcher
    })

  </script>
</body>

</html>