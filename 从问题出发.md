![Alt text](https://pica.zhimg.com/v2-7c52c151a90f8fedc7516c0798b87067_r.jpg?source%253Dc8b7c179)

![Alt text](https://pic1.zhimg.com/v2-bf197471466a160f3c837810e78d836c_r.jpg?source%253Dc8b7c179)

https://zhuanlan.zhihu.com/p/643489789
https://zhuanlan.zhihu.com/p/641072335
https://zhuanlan.zhihu.com/p/624133891
https://zhuanlan.zhihu.com/p/623324430
https://zhuanlan.zhihu.com/p/608897758
https://zhuanlan.zhihu.com/p/544288732
https://zhuanlan.zhihu.com/p/529491295
https://zhuanlan.zhihu.com/p/528040023
https://zhuanlan.zhihu.com/p/505189023
https://zhuanlan.zhihu.com/p/479245926
https://zhuanlan.zhihu.com/p/474717897
https://zhuanlan.zhihu.com/p/464875327
https://zhuanlan.zhihu.com/p/440756446
https://zhuanlan.zhihu.com/p/433096562
https://zhuanlan.zhihu.com/p/383535347
https://zhuanlan.zhihu.com/p/382498133
https://zhuanlan.zhihu.com/p/382216973
symbol只能运行时唯一，人家要的是静态唯一，可传输的值
symbol在stringify的时候就失效了，补水这一步没办法做的


ErrorBoundary可以捕获子孙组件中「React工作流程」内的错误。「React工作流程」指：render阶段，即「组件render」、「Diff算法」发生的阶段 commit阶段，即「渲染DOM」、「componentDidMount/Update执行」的阶段 这也是为什么「事件回调中发生的错误」无法被ErrorBoundary捕获 —— 事件回调并不属于「React工作流程」。

作者：魔术师卡颂
链接：https://zhuanlan.zhihu.com/p/528040023
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：魔术师卡颂
链接：https://zhuanlan.zhihu.com/p/572429000
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

React性能确实不算太好，这是不争的事实。原因在于React自顶向下的更新机制。每次状态更新，React都会从根组件开始深度优先遍历整棵组件树。既然遍历方式是固定的，那么如何优化性能呢？答案是「寻找遍历时可以跳过的子树」。什么样的子树可以跳过遍历呢？显然是「没有发生变化的子树」。在React中，「变化」主要由下面3个要素造成：state props context 他们都可能改变UI，或者触发useEffect。所以，一棵子树中如果存在上述3个要素的改变，可能会发生变化，也就不能跳过遍历。从「变化」的角度，我们再来看看React中的性能优化API，对于下面2个：useMemo useCallback 他们的本质是 —— 减少props的变化。对于下面2个：PureComponent React.memo 他们的本质是 —— 让比较props的方式从「全等比较」变为「浅比较」。状态管理库能做的优化了解了React的性能优化，我们再来看看状态管理库能为「性能优化」做些什么呢。性能瓶颈主要发生在更新时，所以性能优化的方向主要有两个：减少不必要的更新 减少每次更新时要遍历的子树 像Redux语境下的useSelector走的就是第一条路。对于后一条路，「减少更新时遍历的子树」通常意味着「减少上文介绍的3要素的变化」。 PS：黄玄开发的React Forget，是一个「可以产生等效于useMemo、useCallback代码的编译器」，目的就是减少三要素中props的变化。 状态管理库在这方面能发挥的地方很有限，因为不管状态管理库如何巧妙的封装，也无法掩盖「他操作的其实是一个React状态」这一事实。比如，虽然Mobx为React带来了「细粒度更新」，但并不能带来与Vue中「细粒度更新」相匹配的性能，因为Mobx最终触发的是自顶向下的更新。

useMemo用来缓存变量props，useCallback用来缓存函数props。
-------------
这是什么说法啊？不应该说“useMemo 是用来缓存纯函数的计算结果，useCallback 是用来缓存函数引用”容易理解一点吗？

## 收集资料

- [React中得forwardRef作用是啥,仅仅是因为函数组件不能直接传递ref嘛？](https://www.zhihu.com/question/521311581)
- [useEffect监听了很多变量怎么办？](https://www.zhihu.com/question/483540101)
- https://www.zhihu.com/question/26646855/answer/2585077180
- Suspense https://www.zhihu.com/question/268028123/answer/2339074985
https://www.zhihu.com/question/434791954/answer/2484760705
