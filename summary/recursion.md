# 递归

**递归思想：**

> 递归跟效率没关系，是解决可计算性问题的，图灵可计算的问题都可以通过一些单步的操作加上递归完成，所以有递归就能表述出所有的程序，而且比图灵机程序更直观。至于效率那是实现时候的问题。
<!--  递归是构建现实世界的基本法则之一，递归实际上是对称性的一种体现。-->
> 可计算性理论又称递归论，它是编程的基本思想，不是因为它效率高，是因为它包罗万象。
<!--  编程是用来为现实世界建模的 -->
> **递归的思想就是这样，一个问题可以用 F 函数来代表，而 F 的工作是组合若干小问题的结果，这些小问题依然可以用 F 来表示，只是参数不同。**

**尾递归:**

> [尾递归为啥能优化？](https://zhuanlan.zhihu.com/p/36587160)

<!-- 1. 函数栈的目的是啥？是保持入口环境。

2. **正常递归才符合和人类思考方式，尾递归不是。**

没有任何一个数学算法会给你写「尾递归」，数学归纳是「递归」不是「尾递归」，这个能明白吗？

「递归」（不是尾递归）之所以能写出比循环可读性高的代码是因为递归隐含了一个栈，而用循环实现的时候需要手动维护一个栈导致代码丑且长，但是尾递归恰好就是那个不需要这个栈的特殊情况（我文章里面有说明），也就是说这个时候递归相对于循环完全没有任何优势了。对于无栈循环不能等效的递归函数，转化成尾递归比转化成有栈循环更丑更难看并且还更慢。 -->

<!-- 尾递归的参数只需要入栈和出栈各一次，整个递归过程只需要修改栈里的参数，“调用自身”直接使用jmp，而不是call和ret。而普通递归，到达递归出口前要将参数（和IP寄存器的值）不断入栈，这就可能爆栈了 -->

<!-- 常规的快排肯定不能被尾递归优化的。举个例子 func A() { return A() } 这就是尾递归，如果是 func A() { return A() + A() } 这就不是尾递归，包括 func { return B(A()) } 也不是。只有 return 直接接这个函数调用才是尾递归，才能被尾递归优化。

斐波那契哪个递归不是尾递归，return sefl() 是尾递归，因为递归的是 self()函数。return self() + self() 不是尾递归，等效于 return add(self(), self())，递归的是 add() 不是 self()

尾递归都不能generalize（泛化）成尾调

当年看完尾递归优化之后发现一个很好玩的事情，能尾递归优化的地方说明可以改写成循环，循环都没有的框架才提供尾递归优化编译，说起来就是……
一般情况没撒事。

所有递归都能等效于循环＋栈

我是在清华大学邓俊辉老师的一本书上看到说：二叉树先序遍历 递归版本，其中针对右子树的遍历属于尾递归，所以产生了这个疑惑。。。他的说法是不是有问题？

他说的没问题，划关键词「二叉树右子树遍历」，不是「二叉树遍历」。递归遍历右子树等效于于遍历二叉树最右边一条变组成的链表，等效于一个数组循环。 -->

**递归转循环:**

> [通用的递归转循环方法](https://zhuanlan.zhihu.com/p/136511316)

**扩展阅读：**

- [递归思想为什么是编程的基本思想，它效率很高吗？](https://www.zhihu.com/question/271081962)
- [重新发明 Y 组合子 JavaScript 版](http://picasso250.github.io/2015/03/31/reinvent-y.html)
