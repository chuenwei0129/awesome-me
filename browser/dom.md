# 文档对象模型 (DOM)

## 前置知识

### [为什么 Window 属于 DOM 接口？难道说 Window 属于 DOM?](https://www.zhihu.com/question/345622144)

### [ECMAScript中的对象和 DOM 对象是一个概念么？](https://www.zhihu.com/question/67501711)

是一个概念。

DOM 和 BOM 并不属于 JavaScript（ECMAScript ） 语言的一部分。DOM 和 BOM 是 JavaScript 的运行平台（浏览器）提供的，比如在 nodejs 中就没有 DOM 和 BOM。

JavaScript 类型分为 2 大类：原生类型和对象类型。而 DOM 和 BOM 都是对象类型。

所有的 DOM 和 BOM 没有任何特殊之处，都是一个 Object 的子类。


## 前端为什么操作 DOM 是最耗性能的呢？

<!-- 其一，浏览器的 JavaScript 引擎与 DOM 引擎共享一个主线程。任何 DOM API 调用都要先将 JS 数据结构转为 DOM 数据结构，再挂起 JS 引擎并启动 DOM 引擎，执行过后再把可能的返回值反转数据结构，重启 JS 引擎继续执行。这种上下文切换很耗性能，类似的还有单机进程间调用、远程过程调用等。

其二，很多 DOM API 的读写都涉及页面布局的“重新计算”，以确保返回值的准确，涉及样式、结构的还会触发页面“重新绘制”，更耗性能。

综上，单次 DOM API 调用性能就不够好，频繁调用就会迅速积累上述损耗，导致 DOM 引擎占用主线程过久，用户操作不能及时触发 JS 事件回调，让用户感觉卡顿。

所以，解决此问题的方案本质不在于用不用 jQuery、用不用虚拟 DOM，而是 —— 减少不必要的 DOM API 调用。虚拟 DOM 只是一种可选的方案，不是每种 Web 前端框架都用它。

而减少不必要调用的各种方案，都遵循“在 JS 中缓存必要数据，计算界面更新时的阶段数据差异，只提交最终差集”的基本思路。虚拟 DOM 计算的是最终 DOM 结构的差异，还有的引擎计算的是 DOM 所绑定数据的差异，各有千秋。



总结：你可以把浏览器里所有非 JavaScirpt 内置类型的对象都称之为 DOM 对象，其它人就懂了。

所以 MDN 里干脆把浏览器里所有非 JavaScript 自带的 API 都称之为 Web API (https://developer.mozilla.org/en-US/docs/Web/API)，而不用 DOM API 这样的术语，就像 Node 里提供的 API 都叫 Node API 一样。
直接把一个dom对象当作js对象那样读写非api属性，会像dom一样慢，还是像操作普通js对象一样快呢？
因为 JS 访问的 DOM 对象实际上是 DOM 引擎中的对象在 JS 引擎的包装对象，理论上访问其非 API 属性应该和 JS 对象一样快。

但不同的引擎实现不同，就像当年 IE DOM 对象内存泄露的坑一样，劝你不要拿 DOM 当 JS 对象用。
打开网页时，浏览器先解析 HTML，遇到 script 标签再交给 JS 引擎，此时 DOM 渲染被阻塞，遇到 DOM 操作再切换回来，如此反复
react 的新算法并不是为了更快，而是为了更流畅。举个例子，有一个耗时任务，和一个进度条。一种是任务完成需要60秒，进度条显示1%，然后直接跳到100%；另一种是任务完成需要70秒，但是进度条会一直步进。我们可以说第一种是“快”，而第二种是“流畅”。

就是浏览器它的js和dom是共用一个线程。操作dom的时候，要先把js转成dom的数据结构，然后再切换到dom引擎，然后再把结果返回来再启动js引擎，这就叫上下文切换，这操作很耗性能的。

因为 JavaScript 操作 DOM 会改动 DOM 树，DOM 树发生变化就会触发渲染引擎工作。这背后不仅仅是 JS 操作了 DOM，还有对 DOM 树进行分析、渲染等操作。我们知道 JS 改动了 DOM，也看到了网页发生了变化，但却看不到这中间的细微过程。我用 Chromium 源码举例说明： -->

## DOM API


