<!-- # [专有钉钉前端面试指南](https://juejin.cn/post/6986436944913924103?utm_source=gold_browser_extension#heading-16) -->
<!-- no, it means I have the memory of a human being -->
<!-- 一个问题不好解决时，计算机科学家会选择在上面套一层 -->
<!-- 为什么 Java 和 JS 等语言需要 VM，不能直接操作内存堆栈空间？ -->

# 知识图谱<!-- omit in toc -->

- [基础](#基础)
  - [什么是解释型语言？](#什么是解释型语言)
  - [V8 是如何执行 JavaScript 代码的？](#v8-是如何执行-javascript-代码的)
    - [`Parser` 生成抽象语法树](#parser-生成抽象语法树)
    - [解释器(Ignition)如何将 `AST` 翻译为字节码并执行？](#解释器ignition如何将-ast-翻译为字节码并执行)
    - [执行代码及优化](#执行代码及优化)
      - [內联算法](#內联算法)
      - [逃逸分析](#逃逸分析)
    - [JIT 编译](#jit-编译)
    - [那么变量提升呢?](#那么变量提升呢)
    - [总结](#总结)
  - [`Babel` 的编译过程？](#babel-的编译过程)
  - [`JavaScript` 中的数组在内存中是如何存储的？](#javascript-中的数组在内存中是如何存储的)
    - [什么是数组](#什么是数组)
    - [JavaScript 中的数组](#javascript-中的数组)
    - [从 V8 源码上看数组的实现](#从-v8-源码上看数组的实现)
      - [快数组（Fast Elements）](#快数组fast-elements)
      - [慢数组（Dictionary Elements）](#慢数组dictionary-elements)
      - [快数组慢数组之间的转换](#快数组慢数组之间的转换)
      - [各有优劣](#各有优劣)
    - [扩展：ArrayBuffer](#扩展arraybuffer)
  - [浏览器和 `Node` 中的事件循环机制有什么区别？](#浏览器和-node-中的事件循环机制有什么区别)
  - [`ES6 Modules` 相对于 `CommonJS` 的优势是什么？](#es6-modules-相对于-commonjs-的优势是什么)
  - [什么是沙箱？浏览器的沙箱有什么作用？](#什么是沙箱浏览器的沙箱有什么作用)
  - [发布 / 订阅模式和观察者模式的区别是什么？](#发布--订阅模式和观察者模式的区别是什么)
  - [装饰器模式一般会在什么场合使用？](#装饰器模式一般会在什么场合使用)
  - [什么是函数式编程？什么是响应式编程？什么是函数响应式编程？](#什么是函数式编程什么是响应式编程什么是函数响应式编程)
- [语法](#语法)
- [框架](#框架)
- [工程](#工程)
- [网络](#网络)
- [性能](#性能)
- [插件](#插件)
- [系统](#系统)
- [后端](#后端)

## 基础

### 什么是解释型语言？

语言是用来写代码的，代码是给人看的。

计算机只看得懂程序（`01010101`），看不懂代码。

把代码变成程序有两个常用的方法：

1. 把所有的代码变成程序，再执行。
   **即，先编译再执行**。
2. 把一丢丢代码变成一丢丢程序执行，然后再把一丢丢代码变成一丢丢程序执行，...。
   **即，边解释边执行**。

谁来编译？谁来解释？谁来执行？

- **编译型**：编译器来编译，系统执行。
- **解释型**：解释器解释并执行。

举个例子 🌰：

你女网友只懂中文（源代码），你只懂英文（机器码/CPU 指令），现在你俩要搞对象，怎么办？

女网友写下了自己的：`要求.py`:

```py
二号男嘉宾
我要吃好的
我要穿好的
我要住好的
我不会做饭
我不会家务
我脾气不好
```

由于你们语言不通，直接是无法交流的，所以必须要有一个翻译官（python 解释器）

1. `python` 解释器的执行流程：

```py
二号男嘉宾 => SLOT #2
我要吃好的 => FOOD +10W
我要穿好的 => DRESS + 10W
我要住好的 => HOUSE + 100W
我不会做饭 => ELEME + 7W
我不会家务 => BABYSITTER + 3W
我脾气不好 => PSYCHOLOGIST + 10W
```

翻译官将中文翻译成了你能懂的英文（CPU 指令），这是你的执行流程：

```py
SLOT #2 => ACK
FOOD +10W => +10W
DRESS + 10W => +10W
HOUSE + 100W => +100W
ELEME + 7W => +7W
BABYSITTER + 3W => +3W
PSYCHOLOGIST + 10W => +10W
```

**每接到一次指令，你就去 `ATM` 取一次钱，一共需要取 `6` 次钱；**

然后你将继续等待对方开出的条件，进入 `Idle` 状态，直到翻译将新的指令给你，直到条件开完毕，而你又能一直从 `ATM` 里面取出钱来，然后你们就幸福的在一起了。

2. `JIT` 优化。

你应该看出来了，`Python` 解释器（翻译官）每次传递一行指令，但要求其实都差不多，所以 `JIT` 这时候就派上用场了，**第一次的过程其实是一样的**，但是你的女网友发现你没有回复她的时候，又说了一遍，还说了第三遍，这个时候如果有 `JIT`（比如 `Pypy`），那么从第二次开始，翻译官给你的就不再是一行一行的指令了，而是：

```py
+10W + 10W + 100W + 7W + 3W + 10W
```

**这时候，你只需要去一次 `ATM`，一次性取出需要的这些钱，你们就能幸福的在一起了。**

3. 什么是跨平台呢？

跨平台其实就是 `CPU` 的指令集不太一样，你让懂 `ARM` 的翻译官来翻译给 `Power 7` 听，无论如何都听不懂的，比如你去 `ATM` 里面取钱这个指令翻译成不同 `CPU` 指令就是不一样的：

- `x86`：神昏证，应喊卡，本人，余额足够
- `power7`： 爹，我，钱，`140W`
- `A11`： 秦始皇，封侯，打钱
- `ARM`：果照，`30%` 利率，无敌呀饭款，`30` 秒到站

只要有对应的解释器，你总是能取到钱

4. 顺提一下编译型：

就是翻译官（此处应该叫编译官）把 **你女网友的** `要求.py` 直接重新找了一张 `A4` 纸，上面写着：

```py
$$
```

这样每次你女网友拿着这张纸到`x86`窗口的`ATM`直接就能办理了，**注意，仅此窗口，别家店不可以用的**，咦，好像少了什么人？也是，如果都能直接跟`ATM`沟通了，谁还需要男盆友呢？

5. 性能

因为解释型语言在编译的时候只是编译成了字节码，运行的时候，还需要解释器挨个把字节码翻译成机器语言才能执行。

相当于你写的程序，每次都要先“编译”，再运行，运行速度必然比只需要运行不需要编译的编译型语言慢。

`JavaScript` 是一种动态类型语言，在编译时并不能准确知道变量的类型，只可以在运行时确定，这就不像 `c++`或者 `java` 等静态类型语言，在编译时候就可以确切知道变量的类型。然而，在运行时计算和决定类型，会严重影响语言性能，这也就是 `JavaScript` 运行效率比 `C++`或者 `JAVA` 低很多的原因之一。

> 例子来源：[什么是解释型语言？](https://www.zhihu.com/question/268303059)

### V8 是如何执行 JavaScript 代码的？

`V8` 执行 `JS` 代码的整体流程如下图所示：

![](Images/v8_03.png)

在这个过程中，`V8` 同时使用了 `Parser`（解析器）、`Ignition`（解释器） 和 `TurboFan`（编译器） 来执行 `JS` 代码

#### `Parser` 生成抽象语法树

在 `Chrome` 中开始下载 `Javascript` 文件后，`Parser` 就会**开始并行在单独的线程上解析代码**。这意味着解析可以在下载完成后仅几毫秒内完成，并生成 `AST`。

> TIPS：解析过程中，对于不是立即执行的函数，只进行预解析（Pre Parser）只有当函数调用时才对函数进行全量解析。

![](Images/v8_11.png)

此外，`AST` 还广泛应用于各类项目中，比如 `Babel`、`ESLint`，那么 `AST` 的生成过程是怎么样的呢？

1. **词法分析**（lexical analysis）：主要是将字符流（`char stream`） 转换成标记流（`token stream`），字符流就是我们一行一行的代码，`token` 是指语法上不能再分的、最小的单个字符或者字符串。

![](Images/v8_12.jpg)

```js
var name = 'ivweb'[
  //转成token后为

  ({
    type: 'Keyword',
    value: 'var'
  },
  {
    type: 'Identifier',
    value: 'name'
  },
  {
    type: 'Punctuator',
    value: '='
  },
  {
    type: 'String',
    value: '"ivweb"'
  },
  {
    type: 'Punctuator',
    value: ';'
  })
]
```

从上面可以看出，`var name = "ivweb";` 这样一段代码，会有关键字 `"var"`、标识符 `"name"`、赋值运算符 `"="`、字符串 `"ivweb"`、分隔符 `";"`，共 `5` 个 `token`。

2. **语法分析**：将前面生成的 `token` 流根据语法规则，形成一个有元素层级嵌套的语法规则树，这个树就是 `AST`。在此过程中，如果源代码不符合语法规则，则会终止，并抛出“语法错误”。

#### 解释器(Ignition)如何将 `AST` 翻译为字节码并执行？

> 字节码是机器码的抽象，可以看作是小型的构建块，这些构建块组合到一起构成任何 `JavaScript` 功能。

> 字节码比机器码占用更小的内存，这也是为什么 `V8` 使用字节码的一个很重要的原因。

> 字节码不能够直接在处理器上运行，需要通过解释器将其转换为机器码后才能执行。

![](Images/v8_04.png)

举个例子 🌰：

![](Images/v8_10.png)

#### 执行代码及优化

##### 內联算法

![](Images/v8_05.png)

![](Images/v8_06.png)

![](Images/v8_07.png)

![](Images/v8_08.png)

通过內联可以降低复杂度、消除冗余代码、合并常量，內联技术通常也是逃逸分析的基础。

##### 逃逸分析

> 分析对象的生命周期是否仅限于当前函数

![](Images/v8_09.png)

逃逸分析的好处是，直接将变量加载到寄存器上，不再需要从内存中访问对象属性，还减少了内存占用。

#### JIT 编译

![](Images/v8_02.jpg)

`Ignition` 执行上一步生成的字节码，并记录代码运行的次数等信息，如果同一段代码执行了很多次，就会被标记为 `“HotSpot”`（热点代码）。

然后把这段代码发送给编译器 `TurboFan`，然后 `TurboFan` 把它编译为更高效的机器码储存起来，等到下次再执行到这段代码时，就会用现在的机器码替换原来的字节码进行执行，这样大大提升了代码的执行效率。

另外，当 `TurboFan` 判断一段代码不再为热点代码的时候，会执行去优化的过程，把优化的机器码丢掉，然后执行过程回到 `Ignition`。

#### 那么变量提升呢?

下面是 `JavaScript` 处理声明语句的过程：

1. 一旦 `V8` 引擎进入一个执行具体代码的执行上下文（函数），它就对代码进行词法分析或者分词。这意味着代码将被分割成像`foo = 10`这样的原子符号（atomic token）。

2. 在对当前的整个作用域分析完成后，引擎将 `token` 解析翻译成一个`AST`（抽象语法树）。
   引擎每次遇到声明语句，就会把声明传到作用域（scope）中创建一个绑定。每次声明都会为变量分配内存。只是分配内存，并不会修改源代码将变量声明语句提升。正如你所知道的，在`JS`中分配内存意味着将变量默认设为`undefined`。

3. 在这之后，引擎每一次遇到赋值或者取值，都会通过作用域（scope）查找绑定。如果在当前作用域中没有查找到就接着向上级作用域查找直到找到为止。

4. 接着引擎生成 `CPU` 可以执行的机器码。
   最后，代码执行完毕。

所以变量提升不过是执行上下文的小把戏。在执行任何语句之前，解释器就要从创建执行上下文后已经存在的作用域（scope）中找到变量的值。

#### 总结

那么结合上面对于 `V8` 引擎的介绍，我们在编程中应注意：

- **类型**。对于函数，`JavaScript` 是一种动态类型语言，`JavaScriptCore` 和 `V8` 都使用隐藏类和内嵌缓存来提高性能，为了保证缓存命中率，**一个函数应该使用较少的数据类型**；对于数组，应尽量存放相同类型的数据，这样就可以通过偏移位置来访问。
- **数据表示**。简单类型数据（如整型）直接保存在句柄中，可以减少寻址时间和内存占用，如果可以使用整数表示的，尽量不要用浮点类型。
- **内存**。虽然 `JavaScript` 语言会自己进行垃圾回收，但我们也应尽量做到及时回收不用的内存，对不再使用的对象设置为 `null` 或使用 `delete` 方法来删除(使用 `delete` 方法删除会触发隐藏类新建，需要更多的额外操作)。
- **优化回滚**。在执行多次之后，不要出现修改对象类型的语句，尽量不要触发优化回滚，否则会大幅度降低代码的性能。
- **新机制**。使用 `JavaScript` 引擎或者渲染引擎提供的新机制和新接口提高性能。

知识拓展：[认识 V8 引擎](https://zhuanlan.zhihu.com/p/27628685)

### `Babel` 的编译过程？

### `JavaScript` 中的数组在内存中是如何存储的？

#### 什么是数组

> 数据结构中定义的数组是定长的、数据类型一致的存储结构。

看完数据结构中的定义，再来看下具体语言中对数组的实现：`C、C++、Java、Scala` 等语言中数组的实现，是通过在内存中划分一串连续的、固定长度的空间，来实现存放一组有限个相同数据类型的数据结构。这里面也涉及到了几个重要的概念：**连续**、**固定长度**、**相同数据类型**，与数据结构中的定义是类似的。

1. **连续**

   连续空间存储是数组的特点。各元素在内存中是相邻的，是一种线性的存储结构。

2. **固定长度**

   因为数组的空间是连续的，这就意味着在内存中会有一整块空间来存放数组，如果不是固定长度，那么内存中位于数组之后的区域会没办法分配，内存不知道数组还要不要继续存放，要使用多长的空间。长度固定，就界定了数组使用内存的界限，数组之外的空间可以分配给别人使用。

3. **相同数据类型**

   因为数组的长度是固定的，如果不是相同数据类型，一会存一个 `int` ，一会存一个 `String` ，两种不同长度的数据类型，不能保证各自存放几个，这样有悖固定长度的规定，所以也要是相同的数据类型。

那我们再来看 `JavaScript` 中的数组。

#### JavaScript 中的数组

> `JS` 的数组不是基础的数据结构（数组）实现的，而是在基础上面做了一些封装。

- `JS` 数组中不止可以存放上面的三种数据类型，它可以存放数组、对象、函数、`Number`、`Undefined`、`Null`、`String`、`Boolean` 等等。

- `JS` 的数组可以表现的像栈一样，为数组提供了 `push()`和 `pop()`方法。也可以表现的像队列一样，使用 `shift()`和 `push()`方法，可以像使用队列一样使用数组。

#### 从 V8 源码上看数组的实现

![](Images/array_02.png)

从注释上可以看出，`JS` 数组有两种表现形式，`fast` 和 `slow`

- **fast** ：

快速的后备存储结构是 `FixedArray` ，并且 `数组长度 <= elements.length()`

> `FixedArray` 是 `V8` 实现的一个类似于数组的类，它表示一段固定长度的连续的内存。

- **slow** ：

缓慢的后备存储结构是一个以数字为键的 `HashTable` 。

> `HashTable`，维基百科中解释的很好：

> 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

##### 快数组（Fast Elements）

> TIPS: JS 数组中的数据类型不一样的话，不一定不是快数组

快数组是一种线性的存储方式。

**新创建的空数组，默认的存储方式是快数组，快数组长度是可变的**，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，那来看下源码中是怎么扩容和收缩的。

1. 扩容

```js
new_capacity = old_capacity / 2 + old_capacity + 16
```

也就是，扩容后的新容量 = 旧容量的 `1.5` 倍 + `16`

扩容后会将数组拷贝到新的内存空间中

2. 收缩

收缩数组的判断是：如果`容量 >= length 的 2 倍 + 16`，则进行收缩容量调整，否则用 `holes` 对象（什么事 `holes` 对象？下面来解释）填充未被初始化的位置。

```c
int elements_to_trim = length + 1 == old_length ? (capacity -length) / 2 : capacity -length
```

这个 `elements_to_trim` 就是需要收缩的大小，需要根据 `length + 1` 和 `old_length` 进行判断，是将空出的空间全部收缩掉还是只收缩二分之一

3. `holes`（空洞）对象

`holes`（空洞）对象指的是数组中分配了空间，但是没有存放元素的位置。

对于 `holes`，快数组中有个专门的模式，在 `Fast Elements` 模式中有一个扩展，是 `Fast Holey Elements` 模式。
`Fast Holey Elements` 模式适合于数组中的 `holes`（空洞）情况，即只有某些索引存有数据，而其他的索引都没有赋值的情况。

那什么时候会是 `Fast Holey Elements` 模式呢？

当数组中有空洞，没有赋值的数组索引将会存储一个特殊的值，这样在访问这些位置时就可以得到 `undefined`。这种情况下就会是 `Fast Holey Elements` 模式。
`Fast Holey Elements` 模式与 `Fast Elements` 模式一样，会动态分配连续的存储空间，分配空间的大小由最大的索引值决定。

**新建数组时，如果没有设置容量**，`V8` 会默认使用 `Fast Elements` 模式实现。比如 `let a = new Array(1,2,3);`，这种就不存在空洞，就是以 `Fast Elements` 模式实现

如果要对数组设置容量，但并没有进行内部元素的初始化，例如 `let a = new Array(10);`，这样的话数组内部就存在了空洞，就会以 `Fast Holey Elements` 模式实现。

##### 慢数组（Dictionary Elements）

慢数组是一种哈希表的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 `HashTable`，其效率会比快数组低。

那既然有快数组和慢数组，总不能存储结构一成不变吧，也该有具体情况下的快慢数组转换，下面来看一下什么情况下会发生转换

##### 快数组慢数组之间的转换

**快 -> 慢**

- `新容量 >= 3 * 扩容后的容量 * 2` ，会转变为慢数组。

- 当加入的 `index- 当前 capacity >= kMaxGap（1024` 时（也就是至少有了 `1024` 个空洞），会转变为慢数组。

也就是说，当对数组赋值时使用远超`当前数组的容量+ 1024` 时（这样出现了大于等于 `1024` 个空洞，这时候要对数组分配大量空间则将可能造成存储空间的浪费，为了空间的优化，会转化为慢数组。

```js
let a = [1, 2]
a[1030] = 1
```

数组中只有三个元素，但是却在 `1030` 的位置存放了一个值，那么中间会有多于 `1024` 个空洞，这时就会变为慢数组

**慢 -> 快**

处于哈希表实现的数组，在每次空间增长时， `V8` 的启发式算法会检查其空间占用量， 若其空洞元素减少到一定程度，则会将其转化为快数组模式。

当慢数组的元素可存放在快数组中且长度在 `smi` 之间且仅节省了 `50%` 的空间,则会转变为快数组

![](Images/array_03.png)

```js
let a = [1, 2]
a[1030] = 1
for (let i = 200; i < 1030; i++) {
  a[i] = i
}
```

在 `1030` 的位置上面添加一个值，会造成多于 `1024` 个空洞，数组会使用为 `Dictionary` 模式来实现。

那么我们现在往这个数组中再添加几个值来填补空洞，往 `200-1029` 这些位置上赋值，使慢数组不再比快数组节省 `50%` 的空间，数组变成了快数组的 `Fast Holey Elements` 模式。

##### 各有优劣

快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。 慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。

来源：[探究 JS V8 引擎下的“数组”底层实现](https://juejin.cn/post/6844903943638794248)

#### 扩展：ArrayBuffer

`JS` 在 `ES6` 也推出了可以按照需要分配连续内存的数组，这就是 `ArrayBuffer`。

`ArrayBuffer` 会从内存中申请设定的二进制大小的空间，但是并不能直接操作它，需要通过 `ArrayBuffer` 构建一个视图，通过视图来操作这个内存。

```js
var bf = new ArrayBuffer(1024)
```

这行代码就申请了 `1kb` 的内存区域。但是并不能对 `arrayBuffer` 直接操作，需要将它赋给一个视图来操作内存。

```js
var b = new Int32Array(bf)
```

这行代码创建了有符号的 `32` 位的整数数组，每个数占 `4` 字节，长度也就是 `1024 / 4 = 256` 个。

### 浏览器和 `Node` 中的事件循环机制有什么区别？

### `ES6 Modules` 相对于 `CommonJS` 的优势是什么？

### 什么是沙箱？浏览器的沙箱有什么作用？

### 发布 / 订阅模式和观察者模式的区别是什么？

### 装饰器模式一般会在什么场合使用？

### 什么是函数式编程？什么是响应式编程？什么是函数响应式编程？

## 语法

## 框架

## 工程

## 网络

## 性能

## 插件

## 系统

## 后端
