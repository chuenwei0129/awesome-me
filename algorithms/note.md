# 我接触过的前端数据结构与算法

## 双指针

**前置知识：**[算法一招鲜——双指针问题](https://zhuanlan.zhihu.com/p/71643340)

**刷题：**

- **对撞指针：**[LeetCode 881](https://leetcode.cn/problems/boats-to-save-people/)

子串/子数组/子序列

例如：长度最小的子数组

滑动窗使用思路（寻找最长）

——核心：左右双指针(L，R)在起始点，R向右逐位滑动循环

—每次滑动过程中

如果：窗内元素满足条件，R向右扩大窗口，井更新最优结果如果：窗内元素不满足条件，L向右缩小窗口

—R到达结尾

滑动窗使用思路（寻找最短）

——核心：左右双指针(L，R)在起始点，R向右逐位滑动循环

—每次滑动过程中

如果：窗内元素满足条件，L向右缩小窗口，井更新最优结果如果：窗内元素不满足条件，R向右扩大窗口

——R到达结尾

## 前端相关

### 递归

## 基础知识



### 数组

常见语言的数组不能存放不同的数据类型，因此所有在封装时通常存放在数组中的是Objec类型

常见语言的数组容量不会自动改变。（需要进行扩容操作）

常见语言的数组进行中间插入和删除操作性能比较低.

数组的创建通常需要申请一段连续的内存空间(—整块的内存)，并且大小是固定的(大多数编程语言数组都是固定的)，所以当当前数组不能满足容量需求时，需要扩容．（一般情况下是申请一个更大的数组，比如2倍.然后将原数组中的元素复制过去）

而且在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移

尽管我们已经学过的JavaScript的Array类方法可以帮我们做这些事，但背后的原理依然是这样。

<!-- 查找 -->

### 链表

內存空间不是必须连续的，可以充分利用计算机的内存、实现灵活的内存动态管理.

链表不必在创建时就确定大小，并且大小可以无限的延伸下去.

链表在插入和删除数据时，时间复杂度可以达到O(1），相对数组效率高很多、

要存储多个元素，另外一个选择就是链表.

但不同于数组，链表中的元素在内存中不必是连续的空间.

链表的每个元素由一个存储元素本身的节点和—个指向下一个元素的引|用(有些语言称为指针或者连接)组成.

相对于数组，链表有一些优点：

口内存空间不是必须连续的．可以充分利用计算机的内存.实现灵活的内存动态管理.

口链表不必在创建时就确定大小，并且大小可以无限的延伸下去.

口链表在插入和删除数据时，时间复杂度可以达到O(1）.相对数组效率高很多.

相对于数组，链表有一些缺点：

口链表访问任何一个位置的元素时，都需要从头开始访问(无法跳过第一个元素访问任何一个元素） 口无法通过下标直接访问元素，需要从头一个个访问，直到找到对应的元素.

### 双向链表

### 队列

我们知道数组是一种线性结构，并且可以在数组的任意位置插入和删除数据.

但是有时候，我们为了实现某些功能，必须对这种任意性加以限制.

而栈和队列就是比较常见的受限的线性结构，我们先来学习栈结构.

我们知道，普通的队列插入一个元素，数据会被放在后端.并且需要前面所有的元素都处理完成后才会处理前面的数据.

但是优先级队列，在插入一个元素的时候会考虑该数据的优先级.

和其他数据优先级进行比较.

比较完成后，可以得出这个元素在队列中正确的位置.

其他处理方式，和基本队列的处理方式一样.

### 栈

我们己经学习了一种受限的线性结构：栈结构.

并且已经知道这种受限的数据结构对于解决某些特定问题，会有特别的效果.

下面，我们再来学习另外一个受限的数据结构：队列.

### 哈希表

空间利用率不高，底层使用的是数组，并且某些单元是没有被利用的！

哈希表中的元素是无序的，不能按照固定的顺序来遍历哈希表中的元素.

不能快速的找出哈希表中的最大值或者最小值这些特殊的值.

### 堆

### 优先队列

### 字典树

### 树

1.节点的度(Degree）：节点的子树个数.
2.树的度：树的所有节点中最大的度数.
3.叶节点（Leaf）：度为0的节点.（也称为叶子节点）
4.父节点(Parent）：有子树的节点是其子树的根节点的父节点
5.子节点(Child）：若A节点是B节点的父节点，则称B节点是A节点的子节点；子节点也称孩子节点。
6.兄弟节点（Sibling)：具有同一父节点的各节点彼此是兄弟节点。
7.路径和路径长度：从节点n1到nk的路径为一个节点序列n1，n2…,nk, ni是 ni+1的父节点。路径所包含边的个数为路径的长度。
8.节点的层次（Level）：规定根节点在1层，其它任一节点的层数是其父节点的层数加1。
9.树的深度（Depth）：树中所有节点中的最大层次是这棵树的深度。

其实所有的树本质上都可以使用二叉树模拟出来.

所以在学习树的过程中，二叉树非常重要.

一个二叉树第i层的最大节点数为：2^（1-1,i>= 1；

深度为k的二又树有最大节点总数为：2^k-1,k >= 1;

对任何非空二叉树「，若n0表示叶节点的个数、n2是度为2的非叶节点个数，那么两者满足关系n0= n2 + 1.

完美二叉树(Perfect Binary Tree)，也称为满二叉树(Full Binary Tree) 口在二叉树中，除了最下一层的叶节点外，每层节点都有2个子节点，就构成了满二叉树.

完全二叉树(Complete Binary Tree)

口除二叉树最后一层外，其他各层的节点数都达到最大个数.

口且最后—层从左向右的叶节点连续存在，只缺右侧若干节点.

口完美二叉树是特殊的完全二叉树.

下面不是完全二叉树，因为D节点还没有右节点，但是E节点就有了左右节点.

二叉树的存储常见的方式是数组和链表.

<!-- bst -->
二叉搜索树是一颗二叉树，可以为空；

如果不为空，满足以下性质

非空左子树的所有键值小于其根节点的键值。

非空右子树的所有键值大于其根节点的键值。

口左、右子树本身也都是二叉搜索树。

v2 与hooks区别，面向对象与fp区别，组合，原子css，继承，把方法从 class中抽出来，class出现是为了分类约束，而鸭子类型才是世界的本原，我们不应该本能的归类，分类只有上帝才能做到，依赖注入是把功用方法抽象除去在注入到类中，本质也是他妈的组合

世界是具体的，不是抽象的，二极管，面向对象，向上抽象

链表无序

递归遍历

render 就是存的
ref就相当于违背了存函数，也就是不存了

### 图

> https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md

