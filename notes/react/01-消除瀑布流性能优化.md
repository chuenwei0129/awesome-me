# 消除瀑布流性能优化

## 概述

瀑布流（Waterfall）是指多个异步操作串行执行，每个操作必须等待前一个操作完成后才能开始。消除瀑布流是 React 和 Next.js 性能优化中**最关键**的优化方向之一，可以实现 **2-10 倍**的性能提升。

## 目录

1. [延迟 await 直到真正需要](#1-延迟-await-直到真正需要)
2. [使用 Promise.all() 并行执行独立操作](#2-使用-promiseall-并行执行独立操作)
3. [基于依赖的并行化](#3-基于依赖的并行化)
4. [防止 API 路由中的瀑布链](#4-防止-api-路由中的瀑布链)
5. [策略性使用 Suspense 边界](#5-策略性使用-suspense-边界)

---

## 1. 延迟 await 直到真正需要

### 问题

当一个异步操作在某些分支中不需要时，如果在所有分支之前就 await，会造成不必要的等待。

### 错误示例

```typescript
async function handleRequest(userId: string, skipProcessing: boolean) {
  // 问题：无论哪个分支，都会等待 userData 加载完成
  const userData = await fetchUserData(userId)

  if (skipProcessing) {
    // 这个分支不使用 userData，但仍然等待了它
    return { skipped: true }
  }

  // 只有这个分支才使用 userData
  return processUserData(userData)
}
```

### 正确示例

```typescript
async function handleRequest(userId: string, skipProcessing: boolean) {
  // 优化：先判断分支，只在实际需要时才 await
  if (skipProcessing) {
    return { skipped: true }
  }

  const userData = await fetchUserData(userId)
  return processUserData(userData)
}
```

### 为什么重要

- 避免阻塞不需要该数据的代码路径
- 提高响应速度，特别是当跳过的分支经常被执行时
- 对于延迟操作比较昂贵的情况，这个优化特别有价值

---

## 2. 使用 Promise.all() 并行执行独立操作

### 问题

当多个异步操作之间没有依赖关系时，串行执行会造成严重的性能损失。

### 错误示例

```typescript
// 问题：3 次串行网络往返
const user = await fetchUser()
const posts = await fetchPosts()
const comments = await fetchComments()

// 总时间 = fetchUser + fetchPosts + fetchComments
```

### 正确示例

```typescript
// 优化：并行执行，1 次网络往返
const [user, posts, comments] = await Promise.all([
  fetchUser(),
  fetchPosts(),
  fetchComments()
])

// 总时间 = max(fetchUser, fetchPosts, fetchComments)
```

### 为什么重要

- **CRITICAL 级别**优化
- 可实现 **2-10 倍**性能提升
- 当操作之间没有依赖关系时，应该并发执行

### 实际场景

```typescript
// 场景：加载页面数据
async function loadDashboard() {
  // 错误方式：串行加载
  const stats = await fetchStats()
  const notifications = await fetchNotifications()
  const userSettings = await fetchUserSettings()

  // 正确方式：并行加载
  const [stats2, notifications2, userSettings2] = await Promise.all([
    fetchStats(),
    fetchNotifications(),
    fetchUserSettings()
  ])

  return { stats: stats2, notifications: notifications2, settings: userSettings2 }
}
```

---

## 3. 基于依赖的并行化

### 问题

当异步操作之间存在部分依赖关系时，如果不仔细设计，可能导致可以并行执行的操作被迫串行等待。

### 错误示例

```typescript
// 问题：profile 不必要地等待了 config
const [user, config] = await Promise.all([
  fetchUser(),
  fetchConfig()
])
// profile 依赖 user，但不依赖 config，却仍然等待了 config
const profile = await fetchProfile(user.id)
```

### 正确示例（使用 better-all）

```typescript
import { all } from 'better-all'

// 优化：config 和 profile 可以并行执行
const { user, config, profile } = await all({
  async user() {
    return fetchUser()
  },
  async config() {
    return fetchConfig()
  },
  async profile() {
    // 依赖 user，不依赖 config
    return fetchProfile((await this.$.user).id)
  }
})
```

### 正确示例（手动 Promise）

```typescript
// 优化：手动启动所有可能的 Promise
const userPromise = fetchUser()
const configPromise = fetchConfig()
const profilePromise = userPromise.then(user => fetchProfile(user.id))

// 并行等待
const[ user, config, profile ] = await Promise.all([
  userPromise,
  configPromise,
  profilePromise
])
```

### 执行流程对比

```
错误方式：
fetchUser ────┐
fetchConfig ──┼──→ 等待最慢的一个完成 ──→ fetchProfile ──→ 完成

正确方式：
fetchUser ────┐
fetchConfig ──┼──→ 等待最慢的一个完成 ──→ 完成
              └→ fetchProfile(依赖 user) ────────────────────────┘
```

### 为什么重要

- **CRITICAL 级别**优化
- 最大化并行度
- 可实现 **2-10 倍**性能提升

---

## 4. 防止 API 路由中的瀑布链

### 问题

在 API 路由和 Server Actions 中，如果不立即启动独立操作，会造成不必要的瀑布延迟。

### 错误示例

```typescript
export async function GET(request: Request) {
  // 问题：串行执行
  const session = await auth()
  const config = await fetchConfig()        // 等待 session
  const data = await fetchData(session.user.id) // 等待 config

  return Response.json({ data, config })
}
```

### 正确示例

```typescript
export async function GET(request: Request) {
  // 优化：立即启动所有独立的 Promise
  const sessionPromise = auth()
  const configPromise = fetchConfig()

  // 只等待实际需要的依赖
  const session = await sessionPromise
  const dataPromise = fetchData(session.user.id)

  const [config, data] = await Promise.all([
    configPromise,
    dataPromise
  ])

  return Response.json({ data, config })
}
```

### 为什么重要

- **CRITICAL 级别**优化
- 可实现 **2-10 倍**性能提升
- 在 API 路由和 Server Actions 中，应该立即启动独立操作，即使暂时不 await 它们

### 关键原则

```typescript
// ✅ 正确：立即启动 Promise
const promise = fetchSomething()
const result = await promise

// ❌ 错误：延迟启动
const result = await fetchSomething()
```

---

## 5. 策略性使用 Suspense 边界

### 问题

当页面中有部分数据加载较慢时，如果使用顶层 await，会阻塞整个页面的渲染。

### 错误示例

```tsx
async function Page() {
  // 问题：阻塞整个页面，直到 fetchData 完成
  const data = await fetchData()

  return (
    <div>
      <div>Sidebar</div>      // 被阻塞
      <div>Header</div>       // 被阻塞
      <div><DataDisplay data={data} /></div>
      <div>Footer</div>       // 被阻塞
    </div>
  )
}
```

### 正确示例

```tsx
function Page() {
  return (
    <div>
      <div>Sidebar</div>      // 立即渲染
      <div>Header</div>       // 立即渲染
      <div>
        <Suspense fallback={<Skeleton />}>
          <DataDisplay />    {/* 异步加载 */}
        </Suspense>
      </div>
      <div>Footer</div>       // 立即渲染
    </div>
  )
}

async function DataDisplay() {
  const data = await fetchData()
  return <div>{data.content}</div>
}
```

### 为什么重要

- 更快的初始渲染
- 流式加载内容
- 提升用户体验

### 使用 Suspense 的考虑因素

| 考虑因素 | 说明 |
|---------|------|
| ✅ 适合 | 非关键内容、低优先级数据 |
| ❌ 不适合 | 需要 layout 决策的数据、SEO 关键内容 |
| ⚠️ 权衡 | 更快的初始渲染 vs 可能的布局偏移 |

### 实际示例

```tsx
function ProductPage() {
  return (
    <Layout>
      {/* 关键信息立即加载 */}
      <Suspense fallback={<ProductSkeleton />}>
        <ProductHeader />
      </Suspense>

      {/* 评论可以延迟加载 */}
      <Suspense fallback={<CommentsSkeleton />}>
        <ProductComments />
      </Suspense>

      {/* 推荐产品最后加载 */}
      <Suspense fallback={<RecommendationsSkeleton />}>
        <ProductRecommendations />
      </Suspense>
    </Layout>
  )
}
```

---

## 总结

消除瀑布流是 React 和 Next.js 性能优化中最关键的优化方向：

| 规则 | 优先级 | 性能提升 |
|------|--------|---------|
| 延迟 await | 关键 | 响应速度提升 |
| Promise.all | 关键 | 2-10 倍 |
| 基于依赖并行 | 关键 | 2-10 倍 |
| API 路由优化 | 关键 | 2-10 倍 |
| Suspense 边界 | 关键 | 更快初始渲染 |

### 核心原则

1. **并行化独立操作**：使用 `Promise.all()` 或类似方法
2. **延迟 await**：只在真正需要数据时才等待
3. **考虑依赖关系**：确保并行执行尽可能多的操作
4. **使用 Suspense**：让非关键内容流式加载

### 检查清单

- [ ] 是否有串行的 `await` 可以并行化？
- [ ] 是否有 `await` 可以移动到实际使用它的分支？
- [ ] API 路由是否立即启动了所有独立操作？
- [ ] 是否可以使用 Suspense 来流式加载内容？
