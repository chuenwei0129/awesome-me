# React 高级模式

## 概述

高级模式关注 React 中一些不那么常用但非常有用的技巧，包括事件处理程序稳定性、应用初始化和稳定的回调引用。

## 目录

1. [在 Ref 中存储事件处理程序](#1-在-ref-中存储事件处理程序)
2. [初始化应用一次而不是每次挂载](#2-初始化应用一次而不是每次挂载)
3. [使用 useEffectEvent 获取稳定的回调引用](#3-使用-useeffectevent-获取稳定的回调引用)

---

## 1. 在 Ref 中存储事件处理程序

### 问题

当事件处理程序作为依赖项时，每次处理程序变化都会重新订阅事件。

### 错误示例

```tsx
function useWindowEvent(event: string, handler: (e: Event) => void) {
  useEffect(() => {
    window.addEventListener(event, handler)
    return () => window.removeEventListener(event, handler)
  }, [event, handler])  // 问题：每次 handler 变化都重新订阅
}

// 使用
function App() {
  const [count, setCount] = useState(0)

  // 每次渲染都创建新的 handler
  const handleClick = () => setCount(c => c + 1)

  useWindowEvent('click', handleClick)

  return <div>{count}</div>
}
```

### 正确示例（Ref 模式）

```tsx
function useWindowEvent(event: string, handler: (e: Event) => void) {
  // 使用 ref 存储最新的 handler
  const handlerRef = useRef(handler)

  // 更新 ref
  useEffect(() => {
    handlerRef.current = handler
  }, [handler])

  // 稳定的 effect，依赖只有 event
  useEffect(() => {
    const listener = (e: Event) => handlerRef.current(e)
    window.addEventListener(event, listener)
    return () => window.removeEventListener(event, listener)
  }, [event])
}
```

### 正确示例（useEffectEvent）

```tsx
import { useEffectEvent } from 'react'

function useWindowEvent(event: string, handler: (e: Event) => void) {
  // 使用 useEffectEvent 创建稳定的引用
  const onEvent = useEffectEvent(handler)

  useEffect(() => {
    window.addEventListener(event, onEvent)
    return () => window.removeEventListener(event, onEvent)
  }, [event])
}

// 使用
function App() {
  const [count, setCount] = useState(0)

  const handleClick = () => setCount(c => c + 1)

  // 现在 handleClick 变化不会导致重新订阅
  useWindowEvent('click', handleClick)

  return <div>{count}</div>
}
```

### 为什么重要

- 稳定的订阅
- 避免频繁的添加/移除事件监听器
- 更好的性能

---

## 2. 初始化应用一次而不是每次挂载

### 问题

在开发模式下，React 会严格模式（double invoke）运行 effect，导致某些初始化代码执行两次。

### 错误示例

```tsx
function App() {
  useEffect(() => {
    // 问题：在开发模式下运行两次
    initializeAnalytics()
    loadUserPreferences()
    connectWebSocket()
  }, [])
}
```

### 正确示例（运行一次标志）

```tsx
let didInit = false

function App() {
  useEffect(() => {
    if (didInit) return
    didInit = true

    initializeAnalytics()
    loadUserPreferences()
    connectWebSocket()
  }, [])
}
```

### 更好的方案（useEffectOnce）

```tsx
function useEffectOnce(effect: EffectCallback) {
  const effectRef = useRef<EffectCallback | null>(null)
  const initialized = useRef(false)

  effectRef.current = effect

  useEffect(() => {
    if (initialized.current) return
    initialized.current = true
    return effectRef.current?.()
  }, [])
}

// 使用
function App() {
  useEffectOnce(() => {
    initializeAnalytics()
    loadUserPreferences()
    connectWebSocket()
  })
}
```

### 为什么重要

- 避免开发中重复初始化
- 防止重复的资源分配
- 更清晰的开发体验

---

## 3. 使用 useEffectEvent 获取稳定的回调引用

### 问题

当回调函数作为 Effect 依赖时，每次回调变化都会导致 Effect 重新运行。

### 错误示例

```tsx
function SearchInput({ onSearch }: { onSearch: (query: string) => void }) {
  const [query, setQuery] = useState('')

  useEffect(() => {
    const timeout = setTimeout(() => onSearch(query), 300)
    return () => clearTimeout(timeout)
  }, [query, onSearch])  // 问题：每次 onSearch 变化都重新运行
}
```

### 正确示例（useEffectEvent）

```tsx
import { useEffectEvent } from 'react'

function SearchInput({ onSearch }: { onSearch: (query: string) => void }) {
  const [query, setQuery] = useState('')

  // 创建稳定的回调引用
  const onSearchEvent = useEffectEvent(onSearch)

  useEffect(() => {
    const timeout = setTimeout(() => onSearchEvent(query), 300)
    return () => clearTimeout(timeout)
  }, [query])  // 现在只依赖 query
}
```

### 实际应用示例

```tsxatsx
function FileUploader({ onUpload }: { onUpload: (file: File) => void }) {
  const [dragging, setDragging] = useState(false)

  // 稳定的上传回调
  const handleUpload = useEffectEvent(onUpload)

  useEffect(() => {
    const onDrop = (e: DragEvent) => {
      e.preventDefault()
      setDragging(false)

      const file = e.dataTransfer?.files[0]
      if (file) {
        handleUpload(file)  // 使用稳定的引用
      }
    }

    const onDragOver = (e: DragEvent) => {
      e.preventDefault()
      setDragging(true)
    }

    window.addEventListener('drop', onDrop)
    window.addEventListener('dragover', onDragOver)

    return () => {
      window.removeEventListener('drop', onDrop)
      window.removeEventListener('dragover', onDragOver)
    }
  }, [handleUpload])  // 稳定，不会变化

  return (
    <div className={dragging ? 'dragging' : ''}>
      Drop files here
    </div>
  )
}
```

### useEffectEvent 的行为

| 特性 | 说明 |
|------|------|
| 稳定性 | 返回的函数引用永远不变 |
| 闭包更新 | 每次渲染时更新内部闭包 |
| Effect 依赖 | 不需要作为依赖 |
| 用途 | 在 Effect 中使用最新 props/state |

### 为什么重要

- 防止 effect 重新运行
- 简化依赖数组
- 更稳定的组件行为

---

## 总结

React 高级模式提供了一些高级技巧来解决特定问题：

| 模式 | 解决的问题 |
|------|-----------|
| Ref 存储事件处理程序 | 稳定的订阅，避免频繁重新注册 |
| 初始化应用一次 | 避免开发模式下重复初始化 |
| useEffectEvent | 稳定的回调引用，避免 effect 重新运行 |

### 核心原则

1. **稳定的引用**：使用 Ref 或 useEffectEvent 保持引用稳定
2. **初始化一次**：使用标志确保只初始化一次
3. **简化依赖**：减少 Effect 依赖项

### 检查清单

- [ ] 频繁变化的事件处理程序是否使用 Ref 存储？
- [ ] 应用初始化是否只运行一次？
- [ ] Effect 中的回调是否使用 useEffectEvent？

---

## 完整系列回顾

Vercel React 最佳实践系列文章完成，共 8 篇文章，涵盖了 57 条性能优化规则：

| 系列文章 | 规则数量 | 优先级 |
|----------|----------|--------|
| [消除瀑布流性能优化](./01-消除瀑布流性能优化.md) | 5 | 关键 |
| [包大小优化](./02-包大小优化.md) | 5 | 关键 |
| [服务端性能优化](./03-服务端性能优化.md) | 7 | 高 - 关键 |
| [客户端数据获取优化](./04-客户端数据获取优化.md) | 4 | 中 - 高 |
| [重渲染优化](./05-重渲染优化.md) | 12 | 中 |
| [渲染性能优化](./06-渲染性能优化.md) | 9 | 中 |
| [JavaScript 性能优化](./07-JavaScript性能优化.md) | 12 | 低 - 中 |
| [React 高级模式](./08-高级模式.md) | 3 | 低 |

### 性能影响优先级

1. **关键优先级**：消除瀑布流、包大小优化
2. **高优先级**：服务端性能、客户端数据获取
3. **中优先级**：重渲染优化、渲染性能
4. **低中优先级**：JavaScript 性能优化
5. **低优先级**：高级模式

### 建议的学习路径

1. 先学习**消除瀑布流**和**包大小优化**（关键）
2. 然后学习**服务端性能**和**客户端数据获取**（高）
3. 接着学习**重渲染优化**和**渲染性能**（中）
4. 最后学习**JavaScript 性能**和**高级模式**（低）

希望这个系列能帮助你构建高性能的 React 和 Next.js 应用！
