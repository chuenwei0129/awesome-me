# 客户端数据获取优化

## 概述

客户端数据获取优化主要关注如何高效地获取、去重和管理客户端数据，包括事件监听器、本地存储和数据获取库的使用。

## 目录

1. [使用 SWR 自动去重](#1-使用-swr-自动去重)
2. [去重全局事件监听器](#2-去重全局事件监听器)
3. [使用被动事件监听器提高滚动性能](#3-使用被动事件监听器提高滚动性能)
4. [版本化和最小化 localStorage 数据](#4-版本化和最小化-localstorage-数据)

---

## 1. 使用 SWR 自动去重

### 问题

使用传统的 `useEffect` + `fetch` 模式时，多个组件请求相同数据会导致重复请求，而且容易产生竞态条件。

### 错误示例

```tsx
function UserList() {
  const [users, setUsers] = useState([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetch('/api/users')
      .then(r => r.json())
      .then(data => {
        setUsers(data)
        setLoading(false)
      })
  }, [])

  if (loading) return <div>Loading...</div>
  return <div>{users.map(u => <div key={u.id}>{u.name}</div>)}</div>
}
```

### 正确示例（使用 SWR）

```tsx
import useSWR from 'swr'

const fetcher = (url: string) => fetch(url).then(r => r.json())

function UserList() {
  const { data: users, error, isLoading } = useSWR('/api/users', fetcher)

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <div>
      {users.map(u => <div key={u.id}>{u.name}</div>)}
    </div>
  )
}
```

### SWR 的优势

| 特性 | 说明 |
|------|------|
| 自动去重 | 相同 key 只请求一次 |
| 自动重试 | 失败后自动重试 |
| 自动重新验证 | 窗口聚焦时重新获取 |
| 竞态处理 | 避免竞态条件 |
| 分页/无限滚动 | 内置支持 |

### 高级用法

```tsx
import useSWR from 'swr'
import useSWRMutation from 'swr/mutation'

// 获取数据
const { data, error, isLoading } = useSWR('/api/users', fetcher)

// 变更数据
const { trigger: createUser, isMutating } = useSWRMutation(
  '/api/users',
  async (url, { arg }: { arg: { name: string } }) => {
    const res = await fetch(url, {
      method: 'POST',
      body: JSON.stringify(arg)
    })
    return res.json()
  }
)

// 条件获取
const { data } = useSWR(isEnabled ? '/api/users' : null, fetcher)

// 依赖查询
const { data: user } = useSWR(userId ? `/api/users/${userId}` : null, fetcher)
const { data: posts } = useSWR(user ? `/api/posts?userId=${user.id}` : null, fetcher)
```

### 为什么重要

- **MEDIUM-HIGH 级别**优化
- 自动去重，避免重复请求
- 处理复杂的获取逻辑
- 更好的用户体验

---

## 2. 去重全局事件监听器

### 问题

当多个组件实例都注册相同的全局事件监听器时，会产生重复的监听器，影响性能。

### 错误示例

```tsx
function useKeyboardShortcut(key: string, callback: () => void) {
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.metaKey && e.key === key) {
        callback()
      }
    }
    window.addEventListener('keydown', handler)
    return () => window.removeEventListener('keydown', handler)
  }, [key, callback])
}

// 问题：3 个组件实例 = 3 个监听器
function App() {
  useKeyboardShortcut('s', () => console.log('Save'))
  useKeyboardShortcut('k', () => console.log('Search'))
  useKeyboardShortcut('c', () => console.log('Copy'))
}
```

### 正确示例（使用共享 Map）

```tsx
import useSWRSubscription from 'swr/subscription'

// 全局存储所有快捷键回调
const keyCallbacks = new Map<string, Set<() => void>>()

function useKeyboardShortcut(key: string, callback: () => void) {
  // 注册回调
  useEffect(() => {
    if (!keyCallbacks.has(key)) {
      keyCallbacks.set(key, new Set())
    }
    keyCallbacks.get(key)!.add(callback)

    return () => {
      const set = keyCallbacks.get(key)
      if (set) {
        set.delete(callback)
        if (set.size === 0) {
          keyCallbacks.delete(key)
        }
      }
    }
  }, [key, callback])

  // 单一全局监听器
  useSWRSubscription('global-keydown', () => {
    const handler = (e: KeyboardEvent) => {
      if (e.metaKey && keyCallbacks.has(e.key)) {
        keyCallbacks.get(e.key)!.forEach(cb => cb())
      }
    }
    window.addEventListener('keydown', handler)
    return () => window.removeEventListener('keydown', handler)
  })
}

// 优化：3 个组件实例 = 1 个监听器
function App() {
  useKeyboardShortcut('s', () => console.log('Save'))
  useKeyboardShortcut('k', () => console.log('Search'))
  useKeyboardShortcut('c', () => console.log('Copy'))
}
```

### 其他全局事件的示例

```tsx
// 共享的滚动监听器
const scrollCallbacks = new Set<() => void>()

function useOnScroll(callback: () => void) {
  useEffect(() => {
    scrollCallbacks.add(callback)
    return () => scrollCallbacks.delete(callback)
  }, [callback])

  useEffect(() => {
    let ticking = false
    const handler = () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          scrollCallbacks.forEach(cb => cb())
          ticking = false
        })
        ticking = true
      }
    }
    window.addEventListener('scroll', handler)
    return () => window.removeEventListener('scroll', handler)
  }, [])
}
```

### 为什么重要

- N 个组件实例只使用 1 个监听器
- 减少内存占用
- 提高性能

---

## 3. 使用被动事件监听器提高滚动性能

### 问题

某些事件监听器（如 `touchstart`、`wheel`）如果不标记为 `passive`，浏览器会等待监听器执行完成才能继续滚动，导致滚动延迟。

### 错误示例

```tsx
function TouchHandler() {
  useEffect(() => {
    const handleTouch = (e: TouchEvent) => {
      console.log(e.touches[0].clientX)
    }
    const handleWheel = (e: WheelEvent) => {
      console.log(e.deltaY)
    }

    // 问题：不使用 passive，可能导致滚动延迟
    document.addEventListener('touchstart', handleTouch)
    document.addEventListener('wheel', handleWheel)

    return () => {
      document.removeEventListener('touchstart', handleTouch)
      document.removeEventListener('wheel', handleWheel)
    }
  }, [])

  return <div>Touch and scroll me</div>
}
```

### 正确示例

```tsx
function TouchHandler() {
  useEffect(() => {
    const handleTouch = (e: TouchEvent) => {
      console.log(e.touches[0].clientX)
    }
    const handleWheel = (e: WheelEvent) => {
      console.log(e.deltaY)
    }

    // 优化：使用 passive
    document.addEventListener('touchstart', handleTouch, { passive: true })
    document.addEventListener('wheel', handleWheel, { passive: true })

    return () => {
      document.removeEventListener('touchstart', handleTouch)
      document.removeEventListener('wheel', handleWheel)
    }
  }, [])

  return <div>Touch and scroll me</div>
}
```

### Passive 监听器的使用场景

| 事件类型 | 何时使用 Passive | 何时不使用 |
|----------|------------------|-------------|
| `touchstart`, `touchmove` | 只读取数据、不阻止默认行为 | 需要自定义滑动手势 |
| `wheel` | 只读取数据、不阻止默认行为 | 需要自定义滚动行为 |
| `scroll` | 只读取数据 | 不适用（无法调用 preventDefault） |

### 为什么重要

- 消除由事件监听器引起的滚动延迟
- 更流畅的用户体验
- 提高 60fps 的可能性

---

## 4. 版本化和最小化 localStorage 数据

### 问题

`localStorage` 数据如果不版本化，可能导致应用更新后的数据格式不兼容。同时，存储过多数据会影响性能。

### 错误示例

```typescript
// 问题 1：没有版本控制
localStorage.setItem('userConfig', JSON.stringify(fullUserObject))

// 问题 2：没有错误处理（incognito 模式可能抛出）
const data = localStorage.getItem('userConfig')
const config = JSON.parse(data || '{}')
```

### 正确示例

```typescript
const VERSION = 'v2'

interface UserConfig {
  theme: 'light' | 'dark'
  language: string
  fontSize: number
}

function saveConfig(config: UserConfig) {
  try {
    localStorage.setItem(`userConfig:${VERSION}`, JSON.stringify(config))
  } catch (e) {
    // 处理存储限制或错误
    console.warn('Failed to save config:', e)
  }
}

function loadConfig(): UserConfig | null {
  try {
    const data = localStorage.getItem(`userConfig:${VERSION}`)
    return data ? JSON.parse(data) : null
  } catch (e) {
    console.warn('Failed to load config:', e)
    return null
  }
}

// 迁移旧版本数据
function migrateConfig() {
  const oldKey = 'userConfig'
  const oldData = localStorage.getItem(oldKey)

  if (oldData && !localStorage.getItem(`userConfig:${VERSION}`)) {
    try {
      const oldConfig = JSON.parse(oldData)
      const newConfig = migrateV1ToV2(oldConfig)
      saveConfig(newConfig)
      localStorage.removeItem(oldKey)
    } catch (e) {
      console.warn('Migration failed:', e)
    }
  }
}
```

### localStorage 最佳实践

| 实践 | 说明 |
|------|------|
| 使用键前缀 | `app:version:key` |
| 版本控制 | 在键中包含版本号 |
| 错误处理 | 包裹在 try-catch 中 |
| 最小化数据 | 只存储必要字段 |
| 避免敏感数据 | 不要存储密码、令牌 |

### 最小化数据的示例

```typescript
// ❌ 错误：存储完整用户对象
localStorage.setItem('user', JSON.stringify(fullUserObject))

// ✅ 正确：只存储必要字段
localStorage.setItem(
  'user:preferences',
  JSON.stringify({
    theme: user.preferences.theme,
    language: user.preferences.language,
    // 不存储敏感信息
  })
)
```

### 为什么重要

- 防止模式冲突
- 支持数据迁移
- 减少存储大小
- 避免存储敏感数据

---

## 总结

客户端数据获取优化关注高效的数据管理和事件处理：

| 规则 | 优先级 | 影响 |
|------|--------|------|
| 使用 SWR | 中中高 | 自动去重、更好的 UX |
| 去重事件监听器 | 中 | 减少监听器数量 |
| 被动事件监听器 | 中 | 更流畅的滚动 |
| localStorage 优化 | 中 | 避免数据冲突 |

### 核心原则

1. **使用数据获取库**：SWR、TanStack Query 提供自动去重和更好的 UX
2. **去重监听器**：共享全局监听器，减少重复
3. **使用 passive**：滚动相关事件使用 passive 监听器
4. **版本化存储**：localStorage 使用键前缀和版本号

### 检查清单

- [ ] 是否使用数据获取库（SWR/TanStack Query）？
- [ ] 全局事件监听器是否去重？
- [ ] 滚动相关事件是否使用 passive？
- [ ] localStorage 是否有版本控制？
- [ ] localStorage 数据是否最小化？
