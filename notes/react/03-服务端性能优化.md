# 服务端性能优化

## 概述

服务端性能优化是 Next.js 应用的重要组成部分，特别是对于使用 Server Components 和 Server Actions 的应用。正确的优化可以显著提高响应时间和资源利用率。

## 目录

1. [像 API 路由一样认证 Server Actions](#1-像-api-路由一样认证-server-actions)
2. [使用 React.cache() 进行每次请求去重](#2-使用-reactcache-进行每次请求去重)
3. [跨请求 LRU 缓存](#3-跨请求-lru-缓存)
4. [避免 RSC Props 中的重复序列化](#4-避免-rsc-props-中的重复序列化)
5. [最小化 RSC 边界处的序列化](#5-最小化-rsc-边界处的序列化)
6. [使用组件组合并行获取数据](#6-使用组件组合并行获取数据)
7. [使用 after() 执行非阻塞操作](#7-使用-after-执行非阻塞操作)

---

## 1. 像 API 路由一样认证 Server Actions

### 问题

Server Actions 是公开的 HTTP 端点，任何人都可以调用。如果不在内部进行身份验证和授权检查，会导致严重的安全问题。

### 错误示例

```typescript
'use server'

export async function deleteUser(userId: string) {
  // ⚠️ 危险：任何人都可以调用这个函数
  await db.user.delete({ where: { id: userId } })
  return { success: true }
}
```

### 正确示例

```typescript
'use server'

import { verifySession } from '@/lib/auth'
import { unauthorized } from '@/lib/errors'

export async function deleteUser(userId: string) {
  // 1. 验证用户身份
  const session = await verifySession()

  // 2. 检查登录状态
  if (!session) {
    throw unauthorized('Must be logged in')
  }

  // 3. 检查权限
  if (session.user.role !== 'admin' && session.user.id !== userId) {
    throw unauthorized('Cannot delete other users')
  }

  // 4. 执行操作
  await db.user.delete({ where: { id: userId } })
  return { success: true }
}
```

### 安全检查模板

```typescript
'use server'

export async function sensitiveOperation(params: any) {
  // 模板：安全检查流程
  const session = await verifySession()

  // 检查 1：是否登录
  if (!session) {
    throw unauthorized('Authentication required')
  }

  // 检查 2：是否有权限
  if (!hasPermission(session.user, 'operation:execute')) {
    throw forbidden('Insufficient permissions')
  }

  // 检查 3：参数验证
  if (!isValidParams(params)) {
    throw badRequest('Invalid parameters')
  }

  // 执行操作
  return await performOperation(params)
}
```

### 为什么重要

- **CRITICAL 级别**安全要求
- Server Actions 是公开端点
- 必须在内部验证身份验证和授权
- 防止未授权访问服务端变更

---

## 2. 使用 React.cache() 进行每次请求去重

### 问题

在单个请求中，相同的函数可能被多次调用，导致重复的数据库查询或 API 调用。

### 正确示例（单例函数）

```typescript
import { cache } from 'react'

// 使用 cache 包装，确保单次请求只执行一次
export const getCurrentUser = cache(async () => {
  const session = await auth()
  if (!session?.user?.id) return null

  return await db.user.findUnique({
    where: { id: session.user.id }
  })
})

// 即使调用多次，也只执行一次数据库查询
const user1 = await getCurrentUser()
const user2 = await getCurrentUser()  // 使用缓存
```

### 错误示例（有参数的函数）

```typescript
import { cache } from 'react'

// ⚠️ 问题：cache 使用浅相等，内联对象总是不同
const getUser = cache(async (params: { uid: number }) => {
  return await db.user.findUnique({ where: { id: params.uid } })
})

getUser({ uid: 1 })   // 查询执行
getUser({ uid: 1 })   // 缓存未命中！新的对象引用
```

### 正确示例（（有参数的函数）

```typescript
import { cache } from 'react'

// ✅ 方案 1：接受原始类型参数
const getUser = cache(async (uid: number) => {
  return await db.user.findUnique({ where: { id: uid } })
})

getUser(1)  // 查询执行
getUser(1)  // 使用缓存

// ✅ 方案 2：使用对象，但保持引用
const getUser2 = cache(async (params: { uid: number }) => {
  return await db.user.findUnique({ where: { id: params.uid } })
})

const params = { uid: 1 }
getUser2(params)  // 查询执行
getUser2(params)  // 使用缓存 - 相同引用
```

### React.cache() 的行为

| 特性 | 说明 |
|------|------|
| 缓存范围 | 单个请求 |
| 相等比较 | 浅相等（引用相等） |
| 适用场景 | 数据库查询、认证检查等非 fetch 工作 |
| 自动扩展 | Next.js 的 fetch API 自动扩展了请求记忆化 |

### 为什么重要

- 在单个请求中重复调用只执行一次
- 减少数据库查询次数
- 提高响应速度
- 减少服务器负载

---

## 3. 跨请求 LRU 缓存

### 问题

`React.cache()` 只在单个请求内工作，当需要在不同请求之间共享缓存时，需要其他方案。

### 正确示例

```typescript
import { LRUCache } from 'lru-cache'

// 创建跨请求缓存
const userCache = new LRUCache<string, User>({
  max: 1000,              // 最多缓存 1000 个用户
  ttl: 5 * 60 * 1000     // 5 分钟后过期
})

export async function getUser(id: string) {
  // 1. 检查缓存
  const cached = userCache.get(id)
  if (cached) {
    return cached
  }

  // 2. 查询数据库
  const user = await db.user.findUnique({ where: { id } })

  // 3. 存入缓存
  if (user) {
    userCache.set(id, user)
  }

  return user
}

export async function invalidateUser(id: string) {
  // 使缓存失效
  userCache.delete(id)
}
```

### 缓存策略对比

| 策略 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| `React.cache()` | 单次请求内 | 简单、自动 | 不跨请求 |
| `LRUCache` | 同一进程内多次请求 | 跨请求、可控 | 不跨进程 |
| `Redis` | 跨进程、跨服务器 | 共享缓存 | 需要额外基础设施 |

### Vercel Fluid Compute 的优势

```typescript
// 在 Vercel Fluid Compute 中，LRU 缓存特别有效
// 因为单个 server 实例可以处理多个顺序请求

const cache = new LRUCache<string, any>({
  max: 1000,
  ttl: 5 * 60 * 1000
})

// 传统无服务器环境：每次请求都是新进程
// Vercel Fluid Compute：同一进程处理多个请求
```

### 为什么重要

- 在多个顺序请求之间共享数据
- 减少重复的数据库查询
- 提高整体响应速度
- 特别适合 Vercel Fluid Compute

---

## 4. 避免 RSC Props 中的重复序列化

### 问题

当将数据从服务端组件传递到客户端组件时，如果传递派生数据，会导致重复序列化。

### 错误示例

```tsx
async function Page() {
  const usernames = ['alice', 'bob', 'charlie']
  const usernamesOrdered = usernames.toSorted()

  // 问题：发送 6 个字符串（2 个数组 × 3 项）
  return (
    <ClientList
      usernames={usernames}
      usernamesOrdered={usernamesOrdered}
    />
  )
}
```

### 正确示例

```tsx
async function Page() {
  const usernames = ['alice', 'bob', 'charlie']

  // 优化：只发送一次原始数据
  return <ClientList usernames={usernames} />
}

'use client'
function ClientList({ usernames }: { usernames: string[] }) {
  // 在客户端进行转换
  const sorted = useMemo(
    () => [...usernames].sort(),
    [usernames]
  )

  return <div>{sorted.map(name => <div key={name}>{name}</div>)}</div>
}
```

### 序列化行为

| 数据类型 | 序列化行为 |
|----------|------------|
| 对象数组 | 数组结构重复，嵌套对象去重 |
| 基本类型数组 | 完全重复（影响较大） |
| 对象 | 按引用去重 |

### 为什么重要

- 减少网络负载
- 减少服务端到客户端的数据传输量
- 对于基本类型数组影响特别大

---

## 5. 最小化 RSC 边界处的序列化

### 问题

当服务端组件将大量数据传递给客户端组件时，即使客户端只使用其中一小部分，也会导致大量不必要的序列化。

### 错误示例

```tsx
async function Page() {
  const user = await fetchUser()  // 50 个字段

  // 问题：发送完整的 user 对象（50 个字段）
  return <Profile user={user} />
}

'use client'
function Profile({ user }: { user: User }) {
  // 只使用 1 个字段
  return <div>{user.name}</div>
}
```

### 正确示例

```tsx
async function Page() {
  const user = await fetchUser()

  // 优化：只发送需要的字段
  return <Profile name={user.name} />
}

'use client'
function Profile({ name }: { name: string }) {
  return {<div>{name}</div>}
}
```

### 数据传输优化

```tsx
// ❌ 错误：传输整个对象
<UserProfile user={fullUserObject} />

// ✅ 正确：只传输需要的字段
<UserProfile
  name={user.name}
  avatar={user.avatar}
  email={user.email}
/>

// ✅ 更好：使用 DTO
<UserProfile user={toClientDTO(user)} />
```

### 为什么重要

- **HIGH 级别**优化
- 减少数据传输大小
- 提高水合速度
- 减少内存占用

---

## 6. 使用组件组合并行获取数据

### 问题

当在同一个组件中串行获取数据时，后续组件必须等待前面所有数据获取完成才能开始渲染。

### 错误示例（瀑布流）

```tsx
export default async function Page() {
  // 问题：串行获取数据
  const header = await fetchHeader()

  return (
    <div>
      <div>{header}</div>
      {/* Sidebar 必须等待 fetchHeader 完成 */}
      <Sidebar />
    </div>
  )
}
```

### 正确示例（并行获取）

```tsx
// 将数据获取拆分到独立的组件中
async function Header() {
  const data = await fetchHeader()
  return <div>{data}</div>
}

async function Sidebar() {
  const items = await fetchSidebarItems()
  return <nav>{items.map(renderItem)}</nav>
}

export default function Page() {
  return (
    <div>
      {/* Header 和 Sidebar 并行获取数据 */}
      <Header />
      <Sidebar />
    </div>
  )
}
```

### 执行流程对比

```
错误方式（瀑布流）：
fetchHeader ──────→ 完成
                              ↓
                        Sidebar 开始
                        fetchSidebarItems ──→ 完成

正确方式（并行）：
fetchHeader ──────────────┐
fetchSidebarItems ───────┼──→ 都完成后渲染
                           ↓
                        完成
```

### 为什么重要

- **CRITICAL 级别**优化
- 消除服务端瀑布
- 最大化并行度
- 显著提高响应速度

---

## 7. 使用 after() 执行非阻塞操作

### 问题

某些操作（如日志记录、分析跟踪、通知发送）不需要阻塞主要响应，但串行执行会增加响应时间。

### 错误示例

```tsx
export async function POST(request: Request) {
  await updateDatabase(request)

  // 问题：日志阻塞响应
  const userAgent = request.headers.get('user-agent') || 'unknown'
  await logUserAction({ userAgent })

  return new Response(JSON.stringify({ status: 'success' }), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  })
}
```

### 正确示例

```tsx
import { after } from 'next/server'

export async function POST(request: Request) {
  await updateDatabase(request)

  // 优化：使用 after() 非阻塞执行日志
  after(async () => {
    const userAgent = (await headers()).get('user-agent') || 'unknown'
    await logUserAction({ userAgent })
  })

  // 立即返回响应
  return new Response(JSON.stringify({ status: 'success' }), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  })
}
```

### after() 的适用场景

| 场景 | 是否适合 |
|------|----------|
| 分析跟踪 | ✅ |
| 审计日志 | ✅ |
| 发送通知 | ✅ |
| 缓存失效 | ✅ |
| 数据库更新 | ❌（关键数据） |
| 返回数据 | ❌（必须等待） |

### 为什么重要

- 更快的响应时间
- 不阻塞主要业务逻辑
- 适合后台任务

---

## 总结

服务端性能优化是 Next.js 应用性能的关键部分：

| 规则 | 优先级 | 影响 |
|------|--------|------|
| Server Actions 认证 | 关键 | 安全性 |
| React.cache() 去重 | 高 | 减少查询 |
| LRU 缓存 | 高 | 跨请求共享 |
| 避免重复序列化 | 中 | 减少网络负载 |
| 最小化序列化 | 高 | 减少传输量 |
| 并行数据获取 | 关键 | 消除瀑布 |
| after() 非阻塞 | 中 | 更快响应 |

### 核心原则

1. **安全第一**：Server Actions 必须进行认证和授权
2. **去重查询**：使用 React.cache() 避免重复查询
3. **跨请求缓存**：使用 LRU 缓存共享数据
4. **最小化传输**：只传递客户端需要的数据
5. **并行获取**：拆分组件并行获取数据
6. **非阻塞操作**：使用 after() 执行后台任务

### 检查清单

- [ ] 所有 Server Actions 都有认证检查？
- [ ] 是否使用 React.cache() 去重重复查询？
- [ ] 是否使用 LRU 缓存优化跨请求性能？
- [ ] RSC Props 是否只传递必要的数据？
- [ ] 数据获取是否可以并行化？
- [ ] 后台任务是否使用 after()？
