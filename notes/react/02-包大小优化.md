# 包大小优化

## 概述

包大小优化直接影响应用的加载时间、TTI（Time to Interactive）和 LCP（Largest Contentful Paint）。这是 React 和 Next.js 性能优化中**最关键**的优化方向之一。

## 目录

1. [避免 Barrel 文件导入](#1-避免-barrel-文件导入)
2. [动态导入重型组件](#2-动态导入重型组件)
3. [延迟加载非关键第三方库](#3-延迟加载非关键第三方库)
4. [条件模块加载](#4-条件模块加载)
5. [基于用户意图预加载](#5-基于用户意图预加载)

---

## 1. 避免 Barrel 文件导入

### 什么是 Barrel 文件

Barrel 文件（桶文件）是一种导出模式，将多个模块重新导出到一个索引文件中：

```typescript
// 例子：lucide-react 的 barrel 文件
export { Check } from './icons/check'
export { X } from './icons/x'
export { Menu } from './icons/menu'
// ... 还有很多其他导出
```

### 问题

当从 barrel 文件导入时，打包工具可能无法正确地进行 tree-shaking，导致加载大量不需要的代码。

### 错误示例

```tsx
// 问题：从 barrel 文件导入
import { Check, X, Menu } from 'lucide-react'
```

**实际影响**：
- 加载了 **1,583 个模块**
- 开发模式下额外耗时 ~2.8 秒
- 每次冷启动需要 **200-800ms** 运行时成本

### 正确示例（直接导入）

```tsx
// 优化：直接从文件路径导入
import Check from 'lucide-react/dist/esm/icons/check'
import X from 'lucide-react/dist/esm/icons/x'
import Menu from 'lucide-react/dist/esm/icons/menu'
```

**优化效果**：
- 只加载 **3 个模块**
- 极大减少加载时间

### 正确示例（Next.js 配置自动优化）

```typescript
// next.config.mjs
export default {
  experimental: {
    optimizePackageImports: ['lucide-react']
  }
}

// 代码保持简洁
import { Check, X, Menu } from 'lucide-react'
```

### 常见受影响库

| 库名 | 说明 |
|------|------|
| `lucide-react` | 图标库 |
| `@mui/material` | Material UI |
| `@mui/icons-material` | Material Icons |
| `@tabler/icons-react` | Tabler Icons |
| `react-icons` | React Icons |
| `@headlessui/react` | Headless UI |
| `@radix-ui/react-*` | Radix UI |
| `lodash`, `ramda` | 工具函数库 |
| `date-fns` | 日期处理 |
| `rxjs` | RxJS |
| `react-use` | React Hooks |

### 为什么重要

- **CRITICAL 级别**优化
- 节省 **200-800ms** 导入成本
- 加快构建速度
- 减少最终 bundle 大小

---

## 2. 动态导入重型组件

### 问题

重型组件（如 Monaco 编辑器、复杂图表库等）如果与主代码一起打包，会显著增加初始 bundle 大。

### 错误示例

```tsx
import { MonacoEditor } from './monaco-editor'

function CodePanel({ code }: { code: string }) {
  return <MonacoEditor value={code} />
}

// Monaco 与主 chunk 一起打包 ~300KB
```

### 正确示例（Next.js dynamic）

```tsx
import dynamic from 'next/dynamic'

const MonacoEditor = dynamic(
  () => import('./monaco-editor').then(m => m.MonacoEditor),
  { ssr: false }  // 不需要 SSR
)

function CodePanel({ code }: { code: string }) {
  return <MonacoEditor value={code} />
}

// Monaco 被分离到单独的 chunk，按需加载
```

### 完整示例（带加载状态）

```tsx
import dynamic from 'next/dynamic'
import { Spin } from 'antd'

const MonacoEditor = dynamic(
  () => import('./monaco-editor').then(m => m.MonacoEditor),
  {
    ssr: false,
    loading: () => <Spin size="large" />
  }
)

function CodePanel({ code, visible }: { code: string; visible: boolean }) {
  if (!visible) return null
  return <MonacoEditor value={code} />
}
```

### 为什么重要

- **CRITICAL 级别**优化
- 直接影响 TTI 和 LCP
- 减少初始加载时间
- 按需加载重型资源

---

## 3. 延迟加载非关键第三方库

### 问题

分析、日志和错误跟踪等第三方库不需要阻塞用户交互，应该在水合完成后加载。

### 错误示例

```tsx
import { Analytics } from '@vercel/analytics/react'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
        {/* 问题：Analytics 阻塞水合 */}
        <Analytics />
      </body>
    </html>
  )
}
```

### 正确示例

```tsx
import dynamic from 'next/dynamic'

const Analytics = dynamic(
  () => import('@vercel/analytics/react').then(m => m.Analytics),
  { ssr: false }
)

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
        {/* 优化：Analytics 在水合后加载 */}
        <Analytics />
      </body>
    </html>
  )
}
```

### 适合延迟加载的库

| 库类型 | 示例 |
|--------|------|
| 分析工具 | Google Analytics, Vercel Analytics, Mixpanel |
| 日志工具 | Sentry, LogRocket |
| 聊天组件 | Intercom, Drift |
| 反馈工具 | UserVoice, Hotjar |
| 广告脚本 | Google AdSense |

### 为什么重要

- 不阻塞用户交互
- 更快的 TTI
- 优先加载关键内容

---

## 4. 条件模块加载

### 问题

当某些功能只在特定条件下使用时（如功能开关、用户权限），应该条件性地加载相关模块。

### 错误示例

```tsx
// 问题：动画数据总是被打包
import { frames } from './animation-frames'

function AnimationPlayer({ enabled }: { enabled: boolean }) {
  if (!enabled) return <div>Animation disabled</div>
  return <Canvas frames={frames} />
}
```

### 正确示例

```tsx
// 优化：只在需要时加载动画帧
function AnimationPlayer({ enabled, setEnabled }: Props) {
  const [frames, setFrames] = useState<Frame[] | null>(null)

  useEffect(() => {
    if (enabled && !frames && typeof window !== 'undefined') {
      import('./animation-frames.js')
        .then(mod => setFrames(mod.frames))
        .catch(() => setEnabled(false))  // 加载失败时禁用
    }
  }, [enabled, frames, setEnabled])

  if (!frames) return <Skeleton />
  return <Canvas frames={frames} />
}
```

### 关键注意事项

```tsx
// ✅ 正确：检查 window 防止为 SSR 打包
if (typeof window !== 'undefined') {
  import('./some-client-only-module')
}

// ❌ 错误：会被 SSR 打包
import('./some-client-only-module')
```

### 为什么重要

- 按需加载大型数据或模块
- 减少初始 bundle 大小
- 支持 SSR 的客户端专用代码

---

## 5. 基于用户意图预加载

### 问题

当用户即将与某个功能交互时，提前加载相关模块可以减少感知延迟。

### 正确示例（Hover 预加载）

```tsx
function EditorButton({ onClick }: { onClick: () => void }) {
  const preload = () => {
    if (typeof window !== 'undefined') {
      // 用户 hover 时预加载编辑器
      void import('./monaco-editor')
    }
  }

  return (
    <button
      onMouseEnter={preload}
      onFocus={preload}
      onClick={onClick}
    >
      Open Editor
    </button>
  )
}
```

### 完整示例（路由预加载）

```tsx
import Link from 'next/link'

export default function Navigation() {
  return (
    <nav>
      <Link href="/dashboard" prefetch={true}>
        Dashboard
      </Link>
      {/* prefetch={true} 在 hover 时预加载 */}
    </nav>
  )
}
```

### 预加载策略

| 策略 | 触发时机 | 适用场景 |
|------|----------|----------|
| Hover | `onMouseEnter` | 按钮、链接 |
| Focus | `onFocus` | 表单输入 |
| Scroll | 滚动到视口附近 | 长列表 |
| Idle | 浏览器空闲时 | 低优先级资源 |

### 为什么重要

- 减少感知延迟
- 提升用户体验
- 充分利用用户交互前的空闲时间

---

## 总结

包大小优化是 React 和 Next.js 性能优化中最关键的优化方向之一：

| 规则 | 优先级 | 影响 |
|------|--------|------|
| 避免 Barrel 导入 | 关键 | 节省 200-800ms |
| 动态导入组件 | 关键 | 减少 TTI/LCP |
| 延迟第三方库 | 关键 | 不阻塞交互 |
| 条件模块加载 | 关键 | 减少初始 bundle |
| 用户意图预加载 | 中 | 减少感知延迟 |

### 核心原则

1. **直接导入**：避免从 barrel 文件导入
2. **懒加载**：使用 `next/dynamic` 懒加载重型组件
3. **延迟非关键**：分析、日志等在水合后加载
4. **条件加载**：只在需要时加载模块
5. **智能预加载**：基于用户行为提前加载

### 检查清单

- [ ] 是否从 barrel 文件导入图标？
- [ ] 重型组件是否使用 dynamic 懒加载？
- [ ] 分析、日志等是否延迟加载？
- [ ] 功能开关相关的代码是否条件加载？
- [ ] 是否在 hover/focus 时预加载关键资源？

### 工具推荐

- **Bundle Analyzer**: `@next/bundle-analyzer`
- **Lighthouse**: 检查 bundle 大小
- **Webpack Bundle Visualizer**: 可视化分析
