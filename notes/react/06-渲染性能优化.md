# 渲染性能优化

## 概述

渲染性能优化关注如何提高 DOM 渲染、布局和绘制的效率，包括 SVG 动画、长列表渲染和 hydration 优化。

## 目录

1. [动画化 SVG 包装器而不是 SVG 元素](#1-动画化-svg-包装器而不是-svg-元素)
2. [对长列表使用 CSS content-visibility](#2-对长列表使用-css-content-visibility)
3. [提升静态 JSX 元素](#3-提升静态-jsx-元素)
4. [优化 SVG 精度](#4-优化-svg-精度)
5. [在无闪烁的情况下防止水合不匹配](#5-在无闪烁的情况下防止水合不匹配)
6. [抑制预期的水合不匹配](#6-抑制预期的水合不匹配)
7. [使用 Activity 组件进行显示/隐藏](#7-使用-activity-组件进行显示/隐藏)
8. [使用显式条件渲染](#8-使用显式条件渲染)
9. [使用 useTransition 而不是手动加载状态](#9-使用-usetransition-而不是手动加载状态)

---

## 1. 动画化 SVG 包装器而不是 SVG 元素

### 问题

直接对 SVG 元素应用动画可能无法利用硬件加速，导致性能下降。

### 错误示例

```tsx
function LoadingSpinner() {
  return (
    // 问题：直接动画化 SVG 元素
    <svg className="animate-spin" width="24" height="24" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="10" stroke="currentColor" />
    </svg>
  )
}
```

### 正确示例

```tsx
function LoadingSpinner() {
  return (
    // 优化：动画化 div 包装器
    <div className="animate-spin">
      <svg width="24" height="24" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="10" stroke="currentColor" />
      </svg>
    </div>
  )
}
```

### CSS 动画示例

```css
/* 硬件加速的旋转动画 */
.animate-spin {
  animation: spin 1s linear infinite;
  will-change: transform;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
```

### 为什么重要

- 启用硬件加速
- 更流畅的动画
- 更好的性能

---

## 2. 对长列表使用 CSS content-visibility

### 问题

渲染长列表时，浏览器需要布局和绘制所有项目，即使大部分不在视口中。

### CSS 解决方案

```css
/* 使用 content-visibility 优化长列表 */
.message-item {
  content-visibility: auto;
  contain-intrinsic-size: 0 80px;
}
```

### 组件示例

```tsx
function MessageList({ messages }: { messages: Message[] }) {
  return (
    <div className="overflow-y-auto h-screen">
      {messages.map(msg => (
        <div key={msg.id} className="message-item">
          <Avatar user={msg.author} />
          <div>{msg.content}</div>
        </div>
      ))}
    </div>
  )
}
```

### 其他长列表优化

```tsx
// 虚拟滚动（使用 react-window 或 react-virtualized）
import { FixedSizeList as List } from 'react-window'

function VirtualList({ items }: { items: Item[] }) {
  const Row = ({ index, style }: { index: number; style: any }) => (
    <div style={style}>{items[index].content}</div>
  )

  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={80}
      width={300}
    >
      {Row}
    </List>
  )
}
```

### content-visibility 的优势

| 特性 | 说明 |
|------|------|
| `auto` | 浏览器决定是否跳过内容 |
| `contain-intrinsic-size` | 提供默认尺寸防止布局偏移 |
| 性能提升 | 1000 条消息，跳过约 990 个离屏项目 |

### 为什么重要

- 更快的初始渲染
- 减少布局和绘制工作
- 显著提高长列表性能

---

## 3. 提升静态 JSX 元素

### 问题

在组件内部创建静态 JSX 会导致每次渲染时重新创建这些元素。

### 错误示例

```tsx
function LoadingSkeleton() {
  return <div className="animate-pulse h-20 bg-gray-200" />
}

function Container() {
  return (
    <div>
      {loading && <LoadingSkeleton />}
    </div>
  )
}
```

### 正确示例

```tsx
// 提升到组件外部
const loadingSkeleton = (
  <div className="animate-pulse h-20 bg-gray-200" />
)

function Container() {
  return (
    <div>
      {loading && loadingSkeleton}
    </div>
  )
}
```

### 实际应用

```tsx
// 提升常用的静态元素
const navigationItems = [
  { id: 'home', label: 'Home', href: '/' },
  { id: 'about', label: 'About', href: '/about' },
  { id: 'contact', label: 'Contact', href: '/contact' }
]

const Footer = () => (
  <footer>
    {navigationItems.map(item => (
      <Link key={item.id} href={item.href}>{item.label}</Link>
    ))}
  </footer>
)
```

### 为什么重要

- 避免重新创建静态元素
- 减少内存分配
- 提高渲染性能

---

## 4. 优化 SVG 精度

### 问题

过度精确的 SVG 坐标会增加文件大小而不提供视觉上的改进。

### 错误示例

```svg
<!-- 问题：精度过高 -->
<path d="M 10.293847 20.847362 L 30.938472 40.192837" />
```

### 正确示例

```svg
<!-- 优化：适当的精度 -->
<path d="M 10.3 20.8 L 30.9 40.2" />
```

### 自动化优化

```bash
# 使用 svgo 优化 SVG
npx svgo --precision=1 --multipass icon.svg
```

### svgo 配置示例

```javascript
// svgo.config.js
module.exports = {
  plugins: [
    {
      name: 'preset-default',
      params: {
        overrides: {
          // 移除不必要的属性
          removeViewBox: false,
          convertPathData: {
            // 减少精度
            floatPrecision: 1
          },
          convertTransform: {
            // 简化变换
            precision: 1
          }
        }
      }
    }
  ]
}
```

### 为什么重要

- 减少文件大小
- 更快的加载
- 更小的 bundle

---

## 5. 在无闪烁的情况下防止水合不匹配

### 问题

客户端数据（如 localStorage）在 SSR 时不可用，会导致水合不匹配错误或视觉闪烁。

### 错误示例（SSR 失败）

```tsx
function ThemeWrapper({ children }: { children: ReactNode }) {
  // 问题：localStorage 在 SSR 时不可用
  const theme = localStorage.getItem('theme') || 'light'
  return <div className={theme}>{children}</div>
}
```

### 错误示例（视觉闪烁）

```tsx
function ThemeWrapper({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState('light')

  useEffect(() => {
    // 问题：先渲染 'light'，然后切换到存储的值
    const stored = localStorage.getItem('theme')
    if (stored) setTheme(stored)
  }, [])

  return <div className={theme}>{children}</div>
}
```

### 正确示例（内联脚本）

```tsx
function ThemeWrapper({ children }: { children: ReactNode }) {
  return (
    <>
      <div id="theme-wrapper">{children}</div>
      <script
        dangerouslySetInnerHTML={{
          __html: `
            (function() {
              try {
                var theme = localStorage.getItem('theme') || 'light';
                var el = document.getElementById('theme-wrapper');
                if (el) el.className = theme;
              } catch (e) {}
            })();
          `,
        }}
      />
    </>
  )
}
```

### 为什么重要

- 避免视觉闪烁
- 避免水合不匹配错误
- 更好的用户体验

---

## 6. 抑制预期的水合不匹配

### 问题

某些数据（如时间戳）在服务器和客户端之间必然不同，会导致水合警告。

### 错误示例

```tsx
function Timestamp() {
  // 问题：SSR 和客户端时间不同
  return <span>{new Date().toLocaleString()}</span>
}
```

### 正确示例

```tsx
function Timestamp() {
  // 优化：抑制预期的水合不匹配
  return (
    <span suppressHydrationWarning>
      {new Date().toLocaleString()}
    </span>
  )
}
```

### 其他示例

```tsx
// 随机值
function RandomValue() {
  return (
    <span suppressHydrationWarning>
      {Math.random()}
    </span>
  )
}

// 用户代理
function UserAgent() {
  return (
    <span suppressHydrationWarning>
      {navigator.userAgent}
    </span>
  )
}
```

### 为什么重要

- 避免嘈杂的水合警告
- 更清晰的开发体验

---

## 7. 使用 Activity 组件进行显示/隐藏

### 问题

使用条件渲染显示/隐藏组件时，会导致组件状态丢失和 DOM 销毁重建。

### 正确示例（Activity 组件）

```tsx
import { Activity } from 'react'

function Dropdown({ isOpen }: { isOpen: boolean }) {
  return (
    <Activity mode={isOpen ? 'visible' : 'hidden'}>
      <ExpensiveMenu />
    </Activity>
  )
}
```

### 传统方式的问题

```tsx
// 问题：每次切换都会重新创建组件
function Dropdown({ isOpen }: { isOpen: boolean }) {
  if (!isOpen) return null
  return <ExpensiveMenu />
}
```

### 为什么重要

- 保留状态/DOM
- 避免昂贵的重新创建
- 更好的性能

---

## 8. 使用显式条件渲染

### 问题

使用 `&&` 运算符进行条件渲染时，假值（如 `0` 或 `NaN`）会被渲染。

### 错误示例

```tsx
function Badge({ count }: { count: number }) {
  return (
    <div>
      {count && <span className="badge">{count}</span>}
    </div>
  )
}

// 当 count = 0 时，渲染：&lt;div&gt;0&lt;/div&gt;
```

### 正确示例

```tsx
function Badge({ count }: { count: number }) {
  return (
    <div>
      {count > 0 ? <span className="badge">{count}</span> : null}
    </div>
  )
}

// 当 count = 0 时，渲染：&lt;div&gt;&lt;/div&gt;
```

### 其他解决方案

```tsx
// 使用 ? : 运算符
{count > 0 && <span>{count}</span>}

// 使用 Boolean 转换
{!!count && <span>{count}</span>}

// 使用 children 模式
{count > 0 && <Badge>{count}</Badge>}
```

### 为什么重要

- 防止意外的渲染
- 更可预测的行为
- 避免调试困难

---

## 9. 使用 useTransition 而不是手动加载状态

### 问题

手动管理加载状态会导致额外的状态更新和重渲染。

### 错误示例

```tsx
function SearchResults() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])
  const [isLoading, setIsLoading] = useState(false)

  const handleSearch = async (value: string) => {
    setIsLoading(true)      // 重渲染 1
    setQuery(value)        // 重渲染 2
    const data = await fetchResults(value)
    setResults(data)       // 重渲染 3
    setIsLoading(false)     // 重渲染 4
  }

  return (
    <>
      <input onChange={(e) => handleSearch(e.target.value)} />
      {isLoading && <Spinner />}
      <ResultsList results={results} />
    </>
  )
}
```

### 正确示例

```tsx
import { useTransition, useState } from 'react'

function SearchResults() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])
  const [isPending, startTransition] = useTransition()

  const handleSearch = (value: string) => {
    setQuery(value)  // 立即更新，不阻塞

    startTransition(async () => {
      const data = await fetchResults(value)
      setResults(data)  // 在 transition 中更新
    })
  }

  return (
    <>
      <input onChange={(e) => handleSearch(e.target.value)} />
      {isPending && <Spinner />}
      <ResultsList results={results} />
    </>
  )
}
```

### 为什么重要

- 减少重渲染
- 更好的用户体验
- 保持输入响应

---

## 总结

渲染性能优化关注 DOM 渲染和 hydration 优化：

| 规则 | 优先级 | 影响 |
|------|--------|------|
| SVG 包装器动画 | 中 | 硬件加速 |
| content-visibility | 中 | 更快初始渲染 |
| 提升静态 JSX | 中 | 减少重新创建 |
| SVG 精度优化 | 低 | 减少文件大小 |
| 水合不匹配处理 | 中 | 避免闪烁和错误 |
| Activity 组件 | 中 | 保留状态 |
| 显式条件渲染 | 低 | 防止意外渲染 |
| useTransition | 中 | 减少重渲染 |

### 核心原则

1. **硬件加速**：使用 div 包装 SVG 进行动画
2. **长列表优化**：使用 content-visibility 或虚拟滚动
3. **提升静态元素**：将不变的 JSX 提升到组件外部
4. **优化 SVG**：减少精度，减小文件大小
5. **处理水合**：使用内联脚本或 suppressHydrationWarning
6. **保留状态**：使用 Activity 组件避免状态丢失
7. **显式条件**：使用 `? :` 而不是 `&&`
8. **使用 transition**：自动管理加载状态

### 检查清单

- [ ] SVG 动画是否使用包装器？
- [ ] 长列表是否使用 content-visibility 或虚拟滚动？
- [ ] 静态 JSX 是否提升到组件外部？
- [ ] SVG 精度是否优化？
- [ ] 水合不匹配是否正确处理？
- [ ] 条件渲染是否显式？
