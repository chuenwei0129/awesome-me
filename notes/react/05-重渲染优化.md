# 重渲染优化

## 概述

重渲染优化是 React 性能优化的核心。不必要的重渲染会降低应用性能，特别是在组件树较大或更新频繁的情况下。

## 目录

1. [延迟状态读取到使用点](#1-延迟状态读取到使用点)
2. [提取到记忆化组件](#2-提取到记忆化组件)
3. [提取默认非原始参数值](#3-提取默认非原始参数值)
4. [缩窄 Effect 依赖](#4-缩窄-effect-依赖)
5. [订阅派生状态](#5-订阅派生状态)
6. [在渲染期间计算派生状态](#6-在渲染期间计算派生状态)
7. [使用函数式 setState 更新](#7-使用函数式-setstate-更新)
8. [使用惰性状态初始化](#8-使用惰性状态初始化)
9. [不要用 useMemo 包装简单表达式](#9-不要用-usememo-包装简单表达式)
10. [将交互逻辑放在事件处理程序中](#10-将交互逻辑放在事件处理程序中)
11. [对非紧急更新使用 Transitions](#11-对非紧急更新使用-transitions)
12. [使用 useRef 存储瞬态值](#12-使用-useref-存储瞬态值)

---

## 1. 延迟状态读取到使用点

### 问题

在组件顶层读取 Context 或 Hooks 会导致组件在该状态变化时重新渲染，即使该状态只在事件处理程序中使用。

### 错误示例

```tsx
function ShareButton({ chatId }: { chatId: string }) {
  // 问题：组件会订阅 searchParams 的变化
  const searchParams = useSearchParams()

  const handleShare = () => {
    const ref = searchParams.get('ref')
    shareChat(chatId, { ref })
  }

  return <button onClick={handleShare}>Share</button>
}
```

### 正确示例

```tsx
function ShareButton({ chatId }: { chatId: string }) {
  const handleShare = () => {
    // 优化：只在需要时读取，不订阅
    const params = new URLSearchParams(window.location.search)
    const ref = params.get('ref')
    shareChat(chatId, { ref })
  }

  return <button onClick={handleShare}>Share</button>
}
```

### 为什么重要

- 避免不必要的订阅
- 防止无关的状态变化导致重渲染
- 特别适用于只在事件处理程序中使用的数据

---

## 2. 提取到记忆化组件

### 问题

在 `useMemo` 中计算复杂 JSX，如果父组件有早期返回，会导致计算浪费。

### 错误示例

```tsx
function Profile({ user, loading }: Props) {
  // 问题：即使 loading = true，仍然计算 avatar
  const avatar = useMemo(() => {
    const id = computeAvatarId(user)
    return <Avatar id={id} />
  }, [user])

  if (loading) return <Skeleton />
  return <div>{avatar}</div>
}
```

### 正确示例

```tsx
const UserAvatar = memo(function UserAvatar({ user }: { user: User }) {
  const id = useMemo(() => computeAvatarId(user), [user])
  return <Avatar id={id} />
})

function Profile({ user, loading }: Props) {
  // 优化：早期返回不会触发 UserAvatar 渲染
  if (loading) return <<Skeleton />

  return (
    <div>
      <UserAvatar user={user} />
    </div>
  )
}
```

### 为什么重要

- 启用早期返回
- 避免不必要的计算
- 使用 `memo` 避免子组件不必要的重渲染

---

## 3. 提取默认非原始参数值

### 问题

当 `memo` 组件的默认参数是一个函数或对象时，每次重渲染都会创建新的引用，破坏记忆化。

### 错误示例

```tsx
const UserAvatar = memo(function UserAvatar({
  onClick = () => {}  // 问题：每次都有不同的值
}: { onClick?: () => void }) {
  return <button onClick={onClick}>Avatar</button>
})

// 父组件每次重渲染，UserAvatar 也会重渲染
function Parent() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <UserAvatar />
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
    </div>
  )
}
```

### 正确示例

```tsx
// 优化：提取到常量
const NOOP = () => {}

const UserAvatar = memo(function UserAvatar({
  onClick = NOOP
}: { onClick?: () void }) {
  return <button onClick={onClick}>Avatar</button>
})

// 父组件重渲染时，UserAvatar 不会重渲染
function Parent() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <UserAvatar />
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
    </div>
  )
}
```

### 为什么重要

- 恢复记忆化
- 避免不必要的子组件重渲染
- 减少引用比较的开销

---

## 4. 缩窄 Effect 依赖

### 问题

当 Effect 的依赖过于宽泛时，会导致 Effect 在不应该运行时重新执行。

### 错误示例

```tsx
function UserComponent({ user }: { user: User }) {
  useEffect(() => {
    console.log('User ID:', user.id)
  }, [user])  // 问题：user 任何字段变化都会重新运行
}
```

### 正确示例

```tsx
function UserComponent({ user }: { user: User }) {
  // 优化：只依赖真正需要的字段
  useEffect(() => {
    console.log('User ID:', user.id)
  }, [user.id])  // 只在 id 变化时重新运行
}
```

### 为什么重要

- 最小化 effect 重新运行
- 避免不必要的副作用
- 提高性能

---

## 5. 订阅派生状态

### 问题

订阅原始状态而不是派生状态，会导致更频繁的重渲染。

### 错误示例

```tsx
function Sidebar() {
  // 问题：width 持续更新，导致频繁重渲染
  const width = useWindowWidth()
  const isMobile = width < 768
  return <nav className={isMobile ? 'mobile' : 'desktop'} />
}
```

### 正确示例

```tsx
function Sidebar() {
  // 优化：直接订阅派生状态
  const isMobile = useMediaQuery('(max-width: 767px)')
  return <nav className={isMobile ? 'mobile' : 'desktop'} />
}

// 实现 useMediaQuery
function useMediaQuery(query: string) {
  const [matches, setMatches] = useState(false)

  useEffect(() => {
    const media = window.matchMedia(query)
    setMatches(media.matches)

    const handler = (e: MediaQueryListEvent) => setMatches(e.matches)
    media.addEventListener('change', handler)
    return () => media.removeEventListener('change', handler)
  }, [query])

  return matches
}
```

### 为什么重要

- 减少重渲染频率
- 只在真正需要时更新
- 更精确的状态管理

---

## 6. 在渲染期间计算派生状态

### 问题

使用 Effect 来同步派生状态会导致额外的重渲染和状态漂移。

### 错误示例

```tsx
function Form() {
  const [firstName, setFirstName] = useState('First')
  const [lastName, setLastName] = useState('Last')
  const [fullName, setFullName] = useState('')

  // 问题：额外的 Effect 和重渲染
  useEffect(() => {
    setFullName(firstName + ' ' + lastName)
  }, [firstName, lastName])

  return <p>{fullName}</p>
}
```

### 正确示例

```tsx
function Form() {
  const [firstName, setFirstName] = useState('First')
  const [lastName, setLastName] = useState('')

  // 优化：直接计算派生状态
  const fullName = firstName + ' ' + lastName

  return <p>{fullName}</p>
}
```

### 为什么重要

- 避免冗余渲染
- 避免状态漂移
- 更简洁的代码

---

## 7. 使用函数式 setState 更新

### 问题

使用状态值来更新状态会导致过时闭包和回调不稳定。

### 错误示例

```tsx
function TodoList() {
  const [items, setItems] = useState(initialItems)

  // 问题 1：依赖 items，每次 items 变化都重新创建
  const addItems = useCallback((newItems: Item[]) => {
    setItems([...items, ...newItems])
  }, [items])

  // 问题 2：缺少依赖，过时闭包
  const removeItem = useCallback((id: string) => {
    setItems(items.filter(item => item.id !== id))
  }, [])

  return <div>{/* ... */}</div>
}
```

### 正确示例

```tsx
function TodoList() {
  const [items, setItems] = useState(initialItems)

  // 优化 1：使用函数式更新，依赖稳定
  const addItems = useCallback((newItems: Item[]) => {
    setItems(curr => [...curr, ...newItems])
  }, [])

  // 优化 2：安全且稳定
  const removeItem = useCallback((id: string) => {
    setItems(curr => curr.filter(item => item.id !== id))
  }, [])

  return <div>{/* ... */}</div>
}
```

### 为什么重要

- 防止过时闭包
- 避免不必要的回调重新创建
- 更安全的状态更新

---

## 8. 使用惰性状态初始化

### 问题

将昂贵的计算直接传递给 `useState` 会导致每次渲染时都执行该计算。

### 错误示例

```tsx
function FilteredList({ items }: { items: Item[] }) {
  // 问题：buildSearchIndex() 在每次渲染时都执行
  const [searchIndex, setSearchIndex] = useState(buildSearchIndex(items))
  return <SearchResults index={searchIndex} query={query} />
}
```

### 正确示例

```tsx
function FilteredList({ items }: { items: Item[] }) {
  // 优化：buildSearchIndex() 只在初始渲染时执行
  const [searchIndex, setSearchIndex] = useState(() => buildSearchIndex(items))
  return <SearchResults index={searchIndex} query={query} />
}
```

### 为什么重要

- 避免每次渲染时的浪费计算
- 只在需要时执行昂贵操作
- 提高性能

---

## 9. 不要用 useMemo 包装简单表达式

### 问题

对简单的原始值或简单计算使用 `useMemo`，`useMemo` 本身的开销可能比计算本身更大。

### 错误示例

```tsx
function Header({ user, notifications }: Props) {
  // 问题：简单表达式不需要 useMemo
  const isLoading = useMemo(() => {
    return user.isLoading || notifications.isLoading
  }, [user.isLoading, notifications.isLoading])

  return <div>{isLoading ? 'Loading...' : 'Ready'}</div>
}
```

### 正确示例

```tsx
function Header({ user, notifications }: Props) {
  // 优化：直接计算
  const isLoading = user.isLoading || notifications.isLoading

  return <div>{isLoading ? 'Loading...' : 'Ready'}</div>
}
```

### 使用 useMemo 的准则

| 情况 | 是否使用 useMemo |
|------|------------------|
| 简单原始值计算 | ❌ 不需要 |
| 对象/数组创建 | ✅ 需要如果被依赖 |
| 昂贵计算 | ✅ 需要 |
| 传递给 memo 子组件 | ✅ 需要 |

### 为什么重要

- `useMemo` 和依赖比较可能消耗更多资源
- 简单表达式直接计算更快
- 只在真正需要时使用 `useMemo`

---

## 10. 将交互逻辑放在事件处理程序中

### 问题

将交互逻辑放在 Effect 中会导致 Effect 重新运行和重复副作用。

### 错误示例

```tsx
function Form() {
  const [submitted, setSubmitted] = useState(false)
  const theme = useContext(ThemeContext)

  useEffect(() => {
    if (submitted) {
      post('/api/register')
      showToast('Registered', theme)
    }
  }, [submitted, {theme})  // 问题：依赖 theme，每次主题变化都可能触发

  return <button onClick={() => setSubmitted(true)}>Submit</button>
}
```

### 正确示例

```tsx
function Form() {
  const theme = useContext(ThemeContext)

  // 优化：交互逻辑在事件处理程序中
  function handleSubmit() {
    post('/api/register')
    showToast('Registered', theme)
  }

  return <button onClick={handleSubmit}>Submit</button>
}
```

### 为什么重要

- 避免 effect 重新运行
- 避免重复副作用
- 更符合 React 模式

---

## 11. 对非紧急更新使用 Transitions

### 问题

频繁的状态更新（如滚动位置）会阻塞 UI，导致卡顿。

### 错误示例

```tsx
function ScrollTracker() {
  const [scroll, setScroll] = useState(0)

  useEffect(() => {
    // 问题：每次滚动都立即更新，可能阻塞 UI
    const handler = () => setScroll(window.scrollY)
    window.addEventListener('scroll', handler, { passive: true })
    return () => window.removeEventListener('scroll', handler)
  }, [])

  return <div>Scroll: {scroll}px</div>
}
```

### 正确示例

```tsx
import { startTransition } from 'react'

function ScrollTracker() {
  const [scroll, setScroll] = useState(0)

  useEffect(() => {
    // 优化：使用 transition，不阻塞 UI
    const handler = () => {
      startTransition(() => setScroll(window.scrollY))
    }
    window.addEventListener('scroll', handler, { passive: true })
    return () => window.removeEventListener('scroll', handler)
  }, [])

  return <div>Scroll: {scroll}px</div>
}
```

### 为什么重要

- 保持 UI 响应性
- 非紧急更新不阻塞用户交互
- 更好的用户体验

---

## 12. 使用 useRef 存储瞬态值

### 问题

频繁更新的状态（如鼠标位置）会导致大量重渲染。

### 错误示例

```tsx
function Tracker() {
  const [lastX, setLastX] = useState(0)

  useEffect(() => {
    // 问题：每次鼠标移动都重渲染
    const onMove = (e: MouseEvent) => setLastX(e.clientX)
    window.addEventListener('mousemove', onMove)
    return () => window.removeEventListener('mousemove', onMove)
  }, [])

  return <div style={{ left: lastX }}>Dot</div>
}
```

### 正确示例

```tsx
function Tracker() {
  const dotRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    // 优化：直接操作 DOM，不触发重渲染
    const onMove = (e: MouseEvent) => {
      const node = dotRef.current
      if (node) {
        node.style.transform = `translateX(${e.clientX}px)`
      }
    }
    window.addEventListener('mousemove', onMove)
    return () => window.removeEventListener('mousemove', onMove)
  }, [])

  return <div ref={dotRef} style={{ transform: 'translateX(0px)' }}>Dot</div>
}
```

### 为什么重要

- 避免频繁更新时的不必要重渲染
- 直接操作 DOM 更高效
- 适用于瞬态值

---

## 总结

重渲染优化是 React 性能优化的核心：

| 规则 | 优先级 | 影响 |
|------|--------|------|
| 延迟状态读取 | 中 | 避免不必要的订阅 |
| 提取到 memo 组件 | 中 | 启用早期返回 |
| 提取默认参数 | 中 | 恢复记忆化 |
| 缩窄 Effect 依赖 | 中 | 最小化 effect 重新运行 |
| 订阅派生状态 | 中 | 减少重渲染频率 |
| 派生状态计算 | 中 | 避免冗余渲染 |
| 函数式 setState | 中 | 稳定的回调 |
| 惰性状态初始化 | 中 | 避免浪费计算 |
| 简单表达式不用 useMemo | 中 | 减少开销 |
| 逻辑在事件处理程序 | 中 | 避免重复副作用 |
| 使用 Transitions | 中 | 保持 UI 响应 |
| useRef 存储瞬态值 | 中 | 避免频繁重渲染 |

### 核心原则

1. **延迟读取**：只在需要时读取状态
2. **记忆化**：使用 `memo` 和 `useMemo` 适当
3. **派生状态**：直接计算，不存储
4. **函数式更新**：使用函数式 setState
5. **事件处理**：将逻辑放在事件处理程序中
6. **非阻塞**：使用 transitions 保持响应

### 检查清单

- [ ] 是否有不必要的顶层状态读取？
- [ ] memo 组件的默认参数是否是常量？
- [ ] Effect 依赖是否精确？
- [ ] 派生状态是否直接计算？
- [ ] 是否使用函数式 setState？
- [ ] 是否使用 transitions 处理非紧急更新？
- [ ] 频繁更新的值是否使用 useRef？
