# 位运算<!-- omit in toc -->

## 原码、反码、补码

### 原码

| 十进制 |   原码    |
| :----: | :-------: |
|   2    | 0000 0010 |
|   -2   | 1000 0010 |

原码其实是最容易理解的，只不过需要利用二进制中的第一位来表示符号位，`0` 表示正数，`1` 表示负数，所以可以看到，一个数字用二进制原码表示的话，取值范围是 `-111 1111 ~ +111 1111`，换成十进制就是 `-127 ~ 127`。

### 反码

在数学中我们有加减乘除，而对于计算机来说最好只有加法，这样计算机会更加简单高效，我们知道在数学中 `5 - 3 = 2`，其实可以转换成 `5 + (-3) = 2` ，这就表示减法可以用加法表示，而乘法是加法的累积，除法是减法的累积，所以在计算机中只要有加法就够了。

一个数字用原码表示是容易理解的，但是需要单独的一个 `bit` 来表示符号位。并且在进行加法时，计算机需要先识别某个二进制原码是正数还是负数，识别出来之后再进行相应的运算。这样效率不高，能不能让计算机在进行运算时不用去管符号位，也就是说**让符号位也参与运算**，这就要用到反码。

| 十进制 |   原码    |   反码    |
| :----: | :-------: | :-------: |
|   2    | 0000 0010 | 0000 0010 |
|   -2   | 1000 0010 | 1111 1101 |

**正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。**

用反码直接运算：

| 十进制 | 原码      | 反码      |
| ------ | --------- | --------- |
| 5      | 0000 0101 | 0000 0101 |
| -3     | 1000 0011 | 1111 1100 |

```js
  5-3
= 5+(-3)
= 0000 0101(反码) + 1111 1100(反码)
= 0000 0001(反码)
= 0000 0001(原码)
= 1
```

这不对呀? `5 - 3 = 1`？为什么差了 `1`？

我们来看一个特殊的运算：

```js
  1-1
= 1+(-1)
= 0000 0001(反码) + 1111 1110(反码)
= 1111 1111(反码)
= 1000 0000(原码)
= -0

  0+0
= 0000 0000(反码) + 0000 0000(反码)
= 0000 0000(反码)
= 0000 0000(原码)
= 0
```

我们可以看到 `1000 0000` 表示 `-0`，`0000 0000` 表示 `0`，虽然`-0` 和 `0` 是一样的，但是在用原码和反码表示时是不同的，我们可以理解为在用一个字节表示数字取值范围时，这些数字中多了一个 `-0`，所以**导致我们在用反码直接运算时符号位可以直接参加运算，但是结果会不对**。

### 补码

**为了解决反码的问题就出现了补码**。

**正数的补码和原码、反码一样，负数的补码就是 `反码 +1`。**

| 十进制 | 原码      | 反码      | 补码      |
| ------ | --------- | --------- | --------- |
| 5      | 0000 0101 | 0000 0101 | 0000 0101 |
| -3     | 1000 0011 | 1111 1100 | 1111 1101 |

```js
  5-3
= 5+(-3)
= 0000 0101(补码) + 1111 1101(补码)
= 0000 0010(补码)
= 0000 0010(原码)
= 2

  1-1
= 1+(-1)
= 0000 0001(补码) + 1111 1111(补码)
= 0000 0000(补码)
= 0000 0000(原码)
= 0

  0+0
= 0000 0000(补码) + 0000 0000(补码)
= 0000 0000(补码)
= 0000 0000(原码)
= 0
```

所以，我们可以看到补码解决了反码的问题。

**所以对于数字，我们可以使用补码的形式来进行二进制表示**。

## 位移运算

`JavaScript` 中有三个位移运算：

- `<<`：左移
- `>>`：右移
- `>>>`：无符号右移

### 正数位移运算

```js
console.log(2 << 1) // 4
console.log(2 >> 1) // 1
```

位运算是基于二进制 `bit` 来的，所以我们需要将十进制转换为二进制之后再进行运算：

- `2 << 1`：十进制 `2` 转换成二进制为 `00000000 00000000 00000000 00000010`，再将二进制左移一位，**高位丢弃，低位补 `0`**，所以结果为 `00000000 00000000 00000000 00000100`，换算成十进制则为 `4`

- `2 >> 1`：十进制 `2` 转换成二进制为 `00000000 00000000 00000000 00000010`，再将二进制右移一位，**低位丢弃，高位补 `0`**，所以结果为 `00000000 00000000 00000000 00000001`，换算成十进制则为 `1`

### 负数位移运算

我们再来看 `-2 << 1` 与 `-2 >> 1`

| 十进制 | 原码                                | 反码                                | 补码                                |
| ------ | ----------------------------------- | ----------------------------------- | ----------------------------------- |
| 2      | 00000000 00000000 00000000 00000010 | 00000000 00000000 00000000 00000010 | 00000000 00000000 00000000 00000010 |
| -2     | 10000000 00000000 00000000 00000010 | 11111111 11111111 11111111 11111101 | 11111111 11111111 11111111 11111110 |

> **规则：**
>
> 1. 在对补码进行移动时，**符号位是固定不动的**。
>
> 2. 所有的按位操作符的操作数都会被**转成补码**形式的有符号 `32` 位整数。
>
> 3. 按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即**正数补 `0`，负数补 `1`**。

`-2 << 1`，表示 `-2` 的补码左移一位后为 `10000000 00000000 00000000 00000010`，该补码对应的反码为：

```js
  11111111 11111111 11111111 11111100
- 1
= 11111111 11111111 11111111 11111011
```

该反码对应的原码为：符号位不变，其他位取反，为 `10000000 00000000 00000000 00000100` 十进制表示为 `-4`

同理 `-2 >> 2`，表示 `-2` 的补码右移 `2` 位（低位丢弃，高位补 `1`）后为 `11111111 11111111 11111111 11111111`，该补码对应的反码为：

```js
  10111111 11111111 11111111 11111111
- 1
= 11111111 11111111 11111111 11111110
```

该反码对应的原码为：符号位不变，其他位取反，为 `10000000 00000000 00000000 00000001` 十进制表示为 `-1`

### 无符号右移

上面在进行左移和右移时，在对补码进行移动时，符号位是固定不动的，而无符号右移是指在进行移动时，符号位也会跟着一起移动。 比如 `-2 >>> 1`。

- -2 用原码表示为 `10000000 00000000 00000000 00000010`
- -2 用反码表示为 `11111111 11111111 11111111 11111101`
- -2 用补码表示为 `11111111 11111111 11111111 11111110`
- -2 的补码右移 `1` 位为：`01111111 11111111 11111111 11111111`

右移后的补码对应的反码、原码为：`01111111 11111111 11111111 11111111` （因为现在的符号位为 `0`，表示正数，**正数的原、反、补码都相同**）

所以，对应的十进制为 `-2 >>> 1 = 2147483647`

### 总结

```js
2 << 1 = 4 = 2 * 2
2 << 2 = 8 = 2 * 2 * 2
2 << n = 2 * (2 的 n 次方)
m << n = m * (2 的 n 次方)
```

## 逻辑运算

按位操作符将其操作数当作 `32` 位的比特序列（由 `0` 和 `1` 组成）操作，返回值依然是标准的 `JavaScript` 数值。`JavaScript` 中的按位操作符有

|       运算符       |   用法    |                                          描述                                           |
| :----------------: | :-------: | :-------------------------------------------------------------------------------------: |
|   按位与（AND）    |  `a & b`  |   对于每一个比特位，只有两个操作数相应的比特位都是 `1` 时，结果才为 `1`，否则为 `0`。   |
|    按位或（OR）    | `a \| b`  |  对于每一个比特位，当两个操作数相应的比特位至少有一个 `1` 时，结果为 `1`，否则为 `0`。  |
|  按位异或（XOR）   |  `a ^ b`  | 对于每一个比特位，当两个操作数相应的比特位有且只有一个 `1` 时，结果为 `1`，否则为 `0`。 |
|   按位非（NOT）    |   `~a`    |                   反转操作数的比特位，即 `0` 变成 `1`，`1` 变成 `0`。                   |
| 左移（Left shift） | `a << b`  |              将 a 的二进制形式向左移 `b (< 32)` 比特位，右边用 `0` 填充。               |
|     有符号右移     | `a >> b`  |                将 `a` 的二进制表示向右移 `b (< 32)` 位，丢弃被移出的位。                |
|     无符号右移     | `a >>> b` |    将 `a` 的二进制表示向右移 `b (< 32)` 位，丢弃被移出的位，并使用 `0` 在左侧填充。     |

下面举几个例子，主要看下 `AND` 和 `OR`

```js
# 例子1
    A = 10001001
    B = 10010000
A | B = 10011001

# 例子2
    A = 10001001
    C = 10001000
A | C = 10001001
```

```js
# 例子1
    A = 10001001
    B = 10010000
A & B = 10000000

# 例子2
    A = 10001001
    C = 10001000
A & C = 10001000
```

## 常用的按位运算技巧

`& 1` 运算可以“快速”判断奇数还是偶数

```js
6 & 1 // 0 , 偶数
9921 & 1 // 1 , 奇数
```

`| 0` 运算可以向下取整，不同于 `Math.floor`，小数位会直接舍弃

```js
;7.998 | (0 / 7 - 7.98) | (0 / -7)
```

按位异或 `^` 在不使用第三变量的值得情况下交换两个变量的值

```js
let a = 5,
  b = 6

a = a ^ b
b = a ^ b
a = a ^ b
```

按位非 `~`

```js
// 常用判断
if (arr.indexOf(item) > -1) {
  // code
}
// 按位非 ~-1 = - (-1 + 1)
if (~arr.indexOf(item)) {
  // code
}
```
