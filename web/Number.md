# 位运算

原码、反码、补码
接下来我们主要介绍十进制数用二进制表示的不同方法，所以为了简洁，我们用一个字节，也就是 8 个 bit 来表示二进制数。
原码

十进制
原码

2
0000 0010

-2
1000 0010

原码其实是最容易理解的，只不过需要利用二进制中的第一位来表示符号位，0 表示正数，1 表示负数，所以可以看到，一个数字用二进制原码表示的话，取值范围是-111 1111 ~ +111 1111，换成十进制就是-127 ~ 127。

反码
在数学中我们有加减乘除，而对于计算机来说最好只有加法，这样计算机会更加简单高效，我们知道在数学中 5-3=2，其实可以转换成 5+(-3)=2，这就表示减法可以用加法表示，而乘法是加法的累积，除法是减法的累积，所以在计算机中只要有加法就够了。
一个数字用原码表示是容易理解的，但是需要单独的一个 bit 来表示符号位。并且在进行加法时，计算机需要先识别某个二进制原码是正数还是负数，识别出来之后再进行相应的运算。这样效率不高，能不能让计算机在进行运算时不用去管符号位，也就是说让符号位也参与运算，这就要用到反码。

十进制
原码
反码

2
0000 0010
0000 0010

-2
1000 0010
1111 1101

正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。

  5-3
= 5+(-3)
= 0000 0101(反码) + 1111 1100(反码) 
= 0000 0001(反码)
= 0000 0001(原码) 
= 1

这不对呀?!! 5-3=1?，为什么差了1？
我们来看一个特殊的运算：
  1-1
= 1+(-1)
= 0000 0001(反码) + 1111 1110(反码)
= 1111 1111(反码)
= 1000 0000(原码)
= -0
复制代码我们来看一个特殊的运算：
  0+0
= 0000 0000(反码) + 0000 0000(反码)
= 0000 0000(反码)
= 0000 0000(原码)
= 0
复制代码我们可以看到1000 0000表示-0，0000 0000表示0，虽然-0和0是一样的，但是在用原码和反码表示时是不同的，我们可以理解为在用一个字节表示数字取值范围时，这些数字中多了一个-0，所以导致我们在用反码直接运算时符号位可以直接参加运算，但是结果会不对。

作者：1点25
链接：https://juejin.cn/post/6844903912425259022
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

正数的补码和原码、反码一样，负数的补码就是反码+1。

十进制
原码
反码
补码




5
0000 0101
0000 0101
0000 0101


-3
1000 0011
1111 1100
1111 1101



  5-3
= 5+(-3)
= 0000 0101(补码) + 1111 1101(补码)
= 0000 0010(补码)
= 0000 0010(原码) 
= 2
复制代码5-3=2！！正确。
再来看特殊的：
  1-1
= 1+(-1)
= 0000 0001(补码) + 1111 1111(补码)
= 0000 0000(补码)
= 0000 0000(原码)
= 0
复制代码1-1=0！！正确
再来看一个特殊的运算：
  0+0
= 0000 0000(补码) + 0000 0000(补码)
= 0000 0000(补码)
= 0000 0000(原码)
= 0
复制代码0+0=0！！也正确。
所以，我们可以看到补码解决了反码的问题。
所以对于数字，我们可以使用补码的形式来进行二进制表示。

作者：1点25
链接：https://juejin.cn/post/6844903912425259022
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

负数位移运算
我们再来看-2 << 1与-2 >> 1。
-2用原码表示为10000000 00000000 00000000 00000010
-2用反码表示为11111111 11111111 11111111 11111101
-2用补码表示为11111111 11111111 11111111 11111110
-2 << 1，表示-2的补码左移一位后为11111111 11111111 11111111 11111100，该补码对应的反码为
  11111111 11111111 11111111 11111100
- 1
= 11111111 11111111 11111111 11111011
复制代码该反码对应的原码为：符号位不变，其他位取反，为10000000 00000000 00000000 00000100，表示-4。
所以-2 << 1 = -4。
同理-2 >> 1是一样的计算方法，这里就不演示了。
无符号右移
上面在进行左移和右移时，我有一点没讲到，就是在对补码进行移动时，符号位是固定不动的，而无符号右移是指在进行移动时，符号位也会跟着一起移动。
比如-2 >>> 1。


作者：1点25
链接：https://juejin.cn/post/6844903912425259022
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

无符号右移
上面在进行左移和右移时，我有一点没讲到，就是在对补码进行移动时，符号位是固定不动的，而无符号右移是指在进行移动时，符号位也会跟着一起移动。
比如-2 >>> 1。
-2用原码表示为10000000 00000000 00000000 00000010
-2用反码表示为11111111 11111111 11111111 11111101
-2用补码表示为11111111 11111111 11111111 11111110
-2的补码右移1位为：01111111 11111111 11111111 11111111
右移后的补码对应的反码、原码为：01111111 11111111 11111111 11111111 （因为现在的符号位为0，表示正数，正数的原、反、补码都相同）
所以，对应的十进制为2147483647。
也就是-2 >>> 1 = 2147483647

作者：1点25
链接：https://juejin.cn/post/6844903912425259022
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

2 << 1 = 4 = 2*2

2 << 2 = 8 = 2*2*2

2 << n = 2 * (2的n次方)

m << n = m * (2的n次方)

无符号右移补0，右移补1

所有的按位操作符的操作数都会被转成补码形式的有符号32位整数。补码形式是指一个数的负对应值（如 5和-5）为数值的所有比特位反转后，再加1。
例如：
1 = 00000000000000000000000000000001
-1 的二进制表示，就是 1 的所有比特位反转后，再加1，所以：
-1 = 11111111111111111111111111111111
 ～-1 自然就是 0 了。
有符号32位，最左边的比特位被称为符号位。负数是1，正数是0。
1 = 00000000000000000000000000000001
～1 = 11111111111111111111111111111110
11111111111111111111111111111110 显然是个负数，那它是哪个数“所有比特位反转后，再加1”得来的呢？自然是：00000000000000000000000000000010，也就是2，2对应的负数是-2，所以 ～1 = -2。

为什么不要在 JavaScript 中使用位操作符？
你站在山外看，影影绰绰捕捉到一点都觉得惊为天人
